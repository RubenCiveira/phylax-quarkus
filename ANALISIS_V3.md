# Auditoría Arquitectónica V3: Phylax API — Perspectiva del Generador de Código

Proyecto: IAM/OAuth 2.0 Server · Framework: Quarkus 3.30.2 · Java 21
Análisis enfocado en el **generador de código** y en cómo `commons` da forma a aplicaciones tipo maestros.

---

## 1. Qué genera el generador y qué aporta Commons

### 1.1 Generadores identificados (por marcas `@autogenerated`)

| Generador | Qué produce | Capa |
|-----------|-------------|------|
| `CreateInputGenerator` / `UpdateInputGenerator` | Clases `*CreateInput` / `*UpdateInput` con Optional\<VO\>, dual overload (raw + VO), builder, fluent setters | Application |
| `CreateProjectionGenerator` / `UpdateProjectionGenerator` / `ListProjectionGenerator` / `RetrieveProjectionGenerator` | Projections inmutables con getters unwrapped y `getOrDefault()` | Application |
| `CreateUsecaseGenerator` / `UpdateUsecaseGenerator` / `EnableUsecaseGenerator` ... | UseCases con `@Observed`, events CDI, visibilidad, auditoría, cache | Application |
| `CreateControllerGenerator` / `UpdateControllerGenerator` / `ListControllerGenerator` ... | Controllers REST con `toDomainModel()` / `toApiModel()` | Infrastructure/Driver |
| `WriteAdaterGatewayGenerator` / `ReadAdaterGatewayGenerator` | Gateway adapters con tracing manual (spans OpenTelemetry) | Infrastructure/Driven |
| `RepositoryJdbcGenerator` | Repositorios JDBC con SQL inline, converter, filteredQuery, cursor-based pagination | Infrastructure/Repository |
| `EventDispatcherGenerator` | Dispatchers CDI minimalistas | Infrastructure/Event |
| `EntityChangeSetGenerator` | ChangeSets con @Delegate a ValueHolders | Domain |
| `ValueHolderGenerator` | ValueHolders genéricos con triple overload (raw, VO, Optional) | Domain |

### 1.2 Qué aporta Commons (infraestructura compartida)

| Componente Commons | Rol | Usado por |
|-------------------|-----|-----------|
| `@Observed` + `ObservedInterceptor` / `TelemetryInterceptor` | Interceptor CDI que crea spans OpenTelemetry de forma declarativa | UseCases (eliminan boilerplate de tracing) |
| `@ApiObserved` + `ApiObservedInterceptor` | Igual pero con SpanKind.SERVER para API REST | Controllers |
| `Trace` (clase estática) | Métodos `setAttribute()` / `addEvent()` null-safe sobre el span actual | UseCases, Controllers |
| `CurrentRequest` | Contexto HTTP: interaction, actor, locale, public host, cacheable response | Controllers |
| `SqlTemplate` / `SqlQuery` / `SqlCommand` / `SqlSchematicQuery` | Framework SQL custom sin ORM: queries tipadas, binding de parámetros, converter | Repositories |
| `SqlParameterValue` / `SqlListParameterValue` / `SqlOperator` | Value types para parámetros SQL con null-safety | Repositories |
| `Slider<T>` | Paginación por cursor con iterador lazy | Repositories |
| `Validator<T>` (FunctionalInterface composable) | Validación encadenable AND/OR/NEGATE | Value Objects |
| `AesCipherService` | Cifrado AES para campos sensibles (passwords) | UseCases, Projections |
| `InMemoryCache<K,V>` | Cache TTL con max-size | Gateways |
| `RemoteConnector` / `MunityWebConnector` | Cliente HTTP reactivo con OpenTelemetry | Projections remotas |
| `BucketService` / `RateLimitingFilter` | Rate limiting por IP con token bucket | Bootstrap |
| `SecurityFilter` + `MaliciousInjectionRiskAnalizer` | Análisis de riesgo por inyección (SQL, XSS, LDAP, etc.) | Bootstrap |
| Exception Mappers (`AbstractFailMapper`, `ThrowableMapper`, SQL mappers) | Traducción de excepciones a respuestas HTTP | Bootstrap |

---

## 2. Mejoras ya implementadas respecto al análisis original

### 2.1 Tracing declarativo en UseCases — RESUELTO

**Problema original:** El 70% de cada UseCase era boilerplate de tracing (try/catch/finally con Span).

**Solución implementada:** El generador ahora produce UseCases que usan `@Observed("descripción")` de Commons. El interceptor CDI `TelemetryInterceptor` gestiona el ciclo de vida del span:

```java
// ANTES (generado): ~25 líneas por método
Span span = tracer.spanBuilder("Creating an entity of tenant")
    .setParent(Context.current().with(Span.current()))
    .setSpanKind(SpanKind.INTERNAL).startSpan();
try {
    // 5 líneas de lógica
} catch (RuntimeException ex) {
    span.setAttribute("error", true);
    span.recordException(ex);
    throw ex;
} finally {
    span.end();
}

// AHORA (generado): 1 anotación + lógica directa
@Observed("Creating an entity of tenant")
public TenantCreateProjection create(Interaction query, TenantCreateInput input) {
    // solo lógica de negocio
    Trace.addEvent("The input value is filled with the fixed values...");
    // ...
}
```

**Impacto:** Reducción de ~70% de líneas en UseCases. Los métodos pasan de ~25 líneas a ~8.

### 2.2 Typo "Dispacher" → "Dispatcher" — RESUELTO

**Problema original:** El generador propagaba "Dispacher" en todos los dispatchers.

**Estado actual:** Todos los EventDispatcher están correctamente nombrados. Verificado en los 12 dispatchers del proyecto (Tenant, User, Role, ApiKeyClient, TrustedClient, etc.).

### 2.3 Telemetría modularizada — RESUELTO

Commons provee una arquitectura de telemetría limpia:
- `@Observed` → SpanKind.INTERNAL (operaciones internas)
- `@ApiObserved` → SpanKind.SERVER (endpoints REST)
- `Trace` → utilidad estática null-safe para enriquecer spans
- `TelemetryInterceptor` → lógica compartida, package-private, con degradación graceful si no hay Tracer

### 2.4 NotFoundException con mensajes contextuales — PARCIALMENTE RESUELTO

En Repositories, `resolve()` y `resolveForUpdate()` ahora incluyen el uid:
```java
throw new NotFoundException("Trying to resolve inexistent Tenant: " + reference.getUid());
```

Pero `verified()` sigue usando string vacío:
```java
throw new NotFoundException(""); // falta contexto
```

Y `OptimistLockException` usa mensaje confuso:
```java
throw new OptimistLockException("No delete from"); // dice "delete" en un update
```

---

## 3. Problemas pendientes — Perspectiva del generador

### 3.1 CAPA CONTROLLER (Driver REST) — Prioridad ALTA

#### 3.1.1 Mapeo campo a campo sin utilidad de soporte

**Problema:** Cada controller genera `toDomainModel()` y `toApiModel()` con mapeo manual repetitivo. Para Tenant (8 campos) son ~20 líneas; para User (14 campos) son ~45 líneas. Se repite en Create, Update, Retrieve, List, Enable, Disable... sumando cientos de líneas idénticas por entidad.

```java
// toDomainModel — patrón repetido por cada campo:
if (null != tenantApiDto.getUid()) { dto.setUid(tenantApiDto.getUid()); }
if (null != tenantApiDto.getName()) { dto.setName(tenantApiDto.getName()); }
// ... N campos más

// toApiModel — patrón repetido por cada campo:
tenantApiDto.setUid(dto.getUid());
tenantApiDto.setName(dto.getName());
// ... N campos más
```

**Variantes especiales que el generador maneja inline:**
- Referencias: `dto.setTenant(TenantReference.of(apiDto.getTenant().get$Ref()))`
- Passwords enmascarados: `if (!"*****".equals(value))`
- Enums: `approveEnumToDomain()` / `approveEnumToApi()`
- Constantes: `apiDto.setPassword("*****")`

**Mejora propuesta:** Crear en Commons un `RestMapper<S>` fluent que el generador use:

```java
// toDomainModel generado con RestMapper:
RestMapper.from(apiDto)
    .map(TenantApiDto::getUid, dto::setUid)
    .map(TenantApiDto::getName, dto::setName)
    .map(TenantApiDto::getRoot, dto::setRoot)
    // ...

// toApiModel generado con RestMapper:
RestMapper.from(dto)
    .set(Projection::getUid, apiDto::setUid)
    .set(Projection::getTenantReference, apiDto::setTenant, ref -> new TenantApiRef().$ref(ref))
    .constant(apiDto::setPassword, "*****")
    // ...
```

Métodos necesarios en `RestMapper<S>`:
- `map(getter, setter)` — null-safe (para toDomainModel)
- `map(getter, setter, transform)` — null-safe + transformación (referencias, enums)
- `mapIf(getter, setter, filter)` — null-safe + filtro (passwords)
- `set(getter, setter)` — incondicional (para toApiModel)
- `set(getter, setter, transform)` — incondicional + transformación
- `constant(setter, value)` — valor fijo (masking)

#### 3.1.2 Conversión de enums duplicada en todos los controllers de una entidad

**Problema:** `approveEnumToApi()` y `approveEnumToDomain()` se duplican **9 veces** en los controllers de User (Create, Update, Retrieve, List, Accept, Enable, Disable, Reject, Unlock). Cada método tiene ~15 líneas.

**Mejora propuesta:** El generador debería producir una clase `UserEnumMapper` por entidad (o métodos estáticos en un companion) que centralice la conversión. Los controllers solo la referencian.

#### 3.1.3 Lógica de paginación por URL duplicada en ListControllers

**Problema:** `toListApiModel()` repite lógica de construcción de URLs de paginación (self, next, first) con StringBuilder y URLEncoder. Es idéntica en estructura para cada entidad, variando solo los campos de filtro.

**Mejora propuesta:** Crear en Commons un helper de paginación `CursorLinks` que reciba los parámetros y produzca los enlaces. El generador usaría este helper en vez de generar la lógica inline.

### 3.2 CAPA GATEWAY ADAPTER (Driven) — Prioridad ALTA

#### 3.2.1 Tracing manual no migrado a @Observed

**Problema:** Los Gateway Adapters (`WriteGatewayAdapter`, `ReadGatewayAdapter`) **siguen usando tracing manual** con try/catch/finally, a diferencia de los UseCases que ya usan `@Observed`. Esto crea una inconsistencia: la capa de aplicación tiene tracing declarativo pero la capa de infraestructura no.

Cada método del `TenantWriteGatewayAdapter` repite:
```java
Span span = tracer.spanBuilder("...")
    .setParent(Context.current().with(Span.current()))
    .setSpanKind(SpanKind.SERVER).startSpan();
try {
    return repository.xxx(...);
} catch (RuntimeException ex) {
    span.setAttribute("error", true);
    span.recordException(ex);
    throw ex;
} finally {
    span.end();
}
```

**Además:** El método `update()` **no tiene tracing** — es el único método sin span:
```java
@Override
public Tenant update(TenantRef reference, Tenant entity) {
    Tenant result = repository.update(entity);  // SIN tracing
    eventDispatcher.dispatch(entity);
    return result;
}
```

**Mejora propuesta:** El generador debería usar `@Observed` también en los Gateway Adapters, igual que ya hace en UseCases. `@Observed` ya está disponible en Commons y funciona con cualquier bean CDI. Esto eliminaría ~200 líneas de boilerplate por entidad en los adapters.

#### 3.2.2 Typo "WriteAdaterGatewayGenerator" persistente

El comentario `@autogenerated WriteAdaterGatewayGenerator` indica que el nombre del generador tiene typo: **Adater** → debería ser **Adapter**. Lo mismo para `ReadAdaterGatewayGenerator` y `CacheAdaterGatewayGenerator`. El código generado funciona correctamente, pero el nombre del generador en el tooling debería corregirse.

### 3.3 CAPA REPOSITORY — Prioridad MEDIA

#### 3.3.1 SQL como strings gigantes inline

**Problema:** INSERT y UPDATE se generan como strings monolíticas:
```java
"insert into \"access_tenant\" ( \"uid\", \"name\", \"root\", \"domain\", \"enabled\",
\"mark_for_delete\", \"mark_for_delete_time\", \"version\") values ( :uid, :name, :root,
:domain, :enabled, :markForDelete, :markForDeleteTime, :version)"
```

Para User (14+ campos) estas strings son enormes. Un typo en un nombre de columna solo se detecta en runtime.

**Mejora propuesta:** El generador podría producir metadatos de schema y construir SQL a partir de ellos:
```java
// Generado: TenantColumns (metadatos)
static final Column UID = column("uid", "uid");
static final Column NAME = column("name", "name");
static final List<Column> ALL = List.of(UID, NAME, ...);

// SQL construido desde metadatos
String insert = SqlBuilder.insert(TABLE, ALL);
String update = SqlBuilder.update(TABLE, UPDATABLE);
```

#### 3.3.2 Métodos tryToOrderBy* repetidos por cada campo ordenable

Para cada campo sortable, el generador produce un método `tryToOrderByXxxAsc` y `tryToOrderByXxxDesc` con la misma estructura (~15 líneas cada uno). Tenant tiene 4 (name/domain × asc/desc = 4 métodos). User tiene más.

**Mejora propuesta:** Extraer a Commons una abstracción de ordenación por cursor que reciba metadata de campos y genere la lógica automáticamente.

#### 3.3.3 Binding de parámetros duplicado entre INSERT y UPDATE

Los campos se bindean con `sq.with()` tanto en `runCreate()` como en `update()` — misma lista de campos, duplicada:
```java
// En runCreate():
sq.with(UID, SqlParameterValue.of(entity.getUid()));
sq.with(NAME, SqlParameterValue.of(entity.getName()));
// ...

// En update():
sq.with(UID, SqlParameterValue.of(entity.getUid()));
sq.with(NAME, SqlParameterValue.of(entity.getName()));
// ... mismos campos
```

Esto se resolvería con los metadatos de schema + un método `bindAll(schema, entity)`.

#### 3.3.4 Converter con manejo de timestamps frágil

```java
MarkForDeleteTimeVO.from(null == row.getTimestamp(MARK_FOR_DELETE_TIME_SNAKE) ? null
    : OffsetDateTime.ofInstant(
        Instant.ofEpochMilli(row.getTimestamp(MARK_FOR_DELETE_TIME_SNAKE).getTime()),
        ZoneId.systemDefault()))
```

Cada campo `OffsetDateTime` repite este patrón. Debería haber un helper en Commons: `SqlResultSet.getOffsetDateTime(column)`.

### 3.4 CAPA APPLICATION (Projections) — Prioridad BAJA

#### 3.4.1 Projections idénticas multiplicadas por operación

Las 4 projections de Tenant (Create, Update, List, Retrieve) tienen **exactamente 292 líneas** y la misma estructura. La única diferencia es el nombre de la clase. Lo mismo ocurre para cada entidad.

**Mejora propuesta:** El generador podría producir una sola `TenantProjection` base y type aliases o factory methods para cada operación:
```java
public class TenantProjection { /* todos los campos y getters */ }

// Aliases por operación:
public final class TenantCreateProjection extends TenantProjection {}
public final class TenantUpdateProjection extends TenantProjection {}
```

Esto eliminaría ~5 clases de ~300 líneas cada una por entidad.

### 3.5 CAPA DOMAIN — Sin cambios necesarios

Los Value Objects, ValueHolders y ChangeSets están bien diseñados:
- VOs inmutables con `from()` / `tryFrom()` validados
- ValueHolders genéricos con triple overload (raw, VO, Optional)
- ChangeSets con `@Delegate` de Lombok para composición limpia
- Unset/unsetIfMatches para control granular de campos

---

## 4. Scorecard actualizado

| Área | V1 | V3 | Cambio | Notas |
|------|----|----|--------|-------|
| Estructura y organización | 9/10 | 9/10 | = | Hexagonal + DDD ejemplar, sin cambios |
| Patrones de dominio | 9/10 | 9/10 | = | VOs, Agregados, Eventos bien implementados |
| Seguridad | 4/10 | 4/10 | = | CORS abierto, credenciales en config, sin @Valid (pendiente) |
| Testing | 5/10 | 5/10 | = | Buenos unit tests, integración inexistente |
| Resiliencia | 3/10 | 3/10 | = | Sin circuit breaker/retry, rate limiting solo por IP |
| Mantenibilidad para equipo | 5/10 | 6/10 | +1 | Tracing declarativo simplifica lectura de UseCases |
| Observabilidad | 8/10 | 9/10 | +1 | @Observed + @ApiObserved + Trace resuelven boilerplate en app layer |
| API REST | 6/10 | 6/10 | = | OpenAPI presente pero respuestas inconsistentes, mapeo sin optimizar |
| Código generado (NUEVO) | — | 6/10 | — | Buena estructura, pero exceso de boilerplate en controllers y gateways |

---

## 5. Resumen priorizado de mejoras para el generador

| Prioridad | Área | Cambio | Impacto | Esfuerzo |
|-----------|------|--------|---------|----------|
| P0 | Commons | Crear `RestMapper<S>` (utilidad fluent con method references) | Habilita reducción de mapeo en controllers | Bajo |
| P0 | Gateway Generator | Migrar a `@Observed` (igual que UseCases) | -200 líneas/entidad, consistencia, fix update sin tracing | Bajo |
| P0 | Gateway Generator | Corregir typo `Adater` → `Adapter` en nombres de generadores | Credibilidad | Trivial |
| P1 | Controller Generator | Usar `RestMapper` en `toDomainModel`/`toApiModel` | -60% líneas en controllers | Medio |
| P1 | Controller Generator | Centralizar conversión de enums (1 clase por entidad, no 9 copias) | -135 líneas en User controllers | Bajo |
| P1 | Repository Generator | Helper `SqlResultSet.getOffsetDateTime()` en Commons | Elimina patrón frágil de timestamp | Bajo |
| P1 | Repository Generator | Mensaje correcto en `OptimistLockException` (dice "delete" en update) | Debuggabilidad | Trivial |
| P1 | Repository Generator | NotFoundException con contexto en `verified()` | Debuggabilidad | Trivial |
| P2 | Commons | Helper de paginación `CursorLinks` para ListControllers | -50 líneas/ListController | Medio |
| P2 | Repository Generator | Schema metadata + SQL builder (eliminar strings inline) | Fiabilidad, mantenibilidad | Medio |
| P2 | Repository Generator | Refactorizar `tryToOrderBy*` en abstracción genérica | -4 métodos × 15 líneas/entidad | Medio |
| P3 | Projection Generator | Unificar Projections (1 base + herencia, no 4-6 clases idénticas) | -5 clases × 300 líneas/entidad | Medio |
| P3 | Controller Generator | Generar `@Valid` + constraints en DTOs/controllers | Seguridad | Bajo |
| P3 | Tests | Generar tests de UseCase (nivel 2 con mocks) | Confianza en refactoring | Alto |

---

## 6. Conclusión

El generador ha evolucionado bien en la capa de aplicación: los UseCases usan `@Observed` de Commons eliminando el 70% de boilerplate de tracing, el typo "Dispacher" está corregido, y la telemetría está modularizada con interceptores CDI.

**Los principales puntos de mejora se concentran en dos áreas:**

1. **Controllers REST:** El mapeo campo a campo (`toDomainModel`/`toApiModel`) sigue siendo 100% manual y repetitivo. Crear un `RestMapper<S>` en Commons con soporte para method references (consumers) permitiría al generador producir código declarativo en vez de imperativo. Esto impactaría a los ~40+ controllers del proyecto.

2. **Gateway Adapters:** Son la única capa que aún usa tracing manual con try/catch/finally. Migrar a `@Observed` (que ya existe en Commons y funciona) los igualaría con los UseCases y eliminaría ~200 líneas de boilerplate por entidad. Además, corregiría el bug de `update()` sin tracing.

Estas dos mejoras tienen el mejor ratio impacto/esfuerzo y afectan a todo código generado futuro.
