/* @autogenerated */
package net.civeira.phylax.bootstrap.security;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map.Entry;

import io.github.bucket4j.Bucket;
import io.micrometer.core.instrument.MeterRegistry;
import jakarta.annotation.Priority;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Instance;
import jakarta.ws.rs.Priorities;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;
import jakarta.ws.rs.ext.Provider;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.bootstrap.rate.BucketService;

@Provider
@Priority(Priorities.AUTHENTICATION)
@ApplicationScoped
@RequiredArgsConstructor
public class SecurityFilter implements ContainerRequestFilter {
  private final Instance<MaliciousInjectionRiskAnalizer> analizers;

  private final MeterRegistry meterRegistry;

  private final BucketService buckets;

  @Override
  public void filter(ContainerRequestContext requestContext) throws IOException {
    int riskScore = 0;

    // Análisis de headers
    for (String header : requestContext.getHeaders().keySet()) {
      String value = requestContext.getHeaderString(header);
      riskScore += analyzeValue(value);
    }
    for (Entry<String, List<String>> entry : requestContext.getUriInfo().getQueryParameters()
        .entrySet()) {
      for (String value : entry.getValue()) {
        riskScore += analyzeValue(value);
      }
    }
    // Análisis del cuerpo (si es JSON o texto plano)
    String body = extractRequestBody(requestContext);
    if (body != null && !body.isEmpty()) {
      riskScore += analyzeValue(body);
    }

    // Skipping for brevity.
    if (riskScore > 10) {
      // Umbral arbitrario, puedes ajustar esto
      // Registrar métrica en Micrometer
      meterRegistry
          .counter("request.security.risk", "source", requestContext.getUriInfo().getPath())
          .increment();
    }

    Bucket bucket = buckets.resolveBucket(requestContext);

    if (riskScore > 0) {
      if (!bucket.tryConsume(riskScore)) {
        // Limitar la solicitud si no hay tokens
        requestContext.abortWith(Response.status(Status.FORBIDDEN)
            .entity("Request blocked due to security risk").build());
      }
    }
  }

  private int analyzeValue(String value) {
    int riskScore = 0;
    if (value == null || value.isEmpty()) {
      return riskScore;
    }
    for (MaliciousInjectionRiskAnalizer maliciousInjectionRiskAnalizer : analizers) {
      riskScore += maliciousInjectionRiskAnalizer.analyze(value);
    }
    return riskScore;
  }

  private String extractRequestBody(ContainerRequestContext requestContext) throws IOException {
    // Leer el InputStream de la solicitud
    InputStream originalInputStream = requestContext.getEntityStream();
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    byte[] data = new byte[1024];
    int nRead;
    while ((nRead = originalInputStream.read(data, 0, data.length)) != -1) {
      buffer.write(data, 0, nRead);
    }
    buffer.flush();

    // Convertir el buffer a String
    String body = buffer.toString(StandardCharsets.UTF_8);

    // Volver a asignar el InputStream al contexto para futuras lecturas
    InputStream newInputStream = new ByteArrayInputStream(buffer.toByteArray());
    requestContext.setEntityStream(newInputStream);

    return body;
  }
}
