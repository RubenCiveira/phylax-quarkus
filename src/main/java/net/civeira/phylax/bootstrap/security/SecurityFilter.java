/* @autogenerated */
package net.civeira.phylax.bootstrap.security;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.SequenceInputStream;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map.Entry;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import io.github.bucket4j.Bucket;
import io.micrometer.core.instrument.MeterRegistry;
import jakarta.enterprise.inject.Instance;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.bootstrap.rate.BucketService;

// @Provider
// @Priority(Priorities.AUTHENTICATION)
// @ApplicationScoped
@RequiredArgsConstructor
public class SecurityFilter implements ContainerRequestFilter {

  /**
   * Maximum number of bytes read from the request body for injection analysis. Requests with larger
   * bodies are analyzed only up to this limit; the full body is still passed downstream. Prevents
   * unbounded memory allocation when a client sends a very large payload.
   */
  private static final int MAX_BODY_ANALYSIS_BYTES = 512 * 1024; // 512 KB

  private final Instance<MaliciousInjectionRiskAnalyzer> analyzers;

  private final MeterRegistry meterRegistry;

  private final BucketService buckets;

  /**
   * Minimum risk score that causes the request to be rejected immediately. Requests with a score
   * between 1 and this threshold only consume tokens from the IP bucket; requests at or above the
   * threshold are blocked outright and the event is recorded as a metric.
   */
  private final @ConfigProperty(name = "app.security.risk-block-threshold",
      defaultValue = "10") int riskBlockThreshold;

  @Override
  public void filter(ContainerRequestContext requestContext) throws IOException {
    int riskScore = 0;

    // Analyze headers
    for (String header : requestContext.getHeaders().keySet()) {
      String value = requestContext.getHeaderString(header);
      riskScore += analyzeValue(value);
    }

    // Analyze query parameters
    for (Entry<String, List<String>> entry : requestContext.getUriInfo().getQueryParameters()
        .entrySet()) {
      for (String value : entry.getValue()) {
        riskScore += analyzeValue(value);
      }
    }

    // Analyze request body (capped to avoid OOM on large payloads)
    String body = extractRequestBody(requestContext);
    if (body != null && !body.isEmpty()) {
      riskScore += analyzeValue(body);
    }

    if (riskScore >= riskBlockThreshold) {
      meterRegistry
          .counter("request.security.risk", "source", requestContext.getUriInfo().getPath())
          .increment();
      requestContext.abortWith(
          Response.status(Status.FORBIDDEN).entity("Request blocked due to security risk").build());
      return;
    }

    if (riskScore > 0) {
      Bucket bucket = buckets.resolveBucket(requestContext);
      if (!bucket.tryConsume(riskScore)) {
        requestContext.abortWith(Response.status(Status.FORBIDDEN)
            .entity("Request blocked due to security risk").build());
      }
    }
  }

  private int analyzeValue(String value) {
    int riskScore = 0;
    if (value == null || value.isEmpty()) {
      return riskScore;
    }
    for (MaliciousInjectionRiskAnalyzer analyzer : analyzers) {
      riskScore += analyzer.analyze(value);
    }
    return riskScore;
  }

  /**
   * Reads the request body up to {@link #MAX_BODY_ANALYSIS_BYTES} bytes into a buffer, replaces the
   * entity stream so downstream consumers can still read it, and returns the body as a UTF-8 string
   * for analysis.
   */
  private String extractRequestBody(ContainerRequestContext requestContext) throws IOException {
    InputStream originalInputStream = requestContext.getEntityStream();
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    byte[] data = new byte[8192];
    int nRead;
    int totalRead = 0;
    while (totalRead < MAX_BODY_ANALYSIS_BYTES
        && (nRead = originalInputStream.read(data, 0, data.length)) != -1) {
      buffer.write(data, 0, nRead);
      totalRead += nRead;
    }
    String body = buffer.toString(StandardCharsets.UTF_8);

    // Restore entity stream: prepend buffered bytes to the remaining original stream
    InputStream restored = new SequenceInputStream(new ByteArrayInputStream(buffer.toByteArray()),
        originalInputStream);
    requestContext.setEntityStream(restored);

    return body;
  }
}
