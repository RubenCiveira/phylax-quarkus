/* @autogenerated */
package net.civeira.phylax.bootstrap.telemetry;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Collection;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.opentelemetry.sdk.common.CompletableResultCode;
import io.opentelemetry.sdk.trace.data.SpanData;
import io.opentelemetry.sdk.trace.export.SpanExporter;
import io.quarkus.arc.properties.IfBuildProperty;
import jakarta.enterprise.context.ApplicationScoped;
import net.civeira.phylax.bootstrap.telemetry.exporter.JsonSpanRecord;
import net.civeira.phylax.bootstrap.telemetry.exporter.SpanToJsonRecordMapper;

@ApplicationScoped
@IfBuildProperty(name = "quarkus.otel.file.enabled", stringValue = "true")
public class LoggingSpanExporter implements SpanExporter {

  private static final Object LOCK = new Object();

  private final int rotationFiles;

  private final long maxSizeBytes;

  private final Path file;
  private BufferedWriter writer;
  private final ObjectMapper mapper;
  private final SpanToJsonRecordMapper spanMapper;


  public LoggingSpanExporter(
      @ConfigProperty(name = "quarkus.otel.file.path",
          defaultValue = "logs/traces.jsonl") String path,
      @ConfigProperty(name = "max-file-size", defaultValue = "100MB") String maxSizeBytes,
      @ConfigProperty(name = "quarkus.otel.file.rotation.max-backup-index",
          defaultValue = "3") int rotationMaxSize,
      ObjectMapper mapper, SpanToJsonRecordMapper spanMapper) throws IOException {
    super();
    this.rotationFiles = rotationMaxSize;
    this.maxSizeBytes = parseSize(maxSizeBytes);
    this.mapper = mapper;
    this.spanMapper = spanMapper;

    this.file = Path.of(path);

    Files.createDirectories(file.getParent());

    this.writer = openWriter();
  }

  @Override
  public CompletableResultCode export(Collection<SpanData> spans) {
    synchronized (LOCK) {
      try {
        rotateIfNeeded();

        for (SpanData span : spans) {
          JsonSpanRecord record = spanMapper.map(span);
          writer.write(mapper.writeValueAsString(record));
          writer.newLine();
        }
        writer.flush();
        return CompletableResultCode.ofSuccess();

      } catch (Exception e) {
        return CompletableResultCode.ofFailure();
      }
    }
  }

  private void rotateIfNeeded() throws IOException {
    if (!Files.exists(file))
      return;

    long size = Files.size(file);
    if (size < maxSizeBytes)
      return;

    writer.close();

    // Borra el Ãºltimo backup
    Path last = Path.of(file + "." + rotationFiles);
    Files.deleteIfExists(last);

    // Desplaza backups
    for (int i = rotationFiles - 1; i >= 1; i--) {
      Path src = Path.of(file + "." + i);
      if (Files.exists(src)) {
        Files.move(src, Path.of(file + "." + (i + 1)));
      }
    }

    // Mueve el actual a .1
    Files.move(file, Path.of(file + ".1"));

    // Abre nuevo fichero
    writer = openWriter();
  }

  @Override
  public CompletableResultCode flush() {
    synchronized (LOCK) {
      try {
        writer.flush();
        return CompletableResultCode.ofSuccess();
      } catch (IOException e) {
        return CompletableResultCode.ofFailure();
      }
    }
  }

  @Override
  public CompletableResultCode shutdown() {
    synchronized (LOCK) {
      try {
        writer.close();
        return CompletableResultCode.ofSuccess();
      } catch (IOException e) {
        return CompletableResultCode.ofFailure();
      }
    }
  }

  private static long parseSize(String value) {
    String v = value.trim().toUpperCase();

    if (v.endsWith("KB"))
      return Long.parseLong(v.replace("KB", "")) * 1024;
    if (v.endsWith("MB"))
      return Long.parseLong(v.replace("MB", "")) * 1024 * 1024;
    if (v.endsWith("GB"))
      return Long.parseLong(v.replace("GB", "")) * 1024 * 1024 * 1024;

    return Long.parseLong(v); // bytes
  }

  private BufferedWriter openWriter() throws IOException {
    return Files.newBufferedWriter(file, StandardOpenOption.CREATE, StandardOpenOption.WRITE,
        StandardOpenOption.APPEND);
  }

}
