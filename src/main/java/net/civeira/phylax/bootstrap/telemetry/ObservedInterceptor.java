/* @autogenerated */
package net.civeira.phylax.bootstrap.telemetry;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.SpanKind;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Context;
import io.opentelemetry.context.Scope;
import jakarta.annotation.Priority;
import jakarta.enterprise.inject.Instance;
import jakarta.inject.Inject;
import jakarta.interceptor.AroundInvoke;
import jakarta.interceptor.Interceptor;
import jakarta.interceptor.InvocationContext;
import net.civeira.phylax.common.telemetry.Observed;
import net.civeira.phylax.common.telemetry.TelemetrySpanKind;

@Observed
@Interceptor
@Priority(Interceptor.Priority.APPLICATION + 10)
public class ObservedInterceptor {
  @Inject
  Instance<Tracer> tracerInstance;

  @AroundInvoke
  public Object around(final InvocationContext context) throws Exception {
    Observed observed = resolveObserved(context);
    Tracer tracer =
        tracerInstance != null && tracerInstance.isResolvable() ? tracerInstance.get() : null;
    if (tracer == null || observed == null) {
      return context.proceed();
    }

    String spanName = resolveSpanName(observed, context.getMethod());
    Span span = tracer.spanBuilder(spanName).setParent(Context.current().with(Span.current()))
        .setSpanKind(mapKind(observed.kind())).startSpan();

    List<AttributeSpec> specs = parseAttributes(observed.attributes());
    Object[] args = context.getParameters();

    try (Scope scope = span.makeCurrent()) {
      applyAttributes(span, specs, args, null);
      Object result = context.proceed();
      applyAttributes(span, specs, args, result);
      return result;
    } catch (RuntimeException ex) {
      span.setAttribute("error", true);
      span.recordException(ex);
      throw ex;
    } finally {
      span.end();
    }
  }

  private Observed resolveObserved(final InvocationContext context) {
    Method method = context.getMethod();
    if (method != null && method.isAnnotationPresent(Observed.class)) {
      return method.getAnnotation(Observed.class);
    }
    Class<?> targetClass = context.getTarget() != null ? context.getTarget().getClass() : null;
    if (targetClass != null && targetClass.isAnnotationPresent(Observed.class)) {
      return targetClass.getAnnotation(Observed.class);
    }
    return null;
  }

  private String resolveSpanName(final Observed observed, final Method method) {
    if (observed != null && !observed.value().isBlank()) {
      return observed.value();
    }
    if (method == null) {
      return "observed";
    }
    return method.getDeclaringClass().getSimpleName() + "." + method.getName();
  }

  private SpanKind mapKind(final TelemetrySpanKind kind) {
    if (kind == null) {
      return SpanKind.INTERNAL;
    }
    switch (kind) {
      case SERVER:
        return SpanKind.SERVER;
      case CLIENT:
        return SpanKind.CLIENT;
      default:
        return SpanKind.INTERNAL;
    }
  }

  private List<AttributeSpec> parseAttributes(final String[] attributes) {
    List<AttributeSpec> specs = new ArrayList<>();
    if (attributes == null) {
      return specs;
    }
    for (String attribute : attributes) {
      if (attribute == null || attribute.isBlank()) {
        continue;
      }
      int idx = attribute.indexOf('=');
      if (idx < 0) {
        idx = attribute.indexOf(':');
      }
      if (idx <= 0 || idx == attribute.length() - 1) {
        continue;
      }
      String key = attribute.substring(0, idx).trim();
      String expr = attribute.substring(idx + 1).trim();
      if (!key.isEmpty() && !expr.isEmpty()) {
        specs.add(new AttributeSpec(key, expr));
      }
    }
    return specs;
  }

  private void applyAttributes(final Span span, final List<AttributeSpec> specs,
      final Object[] arguments, final Object result) {
    if (specs == null || specs.isEmpty()) {
      return;
    }
    for (AttributeSpec spec : specs) {
      if (spec == null) {
        continue;
      }
      if (result == null && spec.usesResult) {
        continue;
      }
      Object value = resolveExpression(spec.expression, arguments, result);
      if (value != null) {
        span.setAttribute(spec.key, String.valueOf(value));
      }
    }
  }

  private Object resolveExpression(final String expression, final Object[] arguments,
      final Object result) {
    if (expression == null || expression.isBlank()) {
      return null;
    }
    String token = expression.trim();
    if (token.startsWith("#")) {
      token = token.substring(1).trim();
    }
    if (token.isEmpty()) {
      return null;
    }
    if ("result".equals(token)) {
      return result;
    }
    if (token.startsWith("arg")) {
      int index = parseIndex(token.substring(3));
      if (index >= 0 && arguments != null && index < arguments.length) {
        return arguments[index];
      }
    }
    return null;
  }

  private int parseIndex(final String value) {
    if (value == null || value.isBlank()) {
      return -1;
    }
    try {
      return Integer.parseInt(value.trim());
    } catch (NumberFormatException ex) {
      return -1;
    }
  }

  private static final class AttributeSpec {
    private final String key;
    private final String expression;
    private final boolean usesResult;

    private AttributeSpec(final String key, final String expression) {
      this.key = key;
      this.expression = expression;
      this.usesResult = expression != null && "result".equals(expression.trim());
    }
  }
}
