/* @autogenerated */
package net.civeira.phylax.bootstrap.store;

import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import javax.sql.DataSource;

import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.infrastructure.store.BinaryContent;
import net.civeira.phylax.common.infrastructure.store.FileStore;
import net.civeira.phylax.common.infrastructure.store.RepositoryLink;

/**
 * Database-backed implementation of {@link FileStore} using a {@code _filestorer} table.
 *
 * <p>
 * Files are stored either as temporary (pending commit) or permanent. Temporary files are
 * automatically evicted when they exceed the configured age or when the total count surpasses the
 * configured capacity.
 * </p>
 */
@Slf4j
@ApplicationScoped
@RequiredArgsConstructor
public class FileStoreImpl implements FileStore {

  /** URL prefix for files stored internally by this implementation. */
  private static final String UPLOAD_SCHEMA = "upload://";

  /** Maximum number of temporary files to retain before evicting the oldest ones. */
  private static final int TEMP_CAPACITY = 1000;

  /** Maximum age in minutes for a temporary file before it is evicted. */
  private static final int TEMP_LIFETIME_MINUTES = 60;

  private final DataSource datasource;

  private void cleanTemp() throws SQLException {
    try (Connection connection = datasource.getConnection()) {
      // Evict expired temporary files by age
      try (PreparedStatement ps =
          connection.prepareStatement("DELETE FROM _filestorer where temp = 1 and upload < ?")) {
        ps.setTimestamp(1,
            new Timestamp(System.currentTimeMillis() - (long) TEMP_LIFETIME_MINUTES * 60_000));
        ps.executeUpdate();
      }

      // Collect codes of temporary files beyond the capacity limit
      List<String> toDelete = new ArrayList<>();
      try (PreparedStatement ps = connection.prepareStatement(
          "SELECT code FROM _filestorer where temp = 1 order by upload desc limit 1000000 offset ?")) {
        ps.setInt(1, TEMP_CAPACITY);
        try (ResultSet rs = ps.executeQuery()) {
          while (rs.next()) {
            toDelete.add(rs.getString(1));
          }
        }
      }

      // Delete excess temporary files using a parameterized single-row statement per entry
      if (!toDelete.isEmpty()) {
        try (PreparedStatement ps =
            connection.prepareStatement("DELETE FROM _filestorer where temp = 1 and code = ?")) {
          for (String code : toDelete) {
            ps.setString(1, code);
            ps.addBatch();
          }
          ps.executeBatch();
        }
      }
    }
  }

  @Override
  public RepositoryLink commitReplace(String path, RepositoryLink link) {
    try (Connection connection = datasource.getConnection()) {
      RepositoryLink key = runCommit(connection, path);
      runDelete(connection, path);
      return key;
    } catch (SQLException e) {
      throw new IllegalArgumentException(e);
    }
  }

  @Override
  public RepositoryLink commitContent(final String path) {
    try (Connection connection = datasource.getConnection()) {
      return runCommit(connection, path);
    } catch (SQLException e) {
      throw new IllegalArgumentException(e);
    }
  }

  @Override
  public RepositoryLink replaceContent(String key, BinaryContent content) {
    try (Connection connection = datasource.getConnection()) {
      try (PreparedStatement ps = connection.prepareStatement(
          "UPDATE _filestorer SET name = ?, mime = ?, upload = ?, bytes = ? WHERE code = ?")) {
        ps.setString(1, content.getName());
        ps.setString(2, content.getContentType());
        ps.setTimestamp(3, new Timestamp(System.currentTimeMillis()));
        ps.setBinaryStream(4, content.getInputStream());
        ps.setString(5, code(key));
        if (ps.executeUpdate() != 1) {
          throw new IllegalArgumentException("Failed to update file content for key: " + key);
        }
        return RepositoryLink.builder().key(key).build();
      }
    } catch (SQLException e) {
      throw new IllegalArgumentException(e);
    }
  }

  @Override
  public void deleteFile(final String path) {
    try (Connection connection = datasource.getConnection()) {
      runDelete(connection, path);
    } catch (SQLException e) {
      throw new IllegalArgumentException(e);
    }
  }

  private Optional<BinaryContent> retrieve(final String path, final boolean temporal) {
    try {
      cleanTemp();
    } catch (SQLException ex) {
      log.error("Unable to clear temp files", ex);
    }
    try (Connection connection = datasource.getConnection()) {
      try (PreparedStatement ps = connection.prepareStatement(
          "SELECT name, mime, bytes, upload FROM _filestorer WHERE code = ? AND temp = ?")) {
        ps.setString(1, code(path));
        ps.setInt(2, temporal ? 1 : 0);
        try (ResultSet rs = ps.executeQuery()) {
          if (rs.next()) {
            String name = rs.getString(1);
            InputStream fcontent = rs.getBinaryStream(3);
            BinaryContent content = BinaryContent.builder().name(name).contentType(rs.getString(2))
                .inputStream(fcontent).lastModification(rs.getTimestamp(4).getTime()).build();
            return Optional.of(content);
          }
          return Optional.empty();
        }
      }
    } catch (SQLException e) {
      throw new IllegalArgumentException(e);
    }
  }

  private String code(String path) {
    return path.startsWith(UPLOAD_SCHEMA) ? path.replace(UPLOAD_SCHEMA, "") : path;
  }

  @Override
  public Optional<BinaryContent> retrieveTemp(String key) {
    return retrieve(key, true);
  }

  @Override
  public Optional<BinaryContent> retrieveFile(String key) {
    return retrieve(key, false);
  }

  @Override
  public RepositoryLink tempStore(BinaryContent source) {
    try {
      cleanTemp();
    } catch (SQLException ex) {
      log.error("Unable to clear temp files", ex);
    }
    try (Connection connection = datasource.getConnection()) {
      try (PreparedStatement ps = connection.prepareStatement(
          "INSERT INTO _filestorer (code, temp, name, mime, upload, bytes) VALUES (?, ?, ?, ?, ?, ?)")) {
        final String path = UUID.randomUUID().toString();
        ps.setString(1, path);
        ps.setInt(2, 1);
        ps.setString(3, source.getName());
        ps.setString(4, source.getContentType());
        ps.setTimestamp(5, new Timestamp(System.currentTimeMillis()));
        ps.setBinaryStream(6, source.getInputStream());
        if (ps.executeUpdate() != 1) {
          throw new IOException("Failed to store temporary file: " + path);
        }
        return RepositoryLink.builder().key(path).build();
      }
    } catch (IOException | SQLException e) {
      throw new IllegalArgumentException(e);
    }
  }

  private RepositoryLink runCommit(Connection connection, String path) throws SQLException {
    try (PreparedStatement ps =
        connection.prepareStatement("UPDATE _filestorer SET upload = ?, temp = 0 WHERE code = ?")) {
      ps.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
      ps.setString(2, code(path));
      if (ps.executeUpdate() != 1) {
        throw new IllegalArgumentException("Failed to commit file: " + path);
      }
      return RepositoryLink.builder().key(path).build();
    }
  }

  private void runDelete(Connection connection, String path) throws SQLException {
    try (PreparedStatement ps =
        connection.prepareStatement("DELETE FROM _filestorer WHERE code = ?")) {
      ps.setString(1, code(path));
      if (ps.executeUpdate() != 1) {
        log.warn("File not found for deletion: {}", path);
      }
    }
  }
}
