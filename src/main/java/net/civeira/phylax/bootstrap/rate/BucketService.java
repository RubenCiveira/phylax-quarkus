/* @autogenerated */
package net.civeira.phylax.bootstrap.rate;

import java.time.Duration;
import java.time.Instant;
import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import io.github.bucket4j.Bucket;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.ws.rs.container.ContainerRequestContext;

@ApplicationScoped
public class BucketService {
  private static final long EXPIRATION_TIME_MS = Duration.ofMinutes(10).toMillis();
  private final Map<String, Bucket> ipBucket = new ConcurrentHashMap<>();
  private final Map<String, Long> lastAccessTime = new ConcurrentHashMap<>();

  public Bucket resolveBucket(ContainerRequestContext requestContext) {
    String ip = requestContext.getHeaders().getFirst("X-Forwarded-For");
    if (ip == null) {
      ip = requestContext.getUriInfo().getRequestUri().getHost();
    }
    cleanExpiredEntries();
    return ipBucket.computeIfAbsent(ip, key -> {
      lastAccessTime.put(key, Instant.now().toEpochMilli());
      return createNewBucket();
    });
  }

  private Bucket createNewBucket() {
    return Bucket.builder()
        .addLimit(limit -> limit.capacity(200).refillGreedy(100, Duration.ofMinutes(1))).build();
  }

  private void cleanExpiredEntries() {
    long currentTime = Instant.now().toEpochMilli();
    Iterator<Map.Entry<String, Long>> iterator = lastAccessTime.entrySet().iterator();

    while (iterator.hasNext()) {
      Map.Entry<String, Long> entry = iterator.next();
      if (currentTime - entry.getValue() > EXPIRATION_TIME_MS) {
        iterator.remove();
        ipBucket.remove(entry.getKey());
      }
    }
  }
}
