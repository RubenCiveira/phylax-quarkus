/* @autogenerated */
package net.civeira.phylax.bootstrap.rate;

import io.github.bucket4j.Bucket;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.container.ContainerResponseContext;
import jakarta.ws.rs.container.ContainerResponseFilter;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.ext.Provider;
import lombok.RequiredArgsConstructor;

@Provider
@ApplicationScoped
@RequiredArgsConstructor
public class RateLimitingFilter implements ContainerRequestFilter, ContainerResponseFilter {

  /**
   * Property key used to pass the resolved bucket between the request and response filter phases.
   * Storing the bucket avoids a second call to {@link BucketService#resolveBucket}, which would
   * re-run IP resolution and cleanup, and could theoretically return a different bucket if the
   * original was evicted between the two filter invocations.
   */
  private static final String BUCKET_PROPERTY = "rate.limit.bucket";

  private final BucketService buckets;

  @Override
  public void filter(ContainerRequestContext requestContext) {
    Bucket bucket = buckets.resolveBucket(requestContext);
    requestContext.setProperty(BUCKET_PROPERTY, bucket);
    if (!bucket.tryConsume(1)) {
      requestContext.abortWith(
          Response.status(Response.Status.TOO_MANY_REQUESTS).entity("Too many requests").build());
    }
  }

  @Override
  public void filter(ContainerRequestContext requestContext,
      ContainerResponseContext responseContext) {
    Bucket bucket = (Bucket) requestContext.getProperty(BUCKET_PROPERTY);
    if (bucket != null) {
      responseContext.getHeaders().add("X-RateLimit-Remaining",
          String.valueOf(bucket.getAvailableTokens()));
    }
  }
}
