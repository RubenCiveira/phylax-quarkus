package net.civeira.phylax.features.access.role.application.usecase.update;

import java.util.Optional;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import net.civeira.phylax.features.access.relyingparty.domain.RelyingPartyRef;
import net.civeira.phylax.features.access.role.application.visibility.RoleVisibleProjection;
import net.civeira.phylax.features.access.role.domain.Role;
import net.civeira.phylax.features.access.role.domain.valueobject.NameVO;
import net.civeira.phylax.features.access.role.domain.valueobject.RelyingPartyVO;
import net.civeira.phylax.features.access.role.domain.valueobject.UidVO;
import net.civeira.phylax.features.access.role.domain.valueobject.VersionVO;

/**
 * A dto transfer to hold role attribute values
 */
@NoArgsConstructor(access = AccessLevel.PRIVATE)
@Getter
public class RoleUpdateProjection {

  /**
   * Create a dto instance with all the values of an entity
   *
   * @autogenerated UpdateProjectionGenerator
   * @param visible The entity who provide values.
   * @return
   */
  public static RoleUpdateProjection from(final RoleVisibleProjection visible) {
    RoleUpdateProjection instance = new RoleUpdateProjection();
    instance.uidValue = visible.getUid();
    instance.nameValue = visible.getName();
    instance.relyingPartyValue = visible.getRelyingParty();
    instance.versionValue = visible.getVersion();
    return instance;
  }

  /**
   * The user name to identify on the login screen
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<NameVO> nameValue;

  /**
   * Domains without a tenant could be used only for admins
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<RelyingPartyVO> relyingPartyValue;

  /**
   * A uid string to identify the entity
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<UidVO> uidValue;

  /**
   * Campo con el n√∫mero de version de role para controlar bloqueos optimistas
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<VersionVO> versionValue;

  /**
   * Create a dto instance with all the values of an entity
   *
   * @autogenerated UpdateProjectionGenerator
   * @param entity The entity who provide values.
   */
  public RoleUpdateProjection(final Role entity) {
    uidValue = Optional.of(entity.getUidValue());
    nameValue = Optional.of(entity.getNameValue());
    relyingPartyValue = Optional.of(entity.getRelyingPartyValue());
    versionValue = Optional.of(entity.getVersionValue());
  }

  /**
   * Inform for a possible change propolsal in Name
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Name, otherwise the value for Name
   */
  public String getName() {
    return getNameOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Name
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Name, otherwise the value for Name
   */
  public String getNameOrDefault(final String orDefault) {
    return nameValue.map(NameVO::getName).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in RelyingParty
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for RelyingParty, otherwise the value for
   *         RelyingParty
   */
  public RelyingPartyRef getRelyingParty() {
    return relyingPartyValue.flatMap(RelyingPartyVO::getRelyingParty).orElse(null);
  }

  /**
   * Inform for a possible change propolsal in RelyingParty
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for RelyingParty, otherwise the value for
   *         RelyingParty
   */
  public String getRelyingPartyReference() {
    return getRelyingPartyReferenceOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in RelyingParty
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault
   * @return empty if there is no change proposal for RelyingParty, otherwise the value for
   *         RelyingParty
   */
  public String getRelyingPartyReferenceOrDefault(final String orDefault) {
    return relyingPartyValue.flatMap(RelyingPartyVO::getRelyingParty).map(RelyingPartyRef::getUid)
        .orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Uid
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Uid, otherwise the value for Uid
   */
  public String getUid() {
    return getUidOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Uid
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Uid, otherwise the value for Uid
   */
  public String getUidOrDefault(final String orDefault) {
    return uidValue.map(UidVO::getUid).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Version
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Version, otherwise the value for Version
   */
  public Integer getVersion() {
    return getVersionOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Version
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Version, otherwise the value for Version
   */
  public Integer getVersionOrDefault(final Integer orDefault) {
    return versionValue.flatMap(VersionVO::getVersion).orElse(orDefault);
  }
}
