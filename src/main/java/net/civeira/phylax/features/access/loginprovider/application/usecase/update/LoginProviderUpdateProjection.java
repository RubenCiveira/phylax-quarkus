package net.civeira.phylax.features.access.loginprovider.application.usecase.update;

import java.util.Optional;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import net.civeira.phylax.features.access.loginprovider.application.visibility.LoginProviderVisibleProjection;
import net.civeira.phylax.features.access.loginprovider.domain.LoginProvider;
import net.civeira.phylax.features.access.loginprovider.domain.LoginProviderSourceOptions;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.CertificateVO;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.DirectAccessVO;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.DisabledVO;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.MetadataVO;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.NameVO;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.PrivateKeyVO;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.PublicKeyVO;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.SourceVO;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.TenantVO;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.UidVO;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.UsersEnabledByDefaultVO;
import net.civeira.phylax.features.access.loginprovider.domain.valueobject.VersionVO;
import net.civeira.phylax.features.access.tenant.domain.TenantRef;

/**
 * A dto transfer to hold login provider attribute values
 */
@NoArgsConstructor(access = AccessLevel.PRIVATE)
@Getter
public class LoginProviderUpdateProjection {

  /**
   * Create a dto instance with all the values of an entity
   *
   * @autogenerated UpdateProjectionGenerator
   * @param visible The entity who provide values.
   * @return
   */
  public static LoginProviderUpdateProjection from(final LoginProviderVisibleProjection visible) {
    LoginProviderUpdateProjection instance = new LoginProviderUpdateProjection();
    instance.uidValue = visible.getUid();
    instance.tenantValue = visible.getTenant();
    instance.nameValue = visible.getName();
    instance.sourceValue = visible.getSource();
    instance.disabledValue = visible.getDisabled();
    instance.directAccessValue = visible.getDirectAccess();
    instance.publicKeyValue = visible.getPublicKey();
    instance.privateKeyValue = visible.getPrivateKey();
    instance.certificateValue = visible.getCertificate();
    instance.metadataValue = visible.getMetadata();
    instance.usersEnabledByDefaultValue = visible.getUsersEnabledByDefault();
    instance.versionValue = visible.getVersion();
    return instance;
  }

  /**
   * The provider certificate used for signature verification, if required.
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<CertificateVO> certificateValue;

  /**
   * If true, the system will default to this login method without requiring selection.
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<DirectAccessVO> directAccessValue;

  /**
   * Indicates if this provider is currently disabled.
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<DisabledVO> disabledValue;

  /**
   * A metadata file required by some providers for configuration (e.g., SAML descriptor).
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<MetadataVO> metadataValue;

  /**
   * A name that identifies this login provider within the tenant.
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<NameVO> nameValue;

  /**
   * Private key used internally to validate codes returned by the identity provider.
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<PrivateKeyVO> privateKeyValue;

  /**
   * A public key shared with users to interact with the identity provider.
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<PublicKeyVO> publicKeyValue;

  /**
   * The source protocol or system used for authentication (e.g., GOOGLE, GITHUB, SAML).
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<SourceVO> sourceValue;

  /**
   * The tenant this login provider is configured for.
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<TenantVO> tenantValue;

  /**
   * A uid string to identify the entity
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<UidVO> uidValue;

  /**
   * Defines whether the users created with this provider are enabled by default.
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<UsersEnabledByDefaultVO> usersEnabledByDefaultValue;

  /**
   * Campo con el n√∫mero de version de login provider para controlar bloqueos optimistas
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<VersionVO> versionValue;

  /**
   * Create a dto instance with all the values of an entity
   *
   * @autogenerated UpdateProjectionGenerator
   * @param entity The entity who provide values.
   */
  public LoginProviderUpdateProjection(final LoginProvider entity) {
    uidValue = Optional.of(entity.getUidValue());
    tenantValue = Optional.of(entity.getTenantValue());
    nameValue = Optional.of(entity.getNameValue());
    sourceValue = Optional.of(entity.getSourceValue());
    disabledValue = Optional.of(entity.getDisabledValue());
    directAccessValue = Optional.of(entity.getDirectAccessValue());
    publicKeyValue = Optional.of(entity.getPublicKeyValue());
    privateKeyValue = Optional.of(entity.getPrivateKeyValue());
    certificateValue = Optional.of(entity.getCertificateValue());
    metadataValue = Optional.of(entity.getMetadataValue());
    usersEnabledByDefaultValue = Optional.of(entity.getUsersEnabledByDefaultValue());
    versionValue = Optional.of(entity.getVersionValue());
  }

  /**
   * Inform for a possible change propolsal in Certificate
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Certificate, otherwise the value for
   *         Certificate
   */
  public String getCertificate() {
    return getCertificateOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Certificate
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Certificate, otherwise the value for
   *         Certificate
   */
  public String getCertificateOrDefault(final String orDefault) {
    return certificateValue.flatMap(CertificateVO::getCertificate).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in DirectAccess
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for DirectAccess, otherwise the value for
   *         DirectAccess
   */
  public Boolean getDirectAccess() {
    return getDirectAccessOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in DirectAccess
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for DirectAccess, otherwise the value for
   *         DirectAccess
   */
  public Boolean getDirectAccessOrDefault(final Boolean orDefault) {
    return directAccessValue.map(DirectAccessVO::isDirectAccess).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Disabled
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Disabled, otherwise the value for Disabled
   */
  public Boolean getDisabled() {
    return getDisabledOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Disabled
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Disabled, otherwise the value for Disabled
   */
  public Boolean getDisabledOrDefault(final Boolean orDefault) {
    return disabledValue.map(DisabledVO::isDisabled).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Metadata
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Metadata, otherwise the value for Metadata
   */
  public String getMetadata() {
    return getMetadataOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Metadata
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Metadata, otherwise the value for Metadata
   */
  public String getMetadataOrDefault(final String orDefault) {
    return metadataValue.flatMap(MetadataVO::getMetadata).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Name
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Name, otherwise the value for Name
   */
  public String getName() {
    return getNameOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Name
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Name, otherwise the value for Name
   */
  public String getNameOrDefault(final String orDefault) {
    return nameValue.map(NameVO::getName).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in PrivateKey
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for PrivateKey, otherwise the value for PrivateKey
   */
  public String getPrivateKey() {
    return getPrivateKeyOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in PrivateKey
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for PrivateKey, otherwise the value for PrivateKey
   */
  public String getPrivateKeyOrDefault(final String orDefault) {
    return privateKeyValue.flatMap(PrivateKeyVO::getPrivateKey).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in PublicKey
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for PublicKey, otherwise the value for PublicKey
   */
  public String getPublicKey() {
    return getPublicKeyOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in PublicKey
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for PublicKey, otherwise the value for PublicKey
   */
  public String getPublicKeyOrDefault(final String orDefault) {
    return publicKeyValue.flatMap(PublicKeyVO::getPublicKey).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Source
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Source, otherwise the value for Source
   */
  public LoginProviderSourceOptions getSource() {
    return getSourceOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Source
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Source, otherwise the value for Source
   */
  public LoginProviderSourceOptions getSourceOrDefault(final LoginProviderSourceOptions orDefault) {
    return sourceValue.map(SourceVO::getSource).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Tenant
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Tenant, otherwise the value for Tenant
   */
  public TenantRef getTenant() {
    return tenantValue.map(TenantVO::getTenant).orElse(null);
  }

  /**
   * Inform for a possible change propolsal in Tenant
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Tenant, otherwise the value for Tenant
   */
  public String getTenantReference() {
    return getTenantReferenceOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Tenant
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault
   * @return empty if there is no change proposal for Tenant, otherwise the value for Tenant
   */
  public String getTenantReferenceOrDefault(final String orDefault) {
    return tenantValue.map(TenantVO::getTenant).map(TenantRef::getUid).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Uid
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Uid, otherwise the value for Uid
   */
  public String getUid() {
    return getUidOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Uid
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Uid, otherwise the value for Uid
   */
  public String getUidOrDefault(final String orDefault) {
    return uidValue.map(UidVO::getUid).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in UsersEnabledByDefault
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for UsersEnabledByDefault, otherwise the value for
   *         UsersEnabledByDefault
   */
  public Boolean getUsersEnabledByDefault() {
    return getUsersEnabledByDefaultOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in UsersEnabledByDefault
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for UsersEnabledByDefault, otherwise the value for
   *         UsersEnabledByDefault
   */
  public Boolean getUsersEnabledByDefaultOrDefault(final Boolean orDefault) {
    return usersEnabledByDefaultValue.map(UsersEnabledByDefaultVO::isUsersEnabledByDefault)
        .orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Version
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Version, otherwise the value for Version
   */
  public Integer getVersion() {
    return getVersionOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Version
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Version, otherwise the value for Version
   */
  public Integer getVersionOrDefault(final Integer orDefault) {
    return versionValue.flatMap(VersionVO::getVersion).orElse(orDefault);
  }
}
