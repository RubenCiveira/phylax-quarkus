package net.civeira.phylax.features.access.user;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.value.validation.ConstraintFail;
import net.civeira.phylax.common.value.validation.ConstraintFailList;
import net.civeira.phylax.features.access.tenant.TenantRef;
import net.civeira.phylax.features.access.user.command.UserWriteAttributes;
import net.civeira.phylax.features.access.user.event.UserBlockEvent;
import net.civeira.phylax.features.access.user.event.UserChangePasswordEvent;
import net.civeira.phylax.features.access.user.event.UserCreateEvent;
import net.civeira.phylax.features.access.user.event.UserDeleteEvent;
import net.civeira.phylax.features.access.user.event.UserDisableEvent;
import net.civeira.phylax.features.access.user.event.UserEnableEvent;
import net.civeira.phylax.features.access.user.event.UserEvent;
import net.civeira.phylax.features.access.user.event.UserSetMfaSeedEvent;
import net.civeira.phylax.features.access.user.event.UserUnlockEvent;
import net.civeira.phylax.features.access.user.event.UserUpdateEvent;
import net.civeira.phylax.features.access.user.transition.block.UserBlockPipeline;
import net.civeira.phylax.features.access.user.transition.changepassword.UserChangePasswordPipeline;
import net.civeira.phylax.features.access.user.transition.create.UserCreatePipeline;
import net.civeira.phylax.features.access.user.transition.delete.UserDeletePipeline;
import net.civeira.phylax.features.access.user.transition.disable.UserDisablePipeline;
import net.civeira.phylax.features.access.user.transition.enable.UserEnablePipeline;
import net.civeira.phylax.features.access.user.transition.setmfaseed.UserSetMfaSeedPipeline;
import net.civeira.phylax.features.access.user.transition.unlock.UserUnlockPipeline;
import net.civeira.phylax.features.access.user.transition.update.UserUpdatePipeline;
import net.civeira.phylax.features.access.user.valueobject.BlockedUntilVO;
import net.civeira.phylax.features.access.user.valueobject.EmailVO;
import net.civeira.phylax.features.access.user.valueobject.EnabledVO;
import net.civeira.phylax.features.access.user.valueobject.LanguageVO;
import net.civeira.phylax.features.access.user.valueobject.NameVO;
import net.civeira.phylax.features.access.user.valueobject.PasswordVO;
import net.civeira.phylax.features.access.user.valueobject.ProviderVO;
import net.civeira.phylax.features.access.user.valueobject.SecondFactorSeedVO;
import net.civeira.phylax.features.access.user.valueobject.TemporalPasswordVO;
import net.civeira.phylax.features.access.user.valueobject.TenantVO;
import net.civeira.phylax.features.access.user.valueobject.UidVO;
import net.civeira.phylax.features.access.user.valueobject.UseSecondFactorsVO;
import net.civeira.phylax.features.access.user.valueobject.VersionVO;

@AllArgsConstructor
@Getter
@ToString
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class User implements UserRef {

  /**
   * @autogenerated EntityGenerator
   * @param attributes
   * @param pipeline
   * @return
   */
  public static User create(final UserWriteAttributes attributes,
      final UserCreatePipeline pipeline) {
    return pipeline.create(attributes, attr -> {
      User instance = new User(attr, Optional.empty());
      instance.addEvent(UserCreateEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * A bloqued user cant login on the system, until these date. On his login attempst, hue will
   * recive a generic not allowed message.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private BlockedUntilVO blockedUntil = BlockedUntilVO.nullValue();

  /**
   * An optional email used to send notifications to the user
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private EmailVO email = EmailVO.nullValue();

  /**
   * A disabled user cant login on the system. On his login attempts, he will recive a specific warn
   * of his disabled account.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private EnabledVO enabled = EnabledVO.nullValue();

  /**
   * El language de user
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private LanguageVO language = LanguageVO.nullValue();

  /**
   * The user name to identify on the login screen
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private NameVO name;

  /**
   * If the user is not delegated, the phrasse to identify
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private PasswordVO password;

  /**
   * Si se identificó con un proveedor, se marca con cual (aunque el provedor cambie luego)
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private ProviderVO provider = ProviderVO.nullValue();

  /**
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private List<UserEvent> recordedEvents = List.of();

  /**
   * the seed used to the otp login
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private SecondFactorSeedVO secondFactorSeed = SecondFactorSeedVO.nullValue();

  /**
   * El temporal password de user
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private TemporalPasswordVO temporalPassword = TemporalPasswordVO.nullValue();

  /**
   * Los usuarios que no tienen tenant son roots del sistema
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private TenantVO tenant = TenantVO.nullValue();

  /**
   * A uid string to identify the entity
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private UidVO uid;

  /**
   * If is true, the user has a otp to force mfa on login
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private UseSecondFactorsVO useSecondFactors = UseSecondFactorsVO.nullValue();

  /**
   * Campo con el número de version de user para controlar bloqueos optimistas
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private VersionVO version = VersionVO.nullValue();

  /**
   * @autogenerated EntityGenerator
   * @param attribute
   * @param previous
   */
  private User(final UserWriteAttributes attribute, final Optional<User> previous) {
    ConstraintFailList list = new ConstraintFailList();
    this.uid = attribute.getUid().orElse(previous.map(User::getUid).orElse(null));
    this.tenant =
        attribute.getTenant().orElse(previous.map(User::getTenant).orElseGet(TenantVO::nullValue));
    this.name = attribute.getName().orElse(previous.map(User::getName).orElse(null));
    this.password = attribute.getPassword().orElse(previous.map(User::getPassword).orElse(null));
    this.email =
        attribute.getEmail().orElse(previous.map(User::getEmail).orElseGet(EmailVO::nullValue));
    this.enabled = attribute.getEnabled()
        .orElse(previous.map(User::getEnabled).orElseGet(EnabledVO::nullValue));
    this.temporalPassword = attribute.getTemporalPassword()
        .orElse(previous.map(User::getTemporalPassword).orElseGet(TemporalPasswordVO::nullValue));
    this.useSecondFactors = attribute.getUseSecondFactors()
        .orElse(previous.map(User::getUseSecondFactors).orElseGet(UseSecondFactorsVO::nullValue));
    this.secondFactorSeed = attribute.getSecondFactorSeed()
        .orElse(previous.map(User::getSecondFactorSeed).orElseGet(SecondFactorSeedVO::nullValue));
    this.blockedUntil = attribute.getBlockedUntil()
        .orElse(previous.map(User::getBlockedUntil).orElseGet(BlockedUntilVO::nullValue));
    this.language = attribute.getLanguage()
        .orElse(previous.map(User::getLanguage).orElseGet(LanguageVO::nullValue));
    this.provider = attribute.getProvider()
        .orElse(previous.map(User::getProvider).orElseGet(ProviderVO::nullValue));
    this.version = attribute.getVersion()
        .orElse(previous.map(User::getVersion).orElseGet(VersionVO::nullValue));
    if (null == uid) {
      list.add(new ConstraintFail("REQUIRED", "uid", null));
    }
    if (null == name) {
      list.add(new ConstraintFail("REQUIRED", "name", null));
    }
    if (null == password) {
      list.add(new ConstraintFail("REQUIRED", "password", null));
    }
    if (list.hasErrors()) {
      throw new ConstraintException(list);
    }
    this.recordedEvents = previous.map(User::getRecordedEvents).orElseGet(List::of);
  }

  /**
   * @autogenerated EntityGenerator
   * @param blockedUntil
   * @param pipeline
   * @return
   */
  public User block(final OffsetDateTime blockedUntil, final UserBlockPipeline pipeline) {
    return pipeline.block(blockedUntil, this, attr -> {
      attr.setBlockedUntil(blockedUntil);
      User instance = new User(attr, Optional.of(this));
      instance.addEvent(UserBlockEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @param password
   * @param pipeline
   * @return
   */
  public User changePassword(final String password, final UserChangePasswordPipeline pipeline) {
    return pipeline.changePassword(password, this, attr -> {
      attr.setPassword(password);
      attr.setTemporalPassword(false);
      User instance = new User(attr, Optional.of(this));
      instance.addEvent(UserChangePasswordEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @param pipeline
   * @return
   */
  public User delete(final UserDeletePipeline pipeline) {
    return pipeline.delete(this, () -> {
      User instance = this;
      instance.addEvent(UserDeleteEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @param pipeline
   * @return
   */
  public User disable(final UserDisablePipeline pipeline) {
    return pipeline.disable(this, attr -> {
      attr.setEnabled(false);
      User instance = new User(attr, Optional.of(this));
      instance.addEvent(UserDisableEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @param pipeline
   * @return
   */
  public User enable(final UserEnablePipeline pipeline) {
    return pipeline.enable(this, attr -> {
      attr.setEnabled(true);
      User instance = new User(attr, Optional.of(this));
      instance.addEvent(UserEnableEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<OffsetDateTime> getBlockedUntilValue() {
    return getBlockedUntil().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<String> getEmailValue() {
    return getEmail().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<String> getLanguageValue() {
    return getLanguage().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public String getNameValue() {
    return getName().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @param cypher
   * @return
   */
  public String getPasswordCypheredValue(final AesCipherService cypher) {
    return getPassword().getCypheredValue(cypher);
  }

  /**
   * @autogenerated EntityGenerator
   * @param cypher
   * @return
   */
  public String getPasswordPlainValue(final AesCipherService cypher) {
    return getPassword().getPlainValue(cypher);
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<String> getProviderValue() {
    return getProvider().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @param cypher
   * @return
   */
  public Optional<String> getSecondFactorSeedCypheredValue(final AesCipherService cypher) {
    return getSecondFactorSeed().getCypheredValue(cypher);
  }

  /**
   * @autogenerated EntityGenerator
   * @param cypher
   * @return
   */
  public Optional<String> getSecondFactorSeedPlainValue(final AesCipherService cypher) {
    return getSecondFactorSeed().getPlainValue(cypher);
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<String> getTenantReferenceValue() {
    return getTenant().getReferenceValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<TenantRef> getTenantValue() {
    return getTenant().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  @Override
  public String getUidValue() {
    return this.uid.getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<Integer> getVersionValue() {
    return getVersion().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public boolean isEnabled() {
    return Boolean.TRUE.equals(getEnabled().getValue().orElse(Boolean.FALSE));
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public boolean isTemporalPassword() {
    return Boolean.TRUE.equals(getTemporalPassword().getValue().orElse(Boolean.FALSE));
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public boolean isUseSecondFactors() {
    return Boolean.TRUE.equals(getUseSecondFactors().getValue().orElse(Boolean.FALSE));
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public User nextVersion() {
    return User.builder().uid(this.uid).tenant(this.tenant).name(this.name).password(this.password)
        .email(this.email).enabled(this.enabled).temporalPassword(this.temporalPassword)
        .useSecondFactors(this.useSecondFactors).secondFactorSeed(this.secondFactorSeed)
        .blockedUntil(this.blockedUntil).language(this.language).provider(this.provider)
        .version(VersionVO.from(this.version() + 1)).build();
  }

  /**
   * @autogenerated EntityGenerator
   * @param secondFactorSeed
   * @param pipeline
   * @return
   */
  public User setMfaSeed(final String secondFactorSeed, final UserSetMfaSeedPipeline pipeline) {
    return pipeline.setMfaSeed(secondFactorSeed, this, attr -> {
      attr.setSecondFactorSeed(secondFactorSeed);
      attr.setUseSecondFactors(true);
      User instance = new User(attr, Optional.of(this));
      instance.addEvent(UserSetMfaSeedEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @param pipeline
   * @return
   */
  public User unlock(final UserUnlockPipeline pipeline) {
    return pipeline.unlock(this, attr -> {
      attr.setBlockedUntil(null);
      User instance = new User(attr, Optional.of(this));
      instance.addEvent(UserUnlockEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @param attributes
   * @param pipeline
   * @return
   */
  public User update(final UserWriteAttributes attributes, final UserUpdatePipeline pipeline) {
    return pipeline.update(attributes, this, attr -> {
      User instance = new User(attr, Optional.of(this));
      instance.addEvent(UserUpdateEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Integer version() {
    return this.getVersion().getValue().orElse(0);
  }

  /**
   * @autogenerated EntityGenerator
   * @param event
   */
  private void addEvent(final UserEvent event) {
    List<UserEvent> events = new ArrayList<>(this.recordedEvents);
    events.add(event);
    this.recordedEvents = List.copyOf(events);
  }
}
