package net.civeira.phylax.features.access.tenant.application.usecase.update;

import java.time.OffsetDateTime;
import java.util.Optional;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import net.civeira.phylax.features.access.tenant.application.visibility.TenantVisibleProjection;
import net.civeira.phylax.features.access.tenant.domain.Tenant;
import net.civeira.phylax.features.access.tenant.domain.valueobject.DomainVO;
import net.civeira.phylax.features.access.tenant.domain.valueobject.EnabledVO;
import net.civeira.phylax.features.access.tenant.domain.valueobject.MarkForDeleteTimeVO;
import net.civeira.phylax.features.access.tenant.domain.valueobject.MarkForDeleteVO;
import net.civeira.phylax.features.access.tenant.domain.valueobject.NameVO;
import net.civeira.phylax.features.access.tenant.domain.valueobject.RootVO;
import net.civeira.phylax.features.access.tenant.domain.valueobject.UidVO;
import net.civeira.phylax.features.access.tenant.domain.valueobject.VersionVO;

/**
 * A dto transfer to hold tenant attribute values
 */
@NoArgsConstructor(access = AccessLevel.PRIVATE)
@Getter
public class TenantUpdateProjection {

  /**
   * Create a dto instance with all the values of an entity
   *
   * @autogenerated UpdateProjectionGenerator
   * @param visible The entity who provide values.
   * @return
   */
  public static TenantUpdateProjection from(final TenantVisibleProjection visible) {
    TenantUpdateProjection instance = new TenantUpdateProjection();
    instance.uidValue = visible.getUid();
    instance.nameValue = visible.getName();
    instance.rootValue = visible.getRoot();
    instance.domainValue = visible.getDomain();
    instance.enabledValue = visible.getEnabled();
    instance.markForDeleteValue = visible.getMarkForDelete();
    instance.markForDeleteTimeValue = visible.getMarkForDeleteTime();
    instance.versionValue = visible.getVersion();
    return instance;
  }

  /**
   * A domain suffix to identify the account
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<DomainVO> domainValue;

  /**
   * The indicator to allow the account be used without deleting it
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<EnabledVO> enabledValue;

  /**
   * A tenant mark for deleted will be deleted soon
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<MarkForDeleteTimeVO> markForDeleteTimeValue;

  /**
   * a tenant mark for deleted will be
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<MarkForDeleteVO> markForDeleteValue;

  /**
   * The name to identify the account.
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<NameVO> nameValue;

  /**
   * El root de tenant
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<RootVO> rootValue;

  /**
   * A number to identify the db record
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<UidVO> uidValue;

  /**
   * Campo con el n√∫mero de version de tenant para controlar bloqueos optimistas
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<VersionVO> versionValue;

  /**
   * Create a dto instance with all the values of an entity
   *
   * @autogenerated UpdateProjectionGenerator
   * @param entity The entity who provide values.
   */
  public TenantUpdateProjection(final Tenant entity) {
    uidValue = Optional.of(entity.getUidValue());
    nameValue = Optional.of(entity.getNameValue());
    rootValue = Optional.of(entity.getRootValue());
    domainValue = Optional.of(entity.getDomainValue());
    enabledValue = Optional.of(entity.getEnabledValue());
    markForDeleteValue = Optional.of(entity.getMarkForDeleteValue());
    markForDeleteTimeValue = Optional.of(entity.getMarkForDeleteTimeValue());
    versionValue = Optional.of(entity.getVersionValue());
  }

  /**
   * Inform for a possible change propolsal in Domain
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Domain, otherwise the value for Domain
   */
  public String getDomain() {
    return getDomainOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Domain
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Domain, otherwise the value for Domain
   */
  public String getDomainOrDefault(final String orDefault) {
    return domainValue.map(DomainVO::getDomain).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Enabled
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Enabled, otherwise the value for Enabled
   */
  public Boolean getEnabled() {
    return getEnabledOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Enabled
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Enabled, otherwise the value for Enabled
   */
  public Boolean getEnabledOrDefault(final Boolean orDefault) {
    return enabledValue.map(EnabledVO::isEnabled).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in MarkForDelete
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for MarkForDelete, otherwise the value for
   *         MarkForDelete
   */
  public Boolean getMarkForDelete() {
    return getMarkForDeleteOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in MarkForDelete
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for MarkForDelete, otherwise the value for
   *         MarkForDelete
   */
  public Boolean getMarkForDeleteOrDefault(final Boolean orDefault) {
    return markForDeleteValue.map(MarkForDeleteVO::isMarkForDelete).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in MarkForDeleteTime
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for MarkForDeleteTime, otherwise the value for
   *         MarkForDeleteTime
   */
  public OffsetDateTime getMarkForDeleteTime() {
    return getMarkForDeleteTimeOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in MarkForDeleteTime
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for MarkForDeleteTime, otherwise the value for
   *         MarkForDeleteTime
   */
  public OffsetDateTime getMarkForDeleteTimeOrDefault(final OffsetDateTime orDefault) {
    return markForDeleteTimeValue.flatMap(MarkForDeleteTimeVO::getMarkForDeleteTime)
        .orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Name
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Name, otherwise the value for Name
   */
  public String getName() {
    return getNameOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Name
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Name, otherwise the value for Name
   */
  public String getNameOrDefault(final String orDefault) {
    return nameValue.map(NameVO::getName).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Root
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Root, otherwise the value for Root
   */
  public Boolean getRoot() {
    return getRootOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Root
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Root, otherwise the value for Root
   */
  public Boolean getRootOrDefault(final Boolean orDefault) {
    return rootValue.map(RootVO::isRoot).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Uid
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Uid, otherwise the value for Uid
   */
  public String getUid() {
    return getUidOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Uid
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Uid, otherwise the value for Uid
   */
  public String getUidOrDefault(final String orDefault) {
    return uidValue.map(UidVO::getUid).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Version
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Version, otherwise the value for Version
   */
  public Integer getVersion() {
    return getVersionOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Version
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Version, otherwise the value for Version
   */
  public Integer getVersionOrDefault(final Integer orDefault) {
    return versionValue.flatMap(VersionVO::getVersion).orElse(orDefault);
  }
}
