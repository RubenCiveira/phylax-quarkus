package net.civeira.phylax.features.access.useridentity.domain;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;
import lombok.With;
import lombok.experimental.Delegate;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.value.validation.ConstraintFailList;
import net.civeira.phylax.features.access.useridentity.domain.event.UserIdentityCreateEvent;
import net.civeira.phylax.features.access.useridentity.domain.event.UserIdentityDeleteEvent;
import net.civeira.phylax.features.access.useridentity.domain.event.UserIdentityEvent;
import net.civeira.phylax.features.access.useridentity.domain.event.UserIdentityUpdateEvent;
import net.civeira.phylax.features.access.useridentity.domain.valueobject.RelyingPartyVO;
import net.civeira.phylax.features.access.useridentity.domain.valueobject.RolesVO;
import net.civeira.phylax.features.access.useridentity.domain.valueobject.TrustedClientVO;
import net.civeira.phylax.features.access.useridentity.domain.valueobject.UidVO;
import net.civeira.phylax.features.access.useridentity.domain.valueobject.UserVO;
import net.civeira.phylax.features.access.useridentity.domain.valueobject.VersionVO;

/**
 * user-identity
 */
@Builder
@Getter
@With
@ToString
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@EqualsAndHashCode
public class UserIdentity implements UserIdentityRef {

  /**
   * Prepare a new user identity with the provided values
   *
   * @autogenerated EntityGenerator
   * @param change A set of values to create a new user identity
   * @throws ConstraintException If there are some constraints fails on the changes.
   * @return A well formed user identity.
   */
  public static UserIdentity create(final UserIdentityChangeSet change) throws ConstraintException {
    UserIdentity instance = new UserIdentity(change, Optional.empty());
    instance.addEvent(UserIdentityCreateEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * List of events
   *
   * @autogenerated EntityGenerator
   */
  @Builder.Default
  private List<UserIdentityEvent> recordedEvents = List.of();

  /**
   * El relying party de user identity
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @Builder.Default
  private RelyingPartyVO relyingPartyValue = RelyingPartyVO.nullValue();

  /**
   * El roles de user identity
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @NonNull
  private RolesVO rolesValue;

  /**
   * El trusted client de user identity
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @Builder.Default
  private TrustedClientVO trustedClientValue = TrustedClientVO.nullValue();

  /**
   * El identificador de la aplicacion
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @NonNull
  private UidVO uidValue;

  /**
   * El user de user identity
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @NonNull
  private UserVO userValue;

  /**
   * Campo con el n√∫mero de version de user identity para controlar bloqueos optimistas
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @Builder.Default
  private VersionVO versionValue = VersionVO.nullValue();

  /**
   * @autogenerated EntityGenerator
   * @param attribute
   * @param previous
   */
  private UserIdentity(final UserIdentityChangeSet attribute,
      final Optional<UserIdentity> previous) {
    ConstraintFailList list = new ConstraintFailList();
    this.uidValue = attribute.readUid(previous, list);
    this.userValue = attribute.readUser(previous, list);
    this.relyingPartyValue = attribute.readRelyingParty(previous, list);
    this.trustedClientValue = attribute.readTrustedClient(previous, list);
    this.rolesValue = attribute.readRoles(previous, list);
    this.versionValue = attribute.readVersion(previous, list);
    if (list.hasErrors()) {
      throw new ConstraintException("Invalid values on UserIdentity", list);
    }
    this.recordedEvents = previous.map(UserIdentity::getRecordedEvents).orElseGet(List::of);
  }

  /**
   * Apply changes to delete a user identity
   *
   * @autogenerated EntityGenerator
   * @return A instance of user identity ready to be deleted
   */
  public UserIdentity delete() {
    UserIdentity instance = new UserIdentity(new UserIdentityChangeSet(), Optional.of(this));
    instance.addEvent(UserIdentityDeleteEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Map<String, String> toMap() {
    Map<String, String> map = new HashMap<>(6);
    uidToMap(map);
    userToMap(map);
    relyingPartyToMap(map);
    trustedClientToMap(map);
    rolesToMap(map);
    versionToMap(map);
    return map;
  }

  /**
   * Modify the values for some of the properties of a user identity
   *
   * @autogenerated EntityGenerator
   * @param change The properties to be modified
   * @throws ConstraintException If there are some constraints fails on the changes.
   * @return A modified instance of user identity
   */
  public UserIdentity update(final UserIdentityChangeSet change) throws ConstraintException {
    UserIdentity instance = new UserIdentity(change, Optional.of(this));
    instance.addEvent(UserIdentityUpdateEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public UserIdentity withNextVersion() {
    return withVersionValue(VersionVO.from(nextVersion()));
  }

  /**
   * @autogenerated EntityGenerator
   * @param event
   */
  private void addEvent(final UserIdentityEvent event) {
    List<UserIdentityEvent> events = new ArrayList<>(this.recordedEvents);
    events.add(event);
    this.recordedEvents = List.copyOf(events);
  }
}
