package net.civeira.phylax.features.access.useracceptedtermnsofuse.domain;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;
import lombok.With;
import lombok.experimental.Delegate;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.value.validation.ConstraintFail;
import net.civeira.phylax.common.value.validation.ConstraintFailList;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.event.UserAcceptedTermnsOfUseCreateEvent;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.event.UserAcceptedTermnsOfUseDeleteEvent;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.event.UserAcceptedTermnsOfUseEvent;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.event.UserAcceptedTermnsOfUseUpdateEvent;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.valueobject.AcceptDateVO;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.valueobject.ConditionsVO;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.valueobject.UidVO;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.valueobject.UserVO;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.valueobject.VersionVO;

/**
 * user-accepted-termns-of-use
 */
@Builder
@Getter
@With
@ToString
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@EqualsAndHashCode
public class UserAcceptedTermnsOfUse implements UserAcceptedTermnsOfUseRef {

  /**
   * Prepare a new user accepted termns of use with the provided values
   *
   * @autogenerated EntityGenerator
   * @param change A set of values to create a new user accepted termns of use
   * @throws ConstraintException If there are some constraints fails on the changes.
   * @return A well formed user accepted termns of use.
   */
  public static UserAcceptedTermnsOfUse create(final UserAcceptedTermnsOfUseChangeSet change)
      throws ConstraintException {
    UserAcceptedTermnsOfUse instance = new UserAcceptedTermnsOfUse(change, Optional.empty());
    instance.addEvent(UserAcceptedTermnsOfUseCreateEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * El accept date de user accepted termns of use
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @Builder.Default
  private AcceptDateVO acceptDateValue = AcceptDateVO.nullValue();

  /**
   * El conditions de user accepted termns of use
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @NonNull
  private ConditionsVO conditionsValue;

  /**
   * List of events
   *
   * @autogenerated EntityGenerator
   */
  @Builder.Default
  private List<UserAcceptedTermnsOfUseEvent> recordedEvents = List.of();

  /**
   * A uid string to identify the entity
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @NonNull
  private UidVO uidValue;

  /**
   * El user de user accepted termns of use
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @NonNull
  private UserVO userValue;

  /**
   * Campo con el n√∫mero de version de user accepted termns of use para controlar bloqueos
   * optimistas
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @Builder.Default
  private VersionVO versionValue = VersionVO.nullValue();

  /**
   * @autogenerated EntityGenerator
   * @param attribute
   * @param previous
   */
  private UserAcceptedTermnsOfUse(final UserAcceptedTermnsOfUseChangeSet attribute,
      final Optional<UserAcceptedTermnsOfUse> previous) {
    ConstraintFailList list = new ConstraintFailList();
    this.uidValue =
        attribute.getUid().orElse(previous.map(UserAcceptedTermnsOfUse::getUidValue).orElse(null));
    this.userValue = attribute.getUser()
        .orElse(previous.map(UserAcceptedTermnsOfUse::getUserValue).orElse(null));
    this.conditionsValue = attribute.getConditions()
        .orElse(previous.map(UserAcceptedTermnsOfUse::getConditionsValue).orElse(null));
    this.acceptDateValue = attribute.getAcceptDate().orElse(previous
        .map(UserAcceptedTermnsOfUse::getAcceptDateValue).orElseGet(AcceptDateVO::nullValue));
    this.versionValue = attribute.getVersion().orElse(
        previous.map(UserAcceptedTermnsOfUse::getVersionValue).orElseGet(VersionVO::nullValue));
    if (null == uidValue) {
      list.add(new ConstraintFail("REQUIRED", "uid", null));
    }
    if (null == userValue) {
      list.add(new ConstraintFail("REQUIRED", "user", null));
    }
    if (null == conditionsValue) {
      list.add(new ConstraintFail("REQUIRED", "conditions", null));
    }
    if (list.hasErrors()) {
      throw new ConstraintException(list);
    }
    this.recordedEvents =
        previous.map(UserAcceptedTermnsOfUse::getRecordedEvents).orElseGet(List::of);
  }

  /**
   * Apply changes to delete a user accepted termns of use
   *
   * @autogenerated EntityGenerator
   * @return A instance of user accepted termns of use ready to be deleted
   */
  public UserAcceptedTermnsOfUse delete() {
    UserAcceptedTermnsOfUse instance = this;
    instance.addEvent(UserAcceptedTermnsOfUseDeleteEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * Modify the values for some of the properties of a user accepted termns of use
   *
   * @autogenerated EntityGenerator
   * @param change The properties to be modified
   * @throws ConstraintException If there are some constraints fails on the changes.
   * @return A modified instance of user accepted termns of use
   */
  public UserAcceptedTermnsOfUse update(final UserAcceptedTermnsOfUseChangeSet change)
      throws ConstraintException {
    UserAcceptedTermnsOfUse instance = new UserAcceptedTermnsOfUse(change, Optional.of(this));
    instance.addEvent(UserAcceptedTermnsOfUseUpdateEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public UserAcceptedTermnsOfUse withNextVersion() {
    return withVersionValue(VersionVO.from(nextVersion()));
  }

  /**
   * @autogenerated EntityGenerator
   * @param event
   */
  private void addEvent(final UserAcceptedTermnsOfUseEvent event) {
    List<UserAcceptedTermnsOfUseEvent> events = new ArrayList<>(this.recordedEvents);
    events.add(event);
    this.recordedEvents = List.copyOf(events);
  }
}
