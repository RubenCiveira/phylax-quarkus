/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.usecase;

import java.util.List;
import java.util.Optional;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.features.access.tenant.domain.Tenant;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantFilter;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantReadRepositoryGateway;
import net.civeira.phylax.features.access.trustedclient.domain.TrustedClient;
import net.civeira.phylax.features.access.trustedclient.domain.gateway.TrustedClientFilter;
import net.civeira.phylax.features.access.trustedclient.domain.gateway.TrustedClientReadRepositoryGateway;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.SecretOauthVO;
import net.civeira.phylax.features.oauth.client.domain.model.ClientDetails;

@Slf4j
@ApplicationScoped
@RequiredArgsConstructor
public class VerifyTrustedClientUsecase {
  private static final List<String> DEFAULT_SCOPES = List.of();
  private static final List<String> DEFAULT_GRANTERS = List.of("password", "refresh", "mfa");

  private final AesCipherService cypher;
  private final TenantReadRepositoryGateway tenants;
  private final TrustedClientReadRepositoryGateway clients;

  public Optional<ClientDetails> loadPrivate(String tenant, String clientId, String clientSecret) {
    return verify(tenant, clientId, Optional.of(clientSecret), Optional.empty());
  }

  public Optional<ClientDetails> loadPublic(String tenant, String clientId, String redirect) {
    return verify(tenant, clientId, Optional.empty(), Optional.of(redirect));
  }

  public Optional<ClientDetails> verify(final String tenant, String clientId,
      Optional<String> clientSecret, Optional<String> withRedirect) {
    return tenant(tenant)
        .flatMap(tenantEntity -> clients.find(TrustedClientFilter.builder().code(clientId).build()))
        .filter(this::clientEnabled)
        .flatMap(client -> clientSecret.isEmpty()
            ? publicClient(client, clientId, withRedirect.orElseThrow())
            : privateClient(client, clientId, clientSecret.get()));
  }

  private Optional<String> tenant(String name) {
    return "main".equals(name) ? Optional.of(name)
        : tenants.find(TenantFilter.builder().name(name).build()).filter(this::tenantEnabled)
            .map(Tenant::getName);
  }

  private boolean tenantEnabled(Tenant tenant) {
    boolean enabled = tenant.isEnabled();
    if (!enabled) {
      log.error("Trying to log with disabled tenant " + tenant.getNameValue());
    }
    return enabled;
  }

  private boolean clientEnabled(TrustedClient app) {
    boolean enabled = app.isEnabled();
    if (!enabled) {
      log.error("Trying to log with disabled client " + app.getCodeValue());
    }
    return enabled;
  }

  private Optional<ClientDetails> publicClient(TrustedClient app, String clientId,
      String redirect) {
    if (app.isPublicAllow() && redirectAllowed(app, redirect)) {
      return Optional.of(ClientDetails.builder().clientId(clientId).protectedWithSecret(false)
          .allowedGrants(DEFAULT_GRANTERS).allowedScopes(DEFAULT_SCOPES).build());
    } else {
      return Optional.empty();
    }
  }

  private boolean redirectAllowed(TrustedClient app, String redirect) {
    String redirects = app.getAllowedRedirects().orElse("");
    return redirects.equals("*") || redirects.contains(redirect);
  }

  private Optional<ClientDetails> privateClient(TrustedClient app, String clientId, String secret) {
    SecretOauthVO secretOauth = app.getSecretOauthValue();
    Optional<String> pass = secretOauth.getPlainSecretOauth(cypher);
    if (pass.isPresent() && secret.equals(pass.get())) {
      return Optional.of(ClientDetails.builder().clientId(clientId).protectedWithSecret(true)
          .allowedGrants(DEFAULT_GRANTERS).allowedScopes(DEFAULT_SCOPES).build());
    } else {
      return Optional.empty();
    }
  }
}
