package net.civeira.phylax.features.access.trustedclient;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.value.validation.ConstraintFail;
import net.civeira.phylax.common.value.validation.ConstraintFailList;
import net.civeira.phylax.features.access.trustedclient.command.TrustedClientWriteAttributes;
import net.civeira.phylax.features.access.trustedclient.event.TrustedClientCreateEvent;
import net.civeira.phylax.features.access.trustedclient.event.TrustedClientDeleteEvent;
import net.civeira.phylax.features.access.trustedclient.event.TrustedClientDisableEvent;
import net.civeira.phylax.features.access.trustedclient.event.TrustedClientEnableEvent;
import net.civeira.phylax.features.access.trustedclient.event.TrustedClientEvent;
import net.civeira.phylax.features.access.trustedclient.event.TrustedClientUpdateEvent;
import net.civeira.phylax.features.access.trustedclient.transition.create.TrustedClientCreatePipeline;
import net.civeira.phylax.features.access.trustedclient.transition.delete.TrustedClientDeletePipeline;
import net.civeira.phylax.features.access.trustedclient.transition.disable.TrustedClientDisablePipeline;
import net.civeira.phylax.features.access.trustedclient.transition.enable.TrustedClientEnablePipeline;
import net.civeira.phylax.features.access.trustedclient.transition.update.TrustedClientUpdatePipeline;
import net.civeira.phylax.features.access.trustedclient.valueobject.AllowedRedirectsVO;
import net.civeira.phylax.features.access.trustedclient.valueobject.CodeVO;
import net.civeira.phylax.features.access.trustedclient.valueobject.EnabledVO;
import net.civeira.phylax.features.access.trustedclient.valueobject.PublicAllowVO;
import net.civeira.phylax.features.access.trustedclient.valueobject.SecretOauthVO;
import net.civeira.phylax.features.access.trustedclient.valueobject.UidVO;
import net.civeira.phylax.features.access.trustedclient.valueobject.VersionVO;

@AllArgsConstructor
@Getter
@ToString
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class TrustedClient implements TrustedClientRef {

  /**
   * @autogenerated EntityGenerator
   * @param attributes
   * @param pipeline
   * @return
   */
  public static TrustedClient create(final TrustedClientWriteAttributes attributes,
      final TrustedClientCreatePipeline pipeline) {
    return pipeline.create(attributes, attr -> {
      TrustedClient instance = new TrustedClient(attr, Optional.empty());
      instance.addEvent(TrustedClientCreateEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * Si permitimos login directo de la app, obligamos a indicar un secreto.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private AllowedRedirectsVO allowedRedirects = AllowedRedirectsVO.nullValue();

  /**
   * El código identificativo de la aplicación
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private CodeVO code;

  /**
   * Una marca que permite quitar el acceso a una cuenta sin borrarla
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private EnabledVO enabled = EnabledVO.nullValue();

  /**
   * If true, users can use these client to access with public code flow
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private PublicAllowVO publicAllow;

  /**
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private List<TrustedClientEvent> recordedEvents = List.of();

  /**
   * If the user is not delegated, the phrasse to identify
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private SecretOauthVO secretOauth = SecretOauthVO.nullValue();

  /**
   * El identificador de la aplicacion
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private UidVO uid;

  /**
   * Campo con el número de version de trusted client para controlar bloqueos optimistas
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private VersionVO version = VersionVO.nullValue();

  /**
   * @autogenerated EntityGenerator
   * @param attribute
   * @param previous
   */
  private TrustedClient(final TrustedClientWriteAttributes attribute,
      final Optional<TrustedClient> previous) {
    ConstraintFailList list = new ConstraintFailList();
    this.uid = attribute.getUid().orElse(previous.map(TrustedClient::getUid).orElse(null));
    this.code = attribute.getCode().orElse(previous.map(TrustedClient::getCode).orElse(null));
    this.publicAllow =
        attribute.getPublicAllow().orElse(previous.map(TrustedClient::getPublicAllow).orElse(null));
    this.secretOauth = attribute.getSecretOauth()
        .orElse(previous.map(TrustedClient::getSecretOauth).orElseGet(SecretOauthVO::nullValue));
    this.allowedRedirects = attribute.getAllowedRedirects().orElse(
        previous.map(TrustedClient::getAllowedRedirects).orElseGet(AllowedRedirectsVO::nullValue));
    this.enabled = attribute.getEnabled()
        .orElse(previous.map(TrustedClient::getEnabled).orElseGet(EnabledVO::nullValue));
    this.version = attribute.getVersion()
        .orElse(previous.map(TrustedClient::getVersion).orElseGet(VersionVO::nullValue));
    if (null == uid) {
      list.add(new ConstraintFail("REQUIRED", "uid", null));
    }
    if (null == code) {
      list.add(new ConstraintFail("REQUIRED", "code", null));
    }
    if (null == publicAllow) {
      list.add(new ConstraintFail("REQUIRED", "publicAllow", null));
    }
    if (list.hasErrors()) {
      throw new ConstraintException(list);
    }
    this.recordedEvents = previous.map(TrustedClient::getRecordedEvents).orElseGet(List::of);
  }

  /**
   * @autogenerated EntityGenerator
   * @param pipeline
   * @return
   */
  public TrustedClient delete(final TrustedClientDeletePipeline pipeline) {
    return pipeline.delete(this, () -> {
      TrustedClient instance = this;
      instance.addEvent(TrustedClientDeleteEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @param pipeline
   * @return
   */
  public TrustedClient disable(final TrustedClientDisablePipeline pipeline) {
    return pipeline.disable(this, attr -> {
      attr.setEnabled(false);
      TrustedClient instance = new TrustedClient(attr, Optional.of(this));
      instance.addEvent(TrustedClientDisableEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @param pipeline
   * @return
   */
  public TrustedClient enable(final TrustedClientEnablePipeline pipeline) {
    return pipeline.enable(this, attr -> {
      attr.setEnabled(true);
      TrustedClient instance = new TrustedClient(attr, Optional.of(this));
      instance.addEvent(TrustedClientEnableEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<String> getAllowedRedirectsValue() {
    return getAllowedRedirects().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public String getCodeValue() {
    return getCode().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @param cypher
   * @return
   */
  public Optional<String> getSecretOauthCypheredValue(final AesCipherService cypher) {
    return getSecretOauth().getCypheredValue(cypher);
  }

  /**
   * @autogenerated EntityGenerator
   * @param cypher
   * @return
   */
  public Optional<String> getSecretOauthPlainValue(final AesCipherService cypher) {
    return getSecretOauth().getPlainValue(cypher);
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  @Override
  public String getUidValue() {
    return this.uid.getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<Integer> getVersionValue() {
    return getVersion().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public boolean isEnabled() {
    return Boolean.TRUE.equals(getEnabled().getValue().orElse(Boolean.FALSE));
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public boolean isPublicAllow() {
    return Boolean.TRUE.equals(getPublicAllow().getValue());
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public TrustedClient nextVersion() {
    return TrustedClient.builder().uid(this.uid).code(this.code).publicAllow(this.publicAllow)
        .secretOauth(this.secretOauth).allowedRedirects(this.allowedRedirects).enabled(this.enabled)
        .version(VersionVO.from(this.version() + 1)).build();
  }

  /**
   * @autogenerated EntityGenerator
   * @param attributes
   * @param pipeline
   * @return
   */
  public TrustedClient update(final TrustedClientWriteAttributes attributes,
      final TrustedClientUpdatePipeline pipeline) {
    return pipeline.update(attributes, this, attr -> {
      TrustedClient instance = new TrustedClient(attr, Optional.of(this));
      instance.addEvent(TrustedClientUpdateEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Integer version() {
    return this.getVersion().getValue().orElse(0);
  }

  /**
   * @autogenerated EntityGenerator
   * @param event
   */
  private void addEvent(final TrustedClientEvent event) {
    List<TrustedClientEvent> events = new ArrayList<>(this.recordedEvents);
    events.add(event);
    this.recordedEvents = List.copyOf(events);
  }
}
