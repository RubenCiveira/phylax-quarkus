package net.civeira.phylax.features.access.trustedclient.domain;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;
import lombok.With;
import lombok.experimental.Delegate;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.value.validation.ConstraintFail;
import net.civeira.phylax.common.value.validation.ConstraintFailList;
import net.civeira.phylax.features.access.trustedclient.domain.event.TrustedClientCreateEvent;
import net.civeira.phylax.features.access.trustedclient.domain.event.TrustedClientDeleteEvent;
import net.civeira.phylax.features.access.trustedclient.domain.event.TrustedClientDisableEvent;
import net.civeira.phylax.features.access.trustedclient.domain.event.TrustedClientEnableEvent;
import net.civeira.phylax.features.access.trustedclient.domain.event.TrustedClientEvent;
import net.civeira.phylax.features.access.trustedclient.domain.event.TrustedClientUpdateEvent;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.AllowedRedirectsVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.CodeVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.EnabledVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.PublicAllowVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.SecretOauthVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.UidVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.VersionVO;

/**
 * Las diferentes aplicaciones que pueden usar el sistema de acceso. Dado qua la app va en la
 * petición de login, podemos obtener la cuenta asociado a traves del proyecto
 */
@Builder
@Getter
@With
@ToString
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@EqualsAndHashCode
public class TrustedClient implements TrustedClientRef {

  /**
   * Prepare a new trusted client with the provided values
   *
   * @autogenerated EntityGenerator
   * @param change A set of values to create a new trusted client
   * @throws ConstraintException If there are some constraints fails on the changes.
   * @return A well formed trusted client.
   */
  public static TrustedClient create(final TrustedClientChangeSet change)
      throws ConstraintException {
    change.setEnabled(false);
    TrustedClient instance = new TrustedClient(change, Optional.empty());
    instance.addEvent(TrustedClientCreateEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * Si permitimos login directo de la app, obligamos a indicar un secreto.
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @Builder.Default
  private AllowedRedirectsVO allowedRedirectsValue = AllowedRedirectsVO.nullValue();

  /**
   * El código identificativo de la aplicación
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @NonNull
  private CodeVO codeValue;

  /**
   * Una marca que permite quitar el acceso a una cuenta sin borrarla
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @Builder.Default
  private EnabledVO enabledValue = EnabledVO.nullValue();

  /**
   * If true, users can use these client to access with public code flow
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @NonNull
  private PublicAllowVO publicAllowValue;

  /**
   * List of events
   *
   * @autogenerated EntityGenerator
   */
  @Builder.Default
  private List<TrustedClientEvent> recordedEvents = List.of();

  /**
   * If the user is not delegated, the phrasse to identify
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @Builder.Default
  private SecretOauthVO secretOauthValue = SecretOauthVO.nullValue();

  /**
   * El identificador de la aplicacion
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @NonNull
  private UidVO uidValue;

  /**
   * Campo con el número de version de trusted client para controlar bloqueos optimistas
   *
   * @autogenerated EntityGenerator
   */
  @Delegate
  @Builder.Default
  private VersionVO versionValue = VersionVO.nullValue();

  /**
   * @autogenerated EntityGenerator
   * @param attribute
   * @param previous
   */
  private TrustedClient(final TrustedClientChangeSet attribute,
      final Optional<TrustedClient> previous) {
    ConstraintFailList list = new ConstraintFailList();
    this.uidValue =
        attribute.getUid().orElse(previous.map(TrustedClient::getUidValue).orElse(null));
    this.codeValue =
        attribute.getCode().orElse(previous.map(TrustedClient::getCodeValue).orElse(null));
    this.publicAllowValue = attribute.getPublicAllow()
        .orElse(previous.map(TrustedClient::getPublicAllowValue).orElse(null));
    this.secretOauthValue = attribute.getSecretOauth().orElse(
        previous.map(TrustedClient::getSecretOauthValue).orElseGet(SecretOauthVO::nullValue));
    this.allowedRedirectsValue = attribute.getAllowedRedirects().orElse(previous
        .map(TrustedClient::getAllowedRedirectsValue).orElseGet(AllowedRedirectsVO::nullValue));
    this.enabledValue = attribute.getEnabled()
        .orElse(previous.map(TrustedClient::getEnabledValue).orElseGet(EnabledVO::nullValue));
    this.versionValue = attribute.getVersion()
        .orElse(previous.map(TrustedClient::getVersionValue).orElseGet(VersionVO::nullValue));
    if (null == uidValue) {
      list.add(new ConstraintFail("REQUIRED", "uid", null));
    }
    if (null == codeValue) {
      list.add(new ConstraintFail("REQUIRED", "code", null));
    }
    if (null == publicAllowValue) {
      list.add(new ConstraintFail("REQUIRED", "publicAllow", null));
    }
    if (list.hasErrors()) {
      throw new ConstraintException(list);
    }
    this.recordedEvents = previous.map(TrustedClient::getRecordedEvents).orElseGet(List::of);
  }

  /**
   * Apply changes to delete a trusted client
   *
   * @autogenerated EntityGenerator
   * @return A instance of trusted client ready to be deleted
   */
  public TrustedClient delete() {
    TrustedClient instance = this;
    instance.addEvent(TrustedClientDeleteEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * Apply disable on trusted client.
   *
   * @autogenerated EntityGenerator
   * @return A modified instance of trusted client
   */
  public TrustedClient disable() {
    TrustedClientChangeSet attr = new TrustedClientChangeSet();
    attr.setEnabled(false);
    TrustedClient instance = new TrustedClient(attr, Optional.of(this));
    instance.addEvent(TrustedClientDisableEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * Apply enable on trusted client.
   *
   * @autogenerated EntityGenerator
   * @return A modified instance of trusted client
   */
  public TrustedClient enable() {
    TrustedClientChangeSet attr = new TrustedClientChangeSet();
    attr.setEnabled(true);
    TrustedClient instance = new TrustedClient(attr, Optional.of(this));
    instance.addEvent(TrustedClientEnableEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * Modify the values for some of the properties of a trusted client
   *
   * @autogenerated EntityGenerator
   * @param change The properties to be modified
   * @throws ConstraintException If there are some constraints fails on the changes.
   * @return A modified instance of trusted client
   */
  public TrustedClient update(final TrustedClientChangeSet change) throws ConstraintException {
    change.unsetEnabled();
    TrustedClient instance = new TrustedClient(change, Optional.of(this));
    instance.addEvent(TrustedClientUpdateEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public TrustedClient withNextVersion() {
    return withVersionValue(VersionVO.from(nextVersion()));
  }

  /**
   * @autogenerated EntityGenerator
   * @param event
   */
  private void addEvent(final TrustedClientEvent event) {
    List<TrustedClientEvent> events = new ArrayList<>(this.recordedEvents);
    events.add(event);
    this.recordedEvents = List.copyOf(events);
  }
}
