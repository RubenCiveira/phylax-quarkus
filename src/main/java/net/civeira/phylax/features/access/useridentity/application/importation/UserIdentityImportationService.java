package net.civeira.phylax.features.access.useridentity.application.importation;

import java.util.Map;
import java.util.Optional;

import lombok.RequiredArgsConstructor;
import net.civeira.phylax.common.value.validation.ConstraintFail;
import net.civeira.phylax.common.value.validation.ConstraintFailList;
import net.civeira.phylax.features.access.relyingparty.domain.RelyingParty;
import net.civeira.phylax.features.access.relyingparty.domain.RelyingPartyChangeSet;
import net.civeira.phylax.features.access.relyingparty.domain.gateway.RelyingPartyFilter;
import net.civeira.phylax.features.access.relyingparty.domain.gateway.RelyingPartyReadRepositoryGateway;
import net.civeira.phylax.features.access.relyingparty.domain.gateway.RelyingPartyWriteRepositoryGateway;
import net.civeira.phylax.features.access.trustedclient.domain.TrustedClient;
import net.civeira.phylax.features.access.trustedclient.domain.TrustedClientChangeSet;
import net.civeira.phylax.features.access.trustedclient.domain.gateway.TrustedClientFilter;
import net.civeira.phylax.features.access.trustedclient.domain.gateway.TrustedClientReadRepositoryGateway;
import net.civeira.phylax.features.access.trustedclient.domain.gateway.TrustedClientWriteRepositoryGateway;
import net.civeira.phylax.features.access.user.domain.User;
import net.civeira.phylax.features.access.user.domain.UserChangeSet;
import net.civeira.phylax.features.access.user.domain.gateway.UserFilter;
import net.civeira.phylax.features.access.user.domain.gateway.UserReadRepositoryGateway;
import net.civeira.phylax.features.access.user.domain.gateway.UserWriteRepositoryGateway;
import net.civeira.phylax.features.access.useridentity.domain.UserIdentity;
import net.civeira.phylax.features.access.useridentity.domain.UserIdentityChangeSet;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityFilter;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityWriteRepositoryGateway;

@RequiredArgsConstructor
public class UserIdentityImportationService {

  /**
   * @autogenerated VisibilityFilterGenerator
   */
  private final RelyingPartyReadRepositoryGateway relyingPartyReadRepository;

  /**
   * @autogenerated VisibilityFilterGenerator
   */
  private final RelyingPartyWriteRepositoryGateway relyingPartyWriteRepository;

  /**
   * @autogenerated VisibilityFilterGenerator
   */
  private final UserIdentityWriteRepositoryGateway repository;

  /**
   * @autogenerated VisibilityFilterGenerator
   */
  private final TrustedClientReadRepositoryGateway trustedClientReadRepository;

  /**
   * @autogenerated VisibilityFilterGenerator
   */
  private final TrustedClientWriteRepositoryGateway trustedClientWriteRepository;

  /**
   * @autogenerated VisibilityFilterGenerator
   */
  private final UserReadRepositoryGateway userReadRepository;

  /**
   * @autogenerated VisibilityFilterGenerator
   */
  private final UserWriteRepositoryGateway userWriteRepository;

  /**
   * @autogenerated VisibilityFilterGenerator
   * @param row
   * @return
   */
  public UserIdentityImportationResult load(final Map<String, String> row) {
    return load(row, UserIdentityImportationRelatedResolver.builder().build());
  }

  /**
   * @autogenerated VisibilityFilterGenerator
   * @param row
   * @param resolver
   * @return
   */
  public UserIdentityImportationResult load(final Map<String, String> row,
      final UserIdentityImportationRelatedResolver resolver) {
    ConstraintFailList fails = new ConstraintFailList();
    String uid = row.get("uid");
    if (null == uid) {
      fails.add(new ConstraintFail("NOT_NULL", "uid", null));
    }
    boolean exists = false;
    UserIdentity entity = null;
    if (!fails.isEmpty()) {
      Optional<UserIdentity> existing =
          repository.findForUpdate(UserIdentityFilter.builder().uid(uid).build());
      UserIdentityChangeSet change = toChangeSet(row, fails, resolver);
      if (existing.isPresent()) {
        entity = existing.get().update(change);
        exists = true;
      } else {
        entity = UserIdentity.create(change.newUid());
      }
    }
    return fails.isEmpty() ? new UserIdentityImportationResult(entity, exists)
        : new UserIdentityImportationResult(fails);
  }

  /**
   * @autogenerated VisibilityFilterGenerator
   * @param row
   * @param fails
   * @param resolver
   * @return
   */
  public UserIdentityChangeSet toChangeSet(final Map<String, String> row,
      final ConstraintFailList fails, final UserIdentityImportationRelatedResolver resolver) {
    UserIdentityChangeSet change = new UserIdentityChangeSet();
    change = readUser(change, row, fails, resolver);
    change = readRelyingParty(change, row, fails, resolver);
    change = readTrustedClient(change, row, fails, resolver);
    return change;
  }

  /**
   * @autogenerated VisibilityFilterGenerator
   * @param change
   * @param row
   * @param fails
   * @param resolver
   * @return
   */
  private UserIdentityChangeSet readRelyingParty(final UserIdentityChangeSet change,
      final Map<String, String> row, final ConstraintFailList fails,
      final UserIdentityImportationRelatedResolver resolver) {
    String relyingParty = row.get("relyingParty");
    if (relyingParty != null) {
      Optional<RelyingParty> existing =
          relyingPartyReadRepository.find(RelyingPartyFilter.builder().code(relyingParty).build());
      if (existing.isPresent()) {
        return change.relyingParty(existing.get());
      } else if (resolver.isCreateMissingRelyingParty()) {
        RelyingPartyChangeSet childChanges = new RelyingPartyChangeSet().newUid();
        RelyingParty entity =
            (null == resolver.getMissingRelyingPartyFactory()) ? RelyingParty.create(childChanges)
                : resolver.getMissingRelyingPartyFactory().apply(childChanges);
        return change.relyingParty(relyingPartyWriteRepository.create(entity));
      } else {
        fails.add(new ConstraintFail("NOT_FOUND", "relyingParty", relyingParty));
        return change;
      }
    } else {
      return change.unsetRelyingParty();
    }
  }

  /**
   * @autogenerated VisibilityFilterGenerator
   * @param change
   * @param row
   * @param fails
   * @param resolver
   * @return
   */
  private UserIdentityChangeSet readTrustedClient(final UserIdentityChangeSet change,
      final Map<String, String> row, final ConstraintFailList fails,
      final UserIdentityImportationRelatedResolver resolver) {
    String trustedClient = row.get("trustedClient");
    if (trustedClient != null) {
      Optional<TrustedClient> existing = trustedClientReadRepository
          .find(TrustedClientFilter.builder().code(trustedClient).build());
      if (existing.isPresent()) {
        return change.trustedClient(existing.get());
      } else if (resolver.isCreateMissingTrustedClient()) {
        TrustedClientChangeSet childChanges = new TrustedClientChangeSet().newUid();
        TrustedClient entity =
            (null == resolver.getMissingTrustedClientFactory()) ? TrustedClient.create(childChanges)
                : resolver.getMissingTrustedClientFactory().apply(childChanges);
        return change.trustedClient(trustedClientWriteRepository.create(entity));
      } else {
        fails.add(new ConstraintFail("NOT_FOUND", "trustedClient", trustedClient));
        return change;
      }
    } else {
      return change.unsetTrustedClient();
    }
  }

  /**
   * @autogenerated VisibilityFilterGenerator
   * @param change
   * @param row
   * @param fails
   * @param resolver
   * @return
   */
  private UserIdentityChangeSet readUser(final UserIdentityChangeSet change,
      final Map<String, String> row, final ConstraintFailList fails,
      final UserIdentityImportationRelatedResolver resolver) {
    String user = row.get("user");
    if (user != null) {
      Optional<User> existing = userReadRepository.find(UserFilter.builder().name(user).build());
      if (existing.isPresent()) {
        return change.user(existing.get());
      } else if (resolver.isCreateMissingUser()) {
        UserChangeSet childChanges = new UserChangeSet().newUid();
        User entity = (null == resolver.getMissingUserFactory()) ? User.create(childChanges)
            : resolver.getMissingUserFactory().apply(childChanges);
        return change.user(userWriteRepository.create(entity));
      } else {
        fails.add(new ConstraintFail("NOT_FOUND", "user", user));
        return change;
      }
    } else {
      return change.unsetUser();
    }
  }
}
