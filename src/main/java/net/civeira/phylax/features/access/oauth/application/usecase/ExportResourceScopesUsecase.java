/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.usecase;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.features.access.relyingparty.domain.RelyingParty;
import net.civeira.phylax.features.access.relyingparty.domain.gateway.RelyingPartyFilter;
import net.civeira.phylax.features.access.relyingparty.domain.gateway.RelyingPartyReadRepositoryGateway;
import net.civeira.phylax.features.access.role.domain.Domains;
import net.civeira.phylax.features.access.role.domain.Role;
import net.civeira.phylax.features.access.role.domain.gateway.RoleFilter;
import net.civeira.phylax.features.access.role.domain.gateway.RoleReadRepositoryGateway;
import net.civeira.phylax.features.access.securitydomain.domain.SecurityDomain;
import net.civeira.phylax.features.access.securitydomain.domain.gateway.SecurityDomainFilter;
import net.civeira.phylax.features.access.securitydomain.domain.gateway.SecurityDomainReadRepositoryGateway;
import net.civeira.phylax.features.access.securityscope.domain.SecurityScope;
import net.civeira.phylax.features.access.securityscope.domain.SecurityScopeKindOptions;
import net.civeira.phylax.features.access.securityscope.domain.SecurityScopeVisibilityOptions;
import net.civeira.phylax.features.access.securityscope.domain.gateway.SecurityScopeFilter;
import net.civeira.phylax.features.access.securityscope.domain.gateway.SecurityScopeReadRepositoryGateway;
import net.civeira.phylax.features.oauth.rbac.domain.RoleGrant;

@ApplicationScoped
@RequiredArgsConstructor
public class ExportResourceScopesUsecase {
  private final RelyingPartyReadRepositoryGateway parties;
  private final RoleReadRepositoryGateway roles;
  private final SecurityScopeReadRepositoryGateway scopes;
  private final SecurityDomainReadRepositoryGateway domains;

  public List<RoleGrant> granted(String relayParty) {
    return parties.find(RelyingPartyFilter.builder().code(relayParty).build())
        .map(this::grantedForRely).orElseGet(List::of);
  }

  public List<RoleGrant> grantedForRely(RelyingParty party) {
    List<SecurityScope> secScopes =
        scopes.list(SecurityScopeFilter.builder().relyingParty(party).build());
    if (secScopes.isEmpty()) {
      return List.of();
    }
    List<SecurityDomain> secDomains = domains.list(SecurityDomainFilter.builder().build());
    List<Role> secRoles = roles.list(RoleFilter.builder().build());
    // Que roles tienes
    Map<String, List<String>> roleSecs = new HashMap<>();

    for (Role role : secRoles) {
      for (Domains roleDomain : role.getDomains()) {
        String ref = roleDomain.getSecurityDomainUid();
        append(role.getName(), ref, roleSecs);
      }
    }
    Map<String, List<String>> byRole = new HashMap<>();
    Map<String, List<String>> bySec = new HashMap<>();
    // para cada secDomain => cruzamos
    for (SecurityScope securityScope : secScopes) {
      if (checkPublic(securityScope)) {
        append("-", securityScope, byRole);
      }
      for (SecurityDomain securityDomain : secDomains) {
        securityScope.getKind().ifPresent(kind -> {
          boolean allowed = checkReadAll(kind, securityDomain, securityScope)
              || checkWriteAll(kind, securityDomain, securityScope)
              || checkManageAll(kind, securityDomain, securityScope) || checkPublic(securityScope)
              || checkAuthorized(securityScope) || checkExplicit();
          if (allowed) {
            append(securityDomain.getUid(), securityScope, bySec);
          }
        });
      }
    }

    for (Entry<String, List<String>> entry : bySec.entrySet()) {
      String domainId = entry.getKey();
      List<String> domainScopes = entry.getValue();
      // get roles.
      for (Entry<String, List<String>> entry2 : roleSecs.entrySet()) {
        String roleName = entry2.getKey();
        List<String> roleDomains = entry2.getValue();
        if (roleDomains.contains(domainId)) {
          domainScopes.forEach(domain -> append(roleName, domain, byRole));
        }
      }
    }
    bySec.clear();
    roleSecs.clear();
    // security_domain
    List<RoleGrant> list = new ArrayList<>();
    for (Entry<String, List<String>> entry : byRole.entrySet()) {
      list.add(RoleGrant.builder().rolename(entry.getKey()).restrictedFields(Map.of())
          .allowedScopes(new HashSet<>(entry.getValue())).build());
    }
    byRole.clear();
    return list;
  }

  private boolean checkPublic(SecurityScope securityScope) {
    return securityScope.getVisibility()
        .orElse(SecurityScopeVisibilityOptions.EXPLICIT) == SecurityScopeVisibilityOptions.PUBLIC;
  }

  private boolean checkAuthorized(SecurityScope securityScope) {
    return securityScope.getVisibility().orElse(
        SecurityScopeVisibilityOptions.EXPLICIT) == SecurityScopeVisibilityOptions.AUTHORIZED;
  }

  private boolean checkExplicit() {
    return false;
  }

  private boolean checkReadAll(SecurityScopeKindOptions kind, SecurityDomain securityDomain,
      SecurityScope securityScope) {
    return kind == SecurityScopeKindOptions.READ && securityDomain.isReadAll();
  }

  private boolean checkWriteAll(SecurityScopeKindOptions kind, SecurityDomain securityDomain,
      SecurityScope securityScope) {
    return kind == SecurityScopeKindOptions.WRITE && securityDomain.isWriteAll();
  }

  private boolean checkManageAll(SecurityScopeKindOptions kind, SecurityDomain securityDomain,
      SecurityScope securityScope) {
    return kind == SecurityScopeKindOptions.MANAGE && securityDomain.isManageAll();
  }

  private void append(String name, SecurityScope securityScope, Map<String, List<String>> map) {
    append(name, securityScope.getResource() + ":" + securityScope.getScope(), map);
  }

  private void append(String name, String scope, Map<String, List<String>> map) {
    if (!map.containsKey(name)) {
      map.put(name, new ArrayList<>());
    }
    map.get(name).add(scope);
  }
}
