package net.civeira.phylax.features.access.useraccesstemporalcode.infrastructure.repository;

import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Predicate;

import javax.sql.DataSource;

import io.opentelemetry.api.trace.Tracer;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.algorithms.Slider;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.exception.NotFoundException;
import net.civeira.phylax.common.infrastructure.sql.OptimistLockException;
import net.civeira.phylax.common.infrastructure.sql.SqlCommand;
import net.civeira.phylax.common.infrastructure.sql.SqlConverter;
import net.civeira.phylax.common.infrastructure.sql.SqlListParameterValue;
import net.civeira.phylax.common.infrastructure.sql.SqlOperator;
import net.civeira.phylax.common.infrastructure.sql.SqlParameterValue;
import net.civeira.phylax.common.infrastructure.sql.SqlQuery;
import net.civeira.phylax.common.infrastructure.sql.SqlResult;
import net.civeira.phylax.common.infrastructure.sql.SqlSchematicQuery;
import net.civeira.phylax.common.infrastructure.sql.SqlTemplate;
import net.civeira.phylax.features.access.useraccesstemporalcode.UserAccessTemporalCode;
import net.civeira.phylax.features.access.useraccesstemporalcode.UserAccessTemporalCodeRef;
import net.civeira.phylax.features.access.useraccesstemporalcode.query.UserAccessTemporalCodeCursor;
import net.civeira.phylax.features.access.useraccesstemporalcode.query.UserAccessTemporalCodeFilter;
import net.civeira.phylax.features.access.useraccesstemporalcode.valueobject.FailedLoginAttemptsVO;
import net.civeira.phylax.features.access.useraccesstemporalcode.valueobject.RecoveryCodeExpirationVO;
import net.civeira.phylax.features.access.useraccesstemporalcode.valueobject.RecoveryCodeVO;
import net.civeira.phylax.features.access.useraccesstemporalcode.valueobject.TempSecondFactorSeedExpirationVO;
import net.civeira.phylax.features.access.useraccesstemporalcode.valueobject.TempSecondFactorSeedVO;
import net.civeira.phylax.features.access.useraccesstemporalcode.valueobject.UidVO;
import net.civeira.phylax.features.access.useraccesstemporalcode.valueobject.UserVO;
import net.civeira.phylax.features.access.useraccesstemporalcode.valueobject.VersionVO;

@ApplicationScoped
@RequiredArgsConstructor
@Slf4j
public class UserAccessTemporalCodeRepository {

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String FAILED_LOGIN_ATTEMPTS = "failedLoginAttempts";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String FAILED_LOGIN_ATTEMPTS_SNAKE = "failed_login_attempts";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String RECOVERY_CODE = "recoveryCode";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String RECOVERY_CODE_EXPIRATION = "recoveryCodeExpiration";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String RECOVERY_CODE_EXPIRATION_SNAKE = "recovery_code_expiration";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String RECOVERY_CODE_SNAKE = "recovery_code";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TEMP_SECOND_FACTOR_SEED = "tempSecondFactorSeed";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TEMP_SECOND_FACTOR_SEED_EXPIRATION = "tempSecondFactorSeedExpiration";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TEMP_SECOND_FACTOR_SEED_EXPIRATION_SNAKE =
      "temp_second_factor_seed_expiration";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TEMP_SECOND_FACTOR_SEED_SNAKE = "temp_second_factor_seed";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String UID = "uid";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USER = "user";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USER_ACCESS_TEMPORAL_CODE_FAILED_LOGIN_ATTEMPTS =
      "user_access_temporal_code.failed_login_attempts";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USER_ACCESS_TEMPORAL_CODE_RECOVERY_CODE =
      "user_access_temporal_code.recovery_code";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USER_ACCESS_TEMPORAL_CODE_RECOVERY_CODE_EXPIRATION =
      "user_access_temporal_code.recovery_code_expiration";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USER_ACCESS_TEMPORAL_CODE_SNAKE = "user_access_temporal_code";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USER_ACCESS_TEMPORAL_CODE_TEMP_SECOND_FACTOR_SEED =
      "user_access_temporal_code.temp_second_factor_seed";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USER_ACCESS_TEMPORAL_CODE_TEMP_SECOND_FACTOR_SEED_EXPIRATION =
      "user_access_temporal_code.temp_second_factor_seed_expiration";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USER_ACCESS_TEMPORAL_CODE_UID = "user_access_temporal_code.uid";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USER_ACCESS_TEMPORAL_CODE_USER = "user_access_temporal_code.user";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USER_ACCESS_TEMPORAL_CODE_USER_TENANT =
      "user_access_temporal_code_user.tenant";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USER_ACCESS_TEMPORAL_CODE_VERSION =
      "user_access_temporal_code.version";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String VERSION = "version";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final AesCipherService cypher;

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final DataSource datasource;

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final Tracer tracer;

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public long count(UserAccessTemporalCodeFilter filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<Long> sq = filteredQuery(template, filter);
      sq.select("count(uid) as uid");
      return sq.query(row -> Optional.of(row.getLong(1))).one().orElse(0l);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public UserAccessTemporalCode create(UserAccessTemporalCode entity) {
    return runCreate(entity, null);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  public UserAccessTemporalCode create(UserAccessTemporalCode entity,
      Predicate<UserAccessTemporalCode> verifier) {
    return runCreate(entity, verifier);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   */
  public void delete(UserAccessTemporalCode entity) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlCommand sq = template
          .createSqlCommand("delete from \"user_access_temporal_code\" where \"uid\" = :uid");
      sq.with(UID, SqlParameterValue.of(entity.getUidValue()));
      int num = sq.execute();
      if (0 == num) {
        throw new IllegalArgumentException("No delete from");
      }
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param reference
   * @return
   */
  public UserAccessTemporalCode enrich(UserAccessTemporalCodeRef reference) {
    return reference instanceof UserAccessTemporalCode userAccessTemporalCode
        ? userAccessTemporalCode
        : retrieve(reference.getUidValue(), Optional.empty())
            .orElseThrow(() -> new NotFoundException(
                "Trying to enrich inexistent UserAccessTemporalCode: " + reference.getUidValue()));
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param reference
   * @return
   */
  public UserAccessTemporalCode enrichForUpdate(UserAccessTemporalCodeRef reference) {
    return reference instanceof UserAccessTemporalCode userAccessTemporalCode
        ? userAccessTemporalCode
        : retrieveForUpdate(reference.getUidValue(), Optional.empty())
            .orElseThrow(() -> new NotFoundException(
                "Trying to enrich inexistent UserAccessTemporalCode: " + reference.getUidValue()));
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public boolean exists(String uid, Optional<UserAccessTemporalCodeFilter> filter) {
    return retrieve(uid, filter).isPresent();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public boolean existsForUpdate(String uid, Optional<UserAccessTemporalCodeFilter> filter) {
    return retrieveForUpdate(uid, filter).isPresent();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public Optional<UserAccessTemporalCode> find(UserAccessTemporalCodeFilter filter) {
    UserAccessTemporalCodeCursor cursor = UserAccessTemporalCodeCursor.builder().build();
    return new UserAccessTemporalCodeSlider(runList(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor).one();
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public Optional<UserAccessTemporalCode> find(final String sql,
      final Map<String, SqlParameterValue> params) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<UserAccessTemporalCode> createSqlQuery = template.createSqlQuery(sql);
      params.forEach(createSqlQuery::with);
      return createSqlQuery.query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public Optional<UserAccessTemporalCode> findForUpdate(UserAccessTemporalCodeFilter filter) {
    UserAccessTemporalCodeCursor cursor = UserAccessTemporalCodeCursor.builder().build();
    return new UserAccessTemporalCodeSlider(runListForUpdate(filter, cursor),
        cursor.getLimit().orElse(0), this::runList, filter, cursor).one();
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public Optional<UserAccessTemporalCode> findForUpdate(final String sql,
      final Map<String, SqlParameterValue> params) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<UserAccessTemporalCode> createSqlQuery = template.createSqlQuery(sql);
      params.forEach(createSqlQuery::with);
      return createSqlQuery.forUpdate().query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public List<UserAccessTemporalCode> list(UserAccessTemporalCodeFilter filter) {
    UserAccessTemporalCodeCursor cursor = UserAccessTemporalCodeCursor.builder().build();
    return new UserAccessTemporalCodeSlider(runList(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor).all();
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<UserAccessTemporalCode> list(final String sql,
      final Map<String, SqlParameterValue> params) {
    return list(sql, params, null, false);
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<UserAccessTemporalCode> list(final String sql,
      final Map<String, SqlParameterValue> params, final int limit) {
    return list(sql, params, Integer.valueOf(limit), false);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public List<UserAccessTemporalCode> listForUpdate(UserAccessTemporalCodeFilter filter) {
    UserAccessTemporalCodeCursor cursor = UserAccessTemporalCodeCursor.builder().build();
    return new UserAccessTemporalCodeSlider(runListForUpdate(filter, cursor),
        cursor.getLimit().orElse(0), this::runList, filter, cursor).all();
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<UserAccessTemporalCode> listForUpdate(final String sql,
      final Map<String, SqlParameterValue> params) {
    return list(sql, params, null, true);
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<UserAccessTemporalCode> listForUpdate(final String sql,
      final Map<String, SqlParameterValue> params, final int limit) {
    return list(sql, params, Integer.valueOf(limit), true);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public Optional<UserAccessTemporalCode> retrieve(String uid,
      Optional<UserAccessTemporalCodeFilter> filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      UserAccessTemporalCodeFilter readyFilter = filter.map(val -> val.withUid(uid))
          .orElseGet(() -> UserAccessTemporalCodeFilter.builder().uid(uid).build());
      SqlSchematicQuery<UserAccessTemporalCode> sq = filteredQuery(template, readyFilter);
      return sq.query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public Optional<UserAccessTemporalCode> retrieveForUpdate(String uid,
      Optional<UserAccessTemporalCodeFilter> filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      UserAccessTemporalCodeFilter readyFilter = filter.map(val -> val.withUid(uid))
          .orElseGet(() -> UserAccessTemporalCodeFilter.builder().uid(uid).build());
      SqlSchematicQuery<UserAccessTemporalCode> sq = filteredQuery(template, readyFilter);
      return sq.forUpdate().query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  public Slider<UserAccessTemporalCode> slide(UserAccessTemporalCodeFilter filter,
      UserAccessTemporalCodeCursor cursor) {
    return new UserAccessTemporalCodeSlider(runList(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  public Slider<UserAccessTemporalCode> slideForUpdate(UserAccessTemporalCodeFilter filter,
      UserAccessTemporalCodeCursor cursor) {
    return new UserAccessTemporalCodeSlider(runListForUpdate(filter, cursor),
        cursor.getLimit().orElse(0), this::runList, filter, cursor);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public UserAccessTemporalCode update(UserAccessTemporalCode entity) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlCommand sq = template.createSqlCommand(
          "update \"user_access_temporal_code\" set  \"user\" = :user, \"temp_second_factor_seed\" = :tempSecondFactorSeed, \"temp_second_factor_seed_expiration\" = :tempSecondFactorSeedExpiration, \"failed_login_attempts\" = :failedLoginAttempts, \"recovery_code\" = :recoveryCode, \"recovery_code_expiration\" = :recoveryCodeExpiration, \"version\" = \"version\" + 1 where \"uid\" = :uid and \"version\" = :version");
      sq.with(UID, SqlParameterValue.of(entity.getUid().getValue()));
      sq.with(USER, SqlParameterValue.of(entity.getUser().getReferenceValue()));
      sq.with(TEMP_SECOND_FACTOR_SEED, entity.getTempSecondFactorSeed().getCypheredValue(cypher)
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullString));
      sq.with(TEMP_SECOND_FACTOR_SEED_EXPIRATION,
          entity.getTempSecondFactorSeedExpiration().getValue().map(SqlParameterValue::of)
              .orElseGet(SqlParameterValue::ofNullOffsetDateTime));
      sq.with(FAILED_LOGIN_ATTEMPTS, entity.getFailedLoginAttempts().getValue()
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullInteger));
      sq.with(RECOVERY_CODE, entity.getRecoveryCode().getValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(RECOVERY_CODE_EXPIRATION, entity.getRecoveryCodeExpiration().getValue()
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullOffsetDateTime));
      sq.with(VERSION, entity.getVersion().getValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      int num = sq.execute();
      if (0 == num) {
        throw new OptimistLockException("No delete from");
      }
      return entity.nextVersion();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @return
   */
  private SqlConverter<UserAccessTemporalCode> converter() {
    return row -> {
      try {
        return Optional.of(UserAccessTemporalCode.builder().uid(UidVO.from(row.getString(UID)))
            .user(UserVO.fromReference(row.getString(USER)))
            .tempSecondFactorSeed(
                TempSecondFactorSeedVO.fromCyphered(row.getString(TEMP_SECOND_FACTOR_SEED_SNAKE)))
            .tempSecondFactorSeedExpiration(TempSecondFactorSeedExpirationVO
                .from(null == row.getTimestamp(TEMP_SECOND_FACTOR_SEED_EXPIRATION_SNAKE) ? null
                    : OffsetDateTime.ofInstant(
                        Instant.ofEpochMilli(
                            row.getTimestamp(TEMP_SECOND_FACTOR_SEED_EXPIRATION_SNAKE).getTime()),
                        ZoneId.systemDefault())))
            .failedLoginAttempts(
                FailedLoginAttemptsVO.from(row.getInt(FAILED_LOGIN_ATTEMPTS_SNAKE)))
            .recoveryCode(RecoveryCodeVO.from(row.getString(RECOVERY_CODE_SNAKE)))
            .recoveryCodeExpiration(RecoveryCodeExpirationVO
                .from(null == row.getTimestamp(RECOVERY_CODE_EXPIRATION_SNAKE) ? null
                    : OffsetDateTime.ofInstant(
                        Instant.ofEpochMilli(
                            row.getTimestamp(RECOVERY_CODE_EXPIRATION_SNAKE).getTime()),
                        ZoneId.systemDefault())))
            .version(VersionVO.from(row.getInt(VERSION))).build());
      } catch (ConstraintException ce) {
        log.error("Unable to map data for {}", row.getString(1), ce);
        return Optional.empty();
      }
    };
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param template
   * @param filter
   * @return
   */
  private <T> SqlSchematicQuery<T> filteredQuery(SqlTemplate template,
      UserAccessTemporalCodeFilter filter) {
    SqlSchematicQuery<T> sq = template.createSqlSchematicQuery(USER_ACCESS_TEMPORAL_CODE_SNAKE);
    sq.selectFields(USER_ACCESS_TEMPORAL_CODE_UID, USER_ACCESS_TEMPORAL_CODE_USER,
        USER_ACCESS_TEMPORAL_CODE_TEMP_SECOND_FACTOR_SEED,
        USER_ACCESS_TEMPORAL_CODE_TEMP_SECOND_FACTOR_SEED_EXPIRATION,
        USER_ACCESS_TEMPORAL_CODE_FAILED_LOGIN_ATTEMPTS, USER_ACCESS_TEMPORAL_CODE_RECOVERY_CODE,
        USER_ACCESS_TEMPORAL_CODE_RECOVERY_CODE_EXPIRATION, USER_ACCESS_TEMPORAL_CODE_VERSION);
    filter.getUid().ifPresent(uid -> sq.where(UID, SqlOperator.EQ, SqlParameterValue.of(uid)));
    if (!filter.getUids().isEmpty()) {
      sq.where(UID, SqlOperator.IN, SqlListParameterValue.strings(filter.getUids()));
    }
    filter.getSearch().ifPresent(
        search -> sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%")));
    filter.getUser().ifPresent(
        user -> sq.where(USER, SqlOperator.EQ, SqlParameterValue.of(user.getUidValue())));
    if (!filter.getUsers().isEmpty()) {
      sq.where(USER, SqlOperator.IN, SqlListParameterValue.strings(filter.getUsers()));
    }
    filter.getUserTenantTenantAccesible().ifPresent(userTenantTenantAccesible -> {
      sq.join("user", "user_access_temporal_code_user", "user_access_temporal_code.user",
          "user_access_temporal_code_user.uid");
      sq.where(USER_ACCESS_TEMPORAL_CODE_USER_TENANT, SqlOperator.EQ,
          SqlParameterValue.of(userTenantTenantAccesible));
    });
    return sq;
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @param forUpdate
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  private List<UserAccessTemporalCode> list(final String sql,
      final Map<String, SqlParameterValue> params, final Integer limit, final boolean forUpdate) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<UserAccessTemporalCode> createSqlQuery = template.createSqlQuery(sql);
      params.forEach(createSqlQuery::with);
      if (forUpdate) {
        createSqlQuery = createSqlQuery.forUpdate();
      }
      SqlResult<UserAccessTemporalCode> query = createSqlQuery.query(converter());
      return null == limit ? query.all() : query.limit(limit);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  private UserAccessTemporalCode runCreate(UserAccessTemporalCode entity,
      Predicate<UserAccessTemporalCode> verifier) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlCommand sq = template.createSqlCommand(
          "insert into \"user_access_temporal_code\" ( \"uid\", \"user\", \"temp_second_factor_seed\", \"temp_second_factor_seed_expiration\", \"failed_login_attempts\", \"recovery_code\", \"recovery_code_expiration\", \"version\") values ( :uid, :user, :tempSecondFactorSeed, :tempSecondFactorSeedExpiration, :failedLoginAttempts, :recoveryCode, :recoveryCodeExpiration, :version)");
      sq.with(UID, SqlParameterValue.of(entity.getUid().getValue()));
      sq.with(USER, SqlParameterValue.of(entity.getUser().getReferenceValue()));
      sq.with(TEMP_SECOND_FACTOR_SEED, entity.getTempSecondFactorSeed().getCypheredValue(cypher)
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullString));
      sq.with(TEMP_SECOND_FACTOR_SEED_EXPIRATION,
          entity.getTempSecondFactorSeedExpiration().getValue().map(SqlParameterValue::of)
              .orElseGet(SqlParameterValue::ofNullOffsetDateTime));
      sq.with(FAILED_LOGIN_ATTEMPTS, entity.getFailedLoginAttempts().getValue()
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullInteger));
      sq.with(RECOVERY_CODE, entity.getRecoveryCode().getValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(RECOVERY_CODE_EXPIRATION, entity.getRecoveryCodeExpiration().getValue()
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullOffsetDateTime));
      sq.with(VERSION, entity.getVersion().getValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      int num = sq.execute();
      if (0 == num) {
        throw new IllegalArgumentException("No insert into");
      }
      return verifier == null ? entity : verified(verifier.test(entity), entity, template);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  private Iterator<UserAccessTemporalCode> runList(UserAccessTemporalCodeFilter filter,
      UserAccessTemporalCodeCursor cursor) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<UserAccessTemporalCode> sq = filteredQuery(template, filter);
      cursor.getSinceUid()
          .ifPresent(since -> sq.where(UID, SqlOperator.GT, SqlParameterValue.of(since)));
      sq.orderAsc("uid");
      return sq.query(converter()).limit(cursor.getLimit()).iterator();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  private Iterator<UserAccessTemporalCode> runListForUpdate(UserAccessTemporalCodeFilter filter,
      UserAccessTemporalCodeCursor cursor) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<UserAccessTemporalCode> sq = filteredQuery(template, filter);
      cursor.getSinceUid()
          .ifPresent(since -> sq.where(UID, SqlOperator.GT, SqlParameterValue.of(since)));
      sq.orderAsc("uid");
      return sq.forUpdate().query(converter()).limit(cursor.getLimit()).iterator();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param exists
   * @param entity
   * @param template
   * @return
   */
  private UserAccessTemporalCode verified(boolean exists, UserAccessTemporalCode entity,
      SqlTemplate template) {
    if (exists) {
      return entity;
    } else {
      template.createSqlCommand("delete from \"user_access_temporal_code\" where \"uid\" = :uid")
          .with("uid", SqlParameterValue.of(entity.getUidValue())).execute();
      throw new NotFoundException("");
    }
  }
}
