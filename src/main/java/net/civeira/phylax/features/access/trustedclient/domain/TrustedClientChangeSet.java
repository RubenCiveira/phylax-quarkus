package net.civeira.phylax.features.access.trustedclient.domain;

import lombok.NoArgsConstructor;
import lombok.experimental.Delegate;
import net.civeira.phylax.common.value.Uuid;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.AllowedRedirectsValueHolder;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.CodeValueHolder;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.EnabledValueHolder;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.PublicAllowValueHolder;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.SecretOauthValueHolder;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.UidValueHolder;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.VersionValueHolder;

/**
 * A dto transfer to hold trusted client attribute values
 */
@NoArgsConstructor
public class TrustedClientChangeSet {

  /**
   * El allowed redirects de trusted client
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private AllowedRedirectsValueHolder<TrustedClientChangeSet> allowedRedirectsValue =
      new AllowedRedirectsValueHolder<>(this);

  /**
   * El código identificativo de la aplicación
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private CodeValueHolder<TrustedClientChangeSet> codeValue = new CodeValueHolder<>(this);

  /**
   * The indicator to allow the account be used without deleting it
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private EnabledValueHolder<TrustedClientChangeSet> enabledValue = new EnabledValueHolder<>(this);

  /**
   * If true, users can use these client to access with public code flow
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private PublicAllowValueHolder<TrustedClientChangeSet> publicAllowValue =
      new PublicAllowValueHolder<>(this);

  /**
   * If the user is not delegated, the phrasse to identify
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private SecretOauthValueHolder<TrustedClientChangeSet> secretOauthValue =
      new SecretOauthValueHolder<>(this);

  /**
   * El identificador de la aplicacion
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private UidValueHolder<TrustedClientChangeSet> uidValue = new UidValueHolder<>(this);

  /**
   * Campo con el número de version de trusted client para controlar bloqueos optimistas
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private VersionValueHolder<TrustedClientChangeSet> versionValue = new VersionValueHolder<>(this);

  /**
   * @autogenerated EntityChangeSetGenerator
   * @return
   */
  public TrustedClientChangeSet newUid() {
    return version(0).uid(Uuid.comb().toString());
  }

  /**
   * Unset a value by the property name. Unset values will no provide command change neither provide
   * information to the output context (hidden or readonly fields, or policy restrictions).
   *
   * @autogenerated EntityChangeSetGenerator
   * @param field The field name to unset.
   */
  public void unset(final String field) {
    uidValue.unsetUidIfMatches(field);
    codeValue.unsetCodeIfMatches(field);
    publicAllowValue.unsetPublicAllowIfMatches(field);
    secretOauthValue.unsetSecretOauthIfMatches(field);
    enabledValue.unsetEnabledIfMatches(field);
    allowedRedirectsValue.unsetAllowedRedirectsIfMatches(field);
    versionValue.unsetVersionIfMatches(field);
  }
}
