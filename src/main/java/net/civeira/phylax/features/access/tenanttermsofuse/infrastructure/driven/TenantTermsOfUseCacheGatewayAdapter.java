package net.civeira.phylax.features.access.tenanttermsofuse.infrastructure.driven;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

import io.quarkus.cache.Cache;
import io.quarkus.cache.CacheName;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.features.access.tenanttermsofuse.TenantTermsOfUse;
import net.civeira.phylax.features.access.tenanttermsofuse.gateway.TenantTermsOfUseCacheGateway;
import net.civeira.phylax.features.access.tenanttermsofuse.gateway.TenantTermsOfUseCached;
import net.civeira.phylax.features.access.tenanttermsofuse.query.TenantTermsOfUseCursor;
import net.civeira.phylax.features.access.tenanttermsofuse.query.TenantTermsOfUseFilter;

@ApplicationScoped
@Slf4j
@RequiredArgsConstructor
public class TenantTermsOfUseCacheGatewayAdapter implements TenantTermsOfUseCacheGateway {

  /**
   * @autogenerated CacheAdaterGatewayGenerator
   */
  @CacheName("tenant-terms-of-use")
  private final Cache cache;

  /**
   * @autogenerated CacheAdaterGatewayGenerator
   */
  @Override
  public void evict() {
    log.trace("Clearing cache after big operation");
    invalidate();
  }

  /**
   * @autogenerated CacheAdaterGatewayGenerator
   * @param tenantTermsOfUse
   */
  @Override
  public void remove(final TenantTermsOfUse tenantTermsOfUse) {
    log.trace("Invalidating tenantTermsOfUse cache due to the removal of {}", tenantTermsOfUse);
    invalidate();
  }

  /**
   * @autogenerated CacheAdaterGatewayGenerator
   * @param filter
   * @param cursor
   * @return
   */
  public Optional<TenantTermsOfUseCached> retrieve(final TenantTermsOfUseFilter filter,
      final TenantTermsOfUseCursor cursor) {
    String key = key(filter, cursor);
    log.trace("Lookup at tenantTermsOfUse cache for the key {}", key);
    return cache.<String, TenantTermsOfUseCached>get(key, k -> null)
        .map(cached -> Optional.ofNullable(cached)).await().indefinitely();
  }

  /**
   * @autogenerated CacheAdaterGatewayGenerator
   * @param filter
   * @param cursor
   * @param tenantTermsOfUses
   * @return
   */
  public TenantTermsOfUseCached store(final TenantTermsOfUseFilter filter,
      final TenantTermsOfUseCursor cursor, final List<TenantTermsOfUse> tenantTermsOfUses) {
    String key = key(filter, cursor);
    cache.invalidate(key).await().indefinitely();
    return cache.<String, TenantTermsOfUseCached>get(key, k -> TenantTermsOfUseCached.builder()
        .since(OffsetDateTime.now()).value(tenantTermsOfUses).build()).await().indefinitely();
  }

  /**
   * @autogenerated CacheAdaterGatewayGenerator
   * @param tenantTermsOfUse
   */
  @Override
  public void update(final TenantTermsOfUse tenantTermsOfUse) {
    log.trace("Invalidating tenantTermsOfUse cache due to the update of {}", tenantTermsOfUse);
    invalidate();
  }

  /**
   * @autogenerated CacheAdaterGatewayGenerator
   */
  private void invalidate() {
    cache.invalidateAll().await().indefinitely();
  }

  /**
   * @autogenerated CacheAdaterGatewayGenerator
   * @param filter
   * @param cursor
   * @return
   */
  private String key(final TenantTermsOfUseFilter filter, final TenantTermsOfUseCursor cursor) {
    return filter.toString() + "-" + cursor.toString();
  }
}
