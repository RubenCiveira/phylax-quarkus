package net.civeira.phylax.features.access.user.domain.valueobject;

import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.value.validation.AbstractFailList;
import net.civeira.phylax.common.value.validation.ConstraintFail;
import net.civeira.phylax.common.value.validation.ConstraintFailList;

/**
 * Value Object representing if the user is not delegated, the phrasse to identify of user.
 */
@RequiredArgsConstructor
@EqualsAndHashCode
public class PasswordVO {

  /**
   * @autogenerated ValueObjectGenerator
   * @param password
   * @return An empty instance
   */
  public static PasswordVO fromCyphered(final String password) {
    return new PasswordVO(true, password, null);
  }

  /**
   * Crear an empty instance with no value
   *
   * @autogenerated ValueObjectGenerator
   * @param password
   * @return An empty instance
   */
  public static PasswordVO fromPlain(final String password) {
    return tryFrom(password);
  }

  /**
   * Crear an empty instance with no value
   *
   * @autogenerated ValueObjectGenerator
   * @param password
   * @return An empty instance
   */
  public static PasswordVO tryFrom(final Object password) {
    ConstraintFailList list = new ConstraintFailList();
    PasswordVO result = tryFrom(password, list);
    if (list.hasErrors()) {
      throw new ConstraintException("Invalid value for PasswordVO.password", list);
    }
    return result;
  }

  /**
   * Crear an empty instance with no value
   *
   * @autogenerated ValueObjectGenerator
   * @param password temptative value
   * @param fails Error list
   * @return An empty instance
   */
  public static <T extends AbstractFailList> PasswordVO tryFrom(final Object password,
      final T fails) {
    if (null == password) {
      fails.add(new ConstraintFail("not-null", "password", null, "Cant be null"));
      return null;
    } else if (password instanceof String castedPassword) {
      return new PasswordVO(false, null, castedPassword);
    } else {
      fails.add(new ConstraintFail("wrong-type", "password", password.getClass(),
          "A String type is expected for password"));
      return null;
    }
  }

  /**
   * @autogenerated ValueObjectGenerator
   */
  private final boolean cyphered;

  /**
   * If the user is not delegated, the phrasse to identify
   *
   * @autogenerated ValueObjectGenerator
   */
  private final String cypheredValue;

  /**
   * @autogenerated ValueObjectGenerator
   */
  private final String plainValue;

  /**
   * Get the vo value
   *
   * @autogenerated ValueObjectGenerator
   * @param cypher
   * @return
   */
  public String getCypheredPassword(final AesCipherService cypher) {
    return cyphered ? cypheredValue : cypher.encryptForAll(plainValue);
  }

  /**
   * Get the vo value
   *
   * @autogenerated ValueObjectGenerator
   * @param cypher
   * @return
   */
  public String getPlainPassword(final AesCipherService cypher) {
    return cyphered ? cypher.decryptForAll(cypheredValue)
        .orElseThrow(() -> new IllegalStateException("Unable to decrypt")) : plainValue;
  }

  /**
   * Returns a formatted string representation of the name (ofuscated if is needed).
   *
   * @autogenerated ValueObjectGenerator
   * @return the string value wrapped in square brackets.
   */
  public String toString() {
    return cyphered ? "[cyphered:" + cypheredValue + "]" : ofuscatePlain();
  }

  /**
   * @autogenerated ValueObjectGenerator
   * @return
   */
  private String ofuscatePlain() {
    return "[plain:" + (plainValue.length() > 10 ? plainValue.substring(0, 5) + "*****" : "*****")
        + "]";
  }
}
