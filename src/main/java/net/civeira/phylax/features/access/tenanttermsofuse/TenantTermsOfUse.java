package net.civeira.phylax.features.access.tenanttermsofuse;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.value.validation.ConstraintFail;
import net.civeira.phylax.common.value.validation.ConstraintFailList;
import net.civeira.phylax.features.access.tenant.TenantRef;
import net.civeira.phylax.features.access.tenanttermsofuse.command.TenantTermsOfUseWriteAttributes;
import net.civeira.phylax.features.access.tenanttermsofuse.event.TenantTermsOfUseCreateEvent;
import net.civeira.phylax.features.access.tenanttermsofuse.event.TenantTermsOfUseDeleteEvent;
import net.civeira.phylax.features.access.tenanttermsofuse.event.TenantTermsOfUseEvent;
import net.civeira.phylax.features.access.tenanttermsofuse.event.TenantTermsOfUseUpdateEvent;
import net.civeira.phylax.features.access.tenanttermsofuse.valueobject.ActivationDateVO;
import net.civeira.phylax.features.access.tenanttermsofuse.valueobject.AttachedVO;
import net.civeira.phylax.features.access.tenanttermsofuse.valueobject.TenantVO;
import net.civeira.phylax.features.access.tenanttermsofuse.valueobject.TextVO;
import net.civeira.phylax.features.access.tenanttermsofuse.valueobject.UidVO;
import net.civeira.phylax.features.access.tenanttermsofuse.valueobject.VersionVO;

@AllArgsConstructor
@Getter
@ToString
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class TenantTermsOfUse implements TenantTermsOfUseRef {

  /**
   * @autogenerated EntityGenerator
   * @param attributes
   * @return
   */
  public static TenantTermsOfUse create(final TenantTermsOfUseWriteAttributes attributes) {
    TenantTermsOfUse instance = new TenantTermsOfUse(attributes, Optional.empty());
    instance.addEvent(TenantTermsOfUseCreateEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public static Set<String> readonlyFields() {
    return Set.of();
  }

  /**
   * Date when the Terms of Use become active.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private ActivationDateVO activationDate = ActivationDateVO.nullValue();

  /**
   * An optional file attachment (e.g., PDF or signed document).
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private AttachedVO attached = AttachedVO.nullValue();

  /**
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private List<TenantTermsOfUseEvent> recordedEvents = List.of();

  /**
   * The tenant this Terms of Use document belongs to.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private TenantVO tenant;

  /**
   * The content of the Terms of Use document.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private TextVO text;

  /**
   * A uid string to identify the entity
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private UidVO uid;

  /**
   * Campo con el n√∫mero de version de tenant terms of use para controlar bloqueos optimistas
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private VersionVO version = VersionVO.nullValue();

  /**
   * @autogenerated EntityGenerator
   * @param attribute
   * @param previous
   */
  private TenantTermsOfUse(final TenantTermsOfUseWriteAttributes attribute,
      final Optional<TenantTermsOfUse> previous) {
    ConstraintFailList list = new ConstraintFailList();
    this.uid = attribute.getUid().orElse(previous.map(TenantTermsOfUse::getUid).orElse(null));
    this.tenant =
        attribute.getTenant().orElse(previous.map(TenantTermsOfUse::getTenant).orElse(null));
    this.text = attribute.getText().orElse(previous.map(TenantTermsOfUse::getText).orElse(null));
    this.attached = attribute.getAttached()
        .orElse(previous.map(TenantTermsOfUse::getAttached).orElseGet(AttachedVO::nullValue));
    this.activationDate = attribute.getActivationDate().orElse(
        previous.map(TenantTermsOfUse::getActivationDate).orElseGet(ActivationDateVO::nullValue));
    this.version = attribute.getVersion()
        .orElse(previous.map(TenantTermsOfUse::getVersion).orElseGet(VersionVO::nullValue));
    if (null == uid) {
      list.add(new ConstraintFail("REQUIRED", "uid", null));
    }
    if (null == tenant) {
      list.add(new ConstraintFail("REQUIRED", "tenant", null));
    }
    if (null == text) {
      list.add(new ConstraintFail("REQUIRED", "text", null));
    }
    if (list.hasErrors()) {
      throw new ConstraintException(list);
    }
    this.recordedEvents = previous.map(TenantTermsOfUse::getRecordedEvents).orElseGet(List::of);
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public TenantTermsOfUse delete() {
    TenantTermsOfUse instance = this;
    instance.addEvent(TenantTermsOfUseDeleteEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<OffsetDateTime> getActivationDateValue() {
    return getActivationDate().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<String> getAttachedValue() {
    return getAttached().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public String getTenantReferenceValue() {
    return getTenant().getReferenceValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public TenantRef getTenantValue() {
    return getTenant().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public String getTextValue() {
    return getText().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  @Override
  public String getUidValue() {
    return this.uid.getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<Integer> getVersionValue() {
    return getVersion().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public TenantTermsOfUse nextVersion() {
    return TenantTermsOfUse.builder().uid(this.uid).tenant(this.tenant).text(this.text)
        .attached(this.attached).activationDate(this.activationDate)
        .version(VersionVO.from(this.version() + 1)).build();
  }

  /**
   * @autogenerated EntityGenerator
   * @param attributes
   * @return
   */
  public TenantTermsOfUse update(final TenantTermsOfUseWriteAttributes attributes) {
    TenantTermsOfUse instance = new TenantTermsOfUse(attributes, Optional.of(this));
    instance.addEvent(TenantTermsOfUseUpdateEvent.builder().payload(instance).build());
    return instance;
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Integer version() {
    return this.getVersion().getValue().orElse(0);
  }

  /**
   * @autogenerated EntityGenerator
   * @param event
   */
  private void addEvent(final TenantTermsOfUseEvent event) {
    List<TenantTermsOfUseEvent> events = new ArrayList<>(this.recordedEvents);
    events.add(event);
    this.recordedEvents = List.copyOf(events);
  }
}
