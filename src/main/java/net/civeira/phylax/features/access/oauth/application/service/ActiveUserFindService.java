/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.service;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.features.access.tenant.domain.Tenant;
import net.civeira.phylax.features.access.tenant.domain.TenantReference;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantFilter;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantReadRepositoryGateway;
import net.civeira.phylax.features.access.user.domain.User;
import net.civeira.phylax.features.access.user.domain.gateway.UserFilter;
import net.civeira.phylax.features.access.user.domain.gateway.UserReadRepositoryGateway;

@Slf4j
@ApplicationScoped
@RequiredArgsConstructor
public class ActiveUserFindService {

  private final TenantReadRepositoryGateway tenants;

  private final UserReadRepositoryGateway users;

  public Optional<Tenant> findEnabledTenant(String tenantName, List<String> audiences) {
    Object[] res = checkTenant(tenantName, audiences);
    if (res.length > 2) {
      return Optional.empty();
    } else {
      return Optional.ofNullable((Tenant) res[1]);
    }
  }

  public Optional<User> findEnabledUserByNameOrEmail(String tenantName, String name,
      List<String> audiences) {
    Object[] res = checkTenant(tenantName, audiences);
    if (res.length > 2) {
      return Optional.empty();
    } else {
      String tenantForData = (String) res[0];
      UserFilter.UserFilterBuilder filter = UserFilter.builder().nameOrEmail(name);
      Tenant tenant = (Tenant) res[1];
      if (!tenant.isRoot()) {
        filter = filter.tenant(TenantReference.of(tenantForData));
      }
      return users.find(filter.build()).filter(this::checkEnabled);
    }
  }

  public Optional<User> findEnabledUser(Tenant tenant, String name) {
    UserFilter.UserFilterBuilder filter = UserFilter.builder().tenant(tenant).name(name);
    return users.find(filter.build()).filter(this::checkEnabled);
  }

  public Optional<User> findEnabledUser(String tenantName, String name, List<String> audiences) {
    Object[] res = checkTenant(tenantName, audiences);
    if (res.length > 2) {
      return Optional.empty();
    } else {
      String tenantForData = (String) res[0];
      UserFilter.UserFilterBuilder filter = UserFilter.builder().name(name);
      Tenant tenant = (Tenant) res[1];
      if (!tenant.isRoot()) {
        filter = filter.tenant(TenantReference.of(tenantForData));
      }
      return users.find(filter.build()).filter(this::checkEnabled);
    }
  }

  public boolean checkEnabled(User user) {
    if (user.isEnabled()) {
      Optional<OffsetDateTime> blockedUntilValue = user.getBlockedUntil();
      if (blockedUntilValue.isPresent() && blockedUntilValue.get().isBefore(OffsetDateTime.now())) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  private Object[] checkTenant(String tenantName, List<String> audiences) {
    String tenantForData = null;
    Tenant tenant = null;
    // el tenant main es siempre master
    tenant = tenants.find(TenantFilter.builder().name(tenantName).build()).orElseThrow(
        () -> new IllegalStateException("The tenant " + tenantName + " is not available"));
    if (!tenant.isEnabled()) {
      log.error("The tenant {} is disabled", tenant);
      return new Object[] {null, tenant, false};
    }
    tenantForData = tenant.getUid();
    return new Object[] {tenantForData, tenant};
  }
}
