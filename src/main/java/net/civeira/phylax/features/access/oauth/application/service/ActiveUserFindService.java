/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.service;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.features.access.tenant.domain.Tenant;
import net.civeira.phylax.features.access.tenant.domain.TenantReference;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantFilter;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantReadRepositoryGateway;
import net.civeira.phylax.features.access.user.domain.User;
import net.civeira.phylax.features.access.user.domain.gateway.UserFilter;
import net.civeira.phylax.features.access.user.domain.gateway.UserReadRepositoryGateway;

@Slf4j
@ApplicationScoped
@RequiredArgsConstructor
public class ActiveUserFindService {

  private final TenantReadRepositoryGateway tenants;

  private final UserReadRepositoryGateway users;

  public Optional<Tenant> findEnabledTenant(String tenantName, List<String> audiences) {
    Object[] res = checkTenant(tenantName, audiences);
    if (res.length > 2) {
      return Optional.empty();
    } else {
      return Optional.ofNullable((Tenant) res[1]);
    }
  }

  public Optional<User> findEnabledUserByNameOrEmail(String tenantName, String name,
      List<String> audiences) {
    Object[] res = checkTenant(tenantName, audiences);
    if (res.length > 2) {
      return Optional.empty();
    } else {
      String tenantForData = (String) res[0];
      UserFilter.UserFilterBuilder filter = UserFilter.builder().nameOrEmail(name);
      if (null == tenantForData) {
        filter = filter.root(true);
      } else {
        filter = filter.tenant(TenantReference.of(tenantForData));
      }
      return users.find(filter.build()).filter(this::checkEnabled);
    }
  }

  public Optional<User> findEnabledUser(String tenantName, String name, List<String> audiences) {
    Object[] res = checkTenant(tenantName, audiences);
    if (res.length > 2) {
      return Optional.empty();
    } else {
      String tenantForData = (String) res[0];

      UserFilter.UserFilterBuilder filter = UserFilter.builder().name(name);
      if (null == tenantForData) {
        filter = filter.root(true);
      } else {
        filter = filter.tenant(TenantReference.of(tenantForData));
      }
      return users.find(filter.build()).filter(this::checkEnabled);
    }
  }

  public boolean checkEnabled(User user) {
    if (user.isEnabled()) {
      Optional<OffsetDateTime> blockedUntilValue = user.getBlockedUntil();
      if (blockedUntilValue.isPresent() && blockedUntilValue.get().isBefore(OffsetDateTime.now())) {
        return false;
      }
      return true;
    } else {
      return false;
    }
  }

  private Object[] checkTenant(String tenantName, List<String> audiences) {
    String tenantForData = null;
    Tenant tenant = null;
    if (!"main".equals(tenantName)) {
      // el tenant main es siempre master
      tenant = tenants.find(TenantFilter.builder().name(tenantName).build()).orElseThrow(
          () -> new IllegalStateException("The tenant " + tenantName + " is not available"));
      if (!tenant.isEnabled()) {
        log.error("The tenant {} is disabled", tenant);
        return new Object[] {null, tenant, false};
      }
      tenantForData = tenant.getUid();
      if (!tenant.isAccessToAllApplications()) {
        List<String> unverified = new ArrayList<>(audiences);
        tenants.resolveRelingParties(tenant.getRelingParties())
            .forEach(rely -> unverified.remove(rely.getCode()));
        tenants.resolveTrustedClients(tenant.getTrustedClients())
            .forEach(client -> unverified.remove(client.getCode()));
        if (!unverified.isEmpty()) {
          log.error("The tenant {} cant access to all the audiences {}", tenant, unverified);
          return new Object[] {null, tenant, false};
        }
      }
    }
    return new Object[] {tenantForData, tenant};
  }
}
