package net.civeira.phylax.features.access.user.application.usecase.list;

import java.time.OffsetDateTime;
import java.util.Optional;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.features.access.tenant.domain.TenantRef;
import net.civeira.phylax.features.access.user.application.visibility.UserVisibleProjection;
import net.civeira.phylax.features.access.user.domain.User;
import net.civeira.phylax.features.access.user.domain.UserApproveOptions;
import net.civeira.phylax.features.access.user.domain.valueobject.ApproveVO;
import net.civeira.phylax.features.access.user.domain.valueobject.BlockedUntilVO;
import net.civeira.phylax.features.access.user.domain.valueobject.EmailVO;
import net.civeira.phylax.features.access.user.domain.valueobject.EnabledVO;
import net.civeira.phylax.features.access.user.domain.valueobject.NameVO;
import net.civeira.phylax.features.access.user.domain.valueobject.PasswordVO;
import net.civeira.phylax.features.access.user.domain.valueobject.ProviderVO;
import net.civeira.phylax.features.access.user.domain.valueobject.SecondFactorSeedVO;
import net.civeira.phylax.features.access.user.domain.valueobject.TemporalPasswordVO;
import net.civeira.phylax.features.access.user.domain.valueobject.TenantVO;
import net.civeira.phylax.features.access.user.domain.valueobject.UidVO;
import net.civeira.phylax.features.access.user.domain.valueobject.UseSecondFactorsVO;
import net.civeira.phylax.features.access.user.domain.valueobject.VersionVO;
import net.civeira.phylax.features.access.user.domain.valueobject.WellcomeAtVO;

/**
 * A dto transfer to hold user attribute values
 */
@NoArgsConstructor(access = AccessLevel.PRIVATE)
@Getter
public class UserListProjection {

  /**
   * Create a dto instance with all the values of an entity
   *
   * @autogenerated ListProjectionGenerator
   * @param visible The entity who provide values.
   * @return
   */
  public static UserListProjection from(final UserVisibleProjection visible) {
    UserListProjection instance = new UserListProjection();
    instance.uidValue = visible.getUid();
    instance.tenantValue = visible.getTenant();
    instance.nameValue = visible.getName();
    instance.passwordValue = visible.getPassword();
    instance.emailValue = visible.getEmail();
    instance.wellcomeAtValue = visible.getWellcomeAt();
    instance.enabledValue = visible.getEnabled();
    instance.approveValue = visible.getApprove();
    instance.temporalPasswordValue = visible.getTemporalPassword();
    instance.useSecondFactorsValue = visible.getUseSecondFactors();
    instance.secondFactorSeedValue = visible.getSecondFactorSeed();
    instance.blockedUntilValue = visible.getBlockedUntil();
    instance.providerValue = visible.getProvider();
    instance.versionValue = visible.getVersion();
    return instance;
  }

  /**
   * El approve de user
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<ApproveVO> approveValue;

  /**
   * A bloqued user cant login on the system, until these date. On his login attempst, hue will
   * recive a generic not allowed message.
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<BlockedUntilVO> blockedUntilValue;

  /**
   * An optional email used to send notifications to the user
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<EmailVO> emailValue;

  /**
   * A disabled user cant login on the system. On his login attempts, he will recive a specific warn
   * of his disabled account.
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<EnabledVO> enabledValue;

  /**
   * The user name to identify on the login screen
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<NameVO> nameValue;

  /**
   * If the user is not delegated, the phrasse to identify
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<PasswordVO> passwordValue;

  /**
   * Si se identificó con un proveedor, se marca con cual (aunque el provvedor cambie luego)
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<ProviderVO> providerValue;

  /**
   * the seed used to the otp login
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<SecondFactorSeedVO> secondFactorSeedValue;

  /**
   * El temporal password de user
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<TemporalPasswordVO> temporalPasswordValue;

  /**
   * El tenant de user
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<TenantVO> tenantValue;

  /**
   * A number to identify the db record
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<UidVO> uidValue;

  /**
   * If is true, the user has a otp to force mfa on login
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<UseSecondFactorsVO> useSecondFactorsValue;

  /**
   * Campo con el número de version de user para controlar bloqueos optimistas
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<VersionVO> versionValue;

  /**
   * The date when a wellcome email is send
   *
   * @autogenerated ListProjectionGenerator
   */
  private Optional<WellcomeAtVO> wellcomeAtValue;

  /**
   * Create a dto instance with all the values of an entity
   *
   * @autogenerated ListProjectionGenerator
   * @param entity The entity who provide values.
   */
  public UserListProjection(final User entity) {
    uidValue = Optional.of(entity.getUidValue());
    tenantValue = Optional.of(entity.getTenantValue());
    nameValue = Optional.of(entity.getNameValue());
    passwordValue = Optional.of(entity.getPasswordValue());
    emailValue = Optional.of(entity.getEmailValue());
    wellcomeAtValue = Optional.of(entity.getWellcomeAtValue());
    enabledValue = Optional.of(entity.getEnabledValue());
    approveValue = Optional.of(entity.getApproveValue());
    temporalPasswordValue = Optional.of(entity.getTemporalPasswordValue());
    useSecondFactorsValue = Optional.of(entity.getUseSecondFactorsValue());
    secondFactorSeedValue = Optional.of(entity.getSecondFactorSeedValue());
    blockedUntilValue = Optional.of(entity.getBlockedUntilValue());
    providerValue = Optional.of(entity.getProviderValue());
    versionValue = Optional.of(entity.getVersionValue());
  }

  /**
   * Inform for a possible change propolsal in Approve
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for Approve, otherwise the value for Approve
   */
  public UserApproveOptions getApprove() {
    return getApproveOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Approve
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Approve, otherwise the value for Approve
   */
  public UserApproveOptions getApproveOrDefault(final UserApproveOptions orDefault) {
    return approveValue.flatMap(ApproveVO::getApprove).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in BlockedUntil
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for BlockedUntil, otherwise the value for
   *         BlockedUntil
   */
  public OffsetDateTime getBlockedUntil() {
    return getBlockedUntilOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in BlockedUntil
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for BlockedUntil, otherwise the value for
   *         BlockedUntil
   */
  public OffsetDateTime getBlockedUntilOrDefault(final OffsetDateTime orDefault) {
    return blockedUntilValue.flatMap(BlockedUntilVO::getBlockedUntil).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Email
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for Email, otherwise the value for Email
   */
  public String getEmail() {
    return getEmailOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Email
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Email, otherwise the value for Email
   */
  public String getEmailOrDefault(final String orDefault) {
    return emailValue.flatMap(EmailVO::getEmail).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Enabled
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for Enabled, otherwise the value for Enabled
   */
  public Boolean getEnabled() {
    return getEnabledOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Enabled
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Enabled, otherwise the value for Enabled
   */
  public Boolean getEnabledOrDefault(final Boolean orDefault) {
    return enabledValue.map(EnabledVO::isEnabled).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Name
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for Name, otherwise the value for Name
   */
  public String getName() {
    return getNameOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Name
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Name, otherwise the value for Name
   */
  public String getNameOrDefault(final String orDefault) {
    return nameValue.map(NameVO::getName).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Password
   *
   * @autogenerated ListProjectionGenerator
   * @param cypher
   * @return empty if there is no change proposal for Password, otherwise the value for Password
   */
  public String getPasswordCyphered(final AesCipherService cypher) {
    return getPasswordCypheredOrDefault(cypher, null);
  }

  /**
   * Inform for a possible change propolsal in Password
   *
   * @autogenerated ListProjectionGenerator
   * @param cypher
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Password, otherwise the value for Password
   */
  public String getPasswordCypheredOrDefault(final AesCipherService cypher,
      final String orDefault) {
    return passwordValue.map(vo -> vo.getPasswordCyphered(cypher)).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Password
   *
   * @autogenerated ListProjectionGenerator
   * @param cypher
   * @return empty if there is no change proposal for Password, otherwise the value for Password
   */
  public String getPasswordPlain(final AesCipherService cypher) {
    return getPasswordPlainOrDefault(cypher, null);
  }

  /**
   * Inform for a possible change propolsal in Password
   *
   * @autogenerated ListProjectionGenerator
   * @param cypher
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Password, otherwise the value for Password
   */
  public String getPasswordPlainOrDefault(final AesCipherService cypher, final String orDefault) {
    return passwordValue.map(vo -> vo.getPasswordPlain(cypher)).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Provider
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for Provider, otherwise the value for Provider
   */
  public String getProvider() {
    return getProviderOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Provider
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Provider, otherwise the value for Provider
   */
  public String getProviderOrDefault(final String orDefault) {
    return providerValue.flatMap(ProviderVO::getProvider).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in SecondFactorSeed
   *
   * @autogenerated ListProjectionGenerator
   * @param cypher
   * @return empty if there is no change proposal for SecondFactorSeed, otherwise the value for
   *         SecondFactorSeed
   */
  public String getSecondFactorSeedCyphered(final AesCipherService cypher) {
    return getSecondFactorSeedCypheredOrDefault(cypher, null);
  }

  /**
   * Inform for a possible change propolsal in SecondFactorSeed
   *
   * @autogenerated ListProjectionGenerator
   * @param cypher
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for SecondFactorSeed, otherwise the value for
   *         SecondFactorSeed
   */
  public String getSecondFactorSeedCypheredOrDefault(final AesCipherService cypher,
      final String orDefault) {
    return secondFactorSeedValue.flatMap(vo -> vo.getSecondFactorSeedCyphered(cypher))
        .orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in SecondFactorSeed
   *
   * @autogenerated ListProjectionGenerator
   * @param cypher
   * @return empty if there is no change proposal for SecondFactorSeed, otherwise the value for
   *         SecondFactorSeed
   */
  public String getSecondFactorSeedPlain(final AesCipherService cypher) {
    return getSecondFactorSeedPlainOrDefault(cypher, null);
  }

  /**
   * Inform for a possible change propolsal in SecondFactorSeed
   *
   * @autogenerated ListProjectionGenerator
   * @param cypher
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for SecondFactorSeed, otherwise the value for
   *         SecondFactorSeed
   */
  public String getSecondFactorSeedPlainOrDefault(final AesCipherService cypher,
      final String orDefault) {
    return secondFactorSeedValue.flatMap(vo -> vo.getSecondFactorSeedPlain(cypher))
        .orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in TemporalPassword
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for TemporalPassword, otherwise the value for
   *         TemporalPassword
   */
  public Boolean getTemporalPassword() {
    return getTemporalPasswordOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in TemporalPassword
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for TemporalPassword, otherwise the value for
   *         TemporalPassword
   */
  public Boolean getTemporalPasswordOrDefault(final Boolean orDefault) {
    return temporalPasswordValue.map(TemporalPasswordVO::isTemporalPassword).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Tenant
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for Tenant, otherwise the value for Tenant
   */
  public TenantRef getTenant() {
    return tenantValue.map(TenantVO::getTenant).orElse(null);
  }

  /**
   * Inform for a possible change propolsal in Tenant
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for Tenant, otherwise the value for Tenant
   */
  public String getTenantReference() {
    return getTenantReferenceOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Tenant
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault
   * @return empty if there is no change proposal for Tenant, otherwise the value for Tenant
   */
  public String getTenantReferenceOrDefault(final String orDefault) {
    return tenantValue.map(TenantVO::getTenant).map(TenantRef::getUid).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Uid
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for Uid, otherwise the value for Uid
   */
  public String getUid() {
    return getUidOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Uid
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Uid, otherwise the value for Uid
   */
  public String getUidOrDefault(final String orDefault) {
    return uidValue.map(UidVO::getUid).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in UseSecondFactors
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for UseSecondFactors, otherwise the value for
   *         UseSecondFactors
   */
  public Boolean getUseSecondFactors() {
    return getUseSecondFactorsOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in UseSecondFactors
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for UseSecondFactors, otherwise the value for
   *         UseSecondFactors
   */
  public Boolean getUseSecondFactorsOrDefault(final Boolean orDefault) {
    return useSecondFactorsValue.map(UseSecondFactorsVO::isUseSecondFactors).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Version
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for Version, otherwise the value for Version
   */
  public Integer getVersion() {
    return getVersionOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Version
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Version, otherwise the value for Version
   */
  public Integer getVersionOrDefault(final Integer orDefault) {
    return versionValue.flatMap(VersionVO::getVersion).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in WellcomeAt
   *
   * @autogenerated ListProjectionGenerator
   * @return empty if there is no change proposal for WellcomeAt, otherwise the value for WellcomeAt
   */
  public OffsetDateTime getWellcomeAt() {
    return getWellcomeAtOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in WellcomeAt
   *
   * @autogenerated ListProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for WellcomeAt, otherwise the value for WellcomeAt
   */
  public OffsetDateTime getWellcomeAtOrDefault(final OffsetDateTime orDefault) {
    return wellcomeAtValue.flatMap(WellcomeAtVO::getWellcomeAt).orElse(orDefault);
  }
}
