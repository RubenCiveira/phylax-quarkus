package net.civeira.phylax.features.access.securityscope.infrastructure.repository;

import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Predicate;

import javax.sql.DataSource;

import io.opentelemetry.api.trace.Tracer;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.algorithms.Slider;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.exception.NotFoundException;
import net.civeira.phylax.common.infrastructure.sql.OptimistLockException;
import net.civeira.phylax.common.infrastructure.sql.SqlCommand;
import net.civeira.phylax.common.infrastructure.sql.SqlConverter;
import net.civeira.phylax.common.infrastructure.sql.SqlListParameterValue;
import net.civeira.phylax.common.infrastructure.sql.SqlOperator;
import net.civeira.phylax.common.infrastructure.sql.SqlParameterValue;
import net.civeira.phylax.common.infrastructure.sql.SqlQuery;
import net.civeira.phylax.common.infrastructure.sql.SqlResult;
import net.civeira.phylax.common.infrastructure.sql.SqlSchematicQuery;
import net.civeira.phylax.common.infrastructure.sql.SqlTemplate;
import net.civeira.phylax.features.access.securityscope.SecurityScope;
import net.civeira.phylax.features.access.securityscope.SecurityScopeKindOptions;
import net.civeira.phylax.features.access.securityscope.SecurityScopeRef;
import net.civeira.phylax.features.access.securityscope.SecurityScopeVisibilityOptions;
import net.civeira.phylax.features.access.securityscope.query.SecurityScopeCursor;
import net.civeira.phylax.features.access.securityscope.query.SecurityScopeFilter;
import net.civeira.phylax.features.access.securityscope.valueobject.EnabledVO;
import net.civeira.phylax.features.access.securityscope.valueobject.KindVO;
import net.civeira.phylax.features.access.securityscope.valueobject.RelyingPartyVO;
import net.civeira.phylax.features.access.securityscope.valueobject.ResourceVO;
import net.civeira.phylax.features.access.securityscope.valueobject.ScopeVO;
import net.civeira.phylax.features.access.securityscope.valueobject.TrustedClientVO;
import net.civeira.phylax.features.access.securityscope.valueobject.UidVO;
import net.civeira.phylax.features.access.securityscope.valueobject.VersionVO;
import net.civeira.phylax.features.access.securityscope.valueobject.VisibilityVO;

@ApplicationScoped
@RequiredArgsConstructor
@Slf4j
public class SecurityScopeRepository {

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ENABLED = "enabled";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String KIND = "kind";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String RELYING_PARTY = "relyingParty";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String RELYING_PARTY_SNAKE = "relying_party";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String RESOURCE = "resource";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SCOPE = "scope";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SECURITY_SCOPE_ENABLED = "security_scope.enabled";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SECURITY_SCOPE_KIND = "security_scope.kind";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SECURITY_SCOPE_RELYING_PARTY = "security_scope.relying_party";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SECURITY_SCOPE_RESOURCE = "security_scope.resource";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SECURITY_SCOPE_SCOPE = "security_scope.scope";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SECURITY_SCOPE_SNAKE = "security_scope";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SECURITY_SCOPE_TRUSTED_CLIENT = "security_scope.trusted_client";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SECURITY_SCOPE_UID = "security_scope.uid";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SECURITY_SCOPE_VERSION = "security_scope.version";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SECURITY_SCOPE_VISIBILITY = "security_scope.visibility";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TRUSTED_CLIENT = "trustedClient";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TRUSTED_CLIENT_SNAKE = "trusted_client";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String UID = "uid";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String VERSION = "version";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String VISIBILITY = "visibility";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final DataSource datasource;

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final Tracer tracer;

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public long count(SecurityScopeFilter filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<Long> sq = filteredQuery(template, filter);
      sq.select("count(uid) as uid");
      return sq.query(row -> Optional.of(row.getLong(1))).one().orElse(0l);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public SecurityScope create(SecurityScope entity) {
    return runCreate(entity, null);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  public SecurityScope create(SecurityScope entity, Predicate<SecurityScope> verifier) {
    return runCreate(entity, verifier);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   */
  public void delete(SecurityScope entity) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlCommand sq =
          template.createSqlCommand("delete from \"security_scope\" where \"uid\" = :uid");
      sq.with(UID, SqlParameterValue.of(entity.getUidValue()));
      int num = sq.execute();
      if (0 == num) {
        throw new IllegalArgumentException("No delete from");
      }
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param reference
   * @return
   */
  public SecurityScope enrich(SecurityScopeRef reference) {
    return reference instanceof SecurityScope securityScope ? securityScope
        : retrieve(reference.getUidValue(), Optional.empty())
            .orElseThrow(() -> new NotFoundException(
                "Trying to enrich inexistent SecurityScope: " + reference.getUidValue()));
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param reference
   * @return
   */
  public SecurityScope enrichForUpdate(SecurityScopeRef reference) {
    return reference instanceof SecurityScope securityScope ? securityScope
        : retrieveForUpdate(reference.getUidValue(), Optional.empty())
            .orElseThrow(() -> new NotFoundException(
                "Trying to enrich inexistent SecurityScope: " + reference.getUidValue()));
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public boolean exists(String uid, Optional<SecurityScopeFilter> filter) {
    return retrieve(uid, filter).isPresent();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public boolean existsForUpdate(String uid, Optional<SecurityScopeFilter> filter) {
    return retrieveForUpdate(uid, filter).isPresent();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public Optional<SecurityScope> find(SecurityScopeFilter filter) {
    SecurityScopeCursor cursor = SecurityScopeCursor.builder().build();
    return new SecurityScopeSlider(runList(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor).one();
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public Optional<SecurityScope> find(final String sql,
      final Map<String, SqlParameterValue> params) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<SecurityScope> createSqlQuery = template.createSqlQuery(sql);
      params.forEach(createSqlQuery::with);
      return createSqlQuery.query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public Optional<SecurityScope> findForUpdate(SecurityScopeFilter filter) {
    SecurityScopeCursor cursor = SecurityScopeCursor.builder().build();
    return new SecurityScopeSlider(runListForUpdate(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor).one();
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public Optional<SecurityScope> findForUpdate(final String sql,
      final Map<String, SqlParameterValue> params) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<SecurityScope> createSqlQuery = template.createSqlQuery(sql);
      params.forEach(createSqlQuery::with);
      return createSqlQuery.forUpdate().query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public List<SecurityScope> list(SecurityScopeFilter filter) {
    SecurityScopeCursor cursor = SecurityScopeCursor.builder().build();
    return new SecurityScopeSlider(runList(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor).all();
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<SecurityScope> list(final String sql, final Map<String, SqlParameterValue> params) {
    return list(sql, params, null, false);
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<SecurityScope> list(final String sql, final Map<String, SqlParameterValue> params,
      final int limit) {
    return list(sql, params, Integer.valueOf(limit), false);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public List<SecurityScope> listForUpdate(SecurityScopeFilter filter) {
    SecurityScopeCursor cursor = SecurityScopeCursor.builder().build();
    return new SecurityScopeSlider(runListForUpdate(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor).all();
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<SecurityScope> listForUpdate(final String sql,
      final Map<String, SqlParameterValue> params) {
    return list(sql, params, null, true);
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<SecurityScope> listForUpdate(final String sql,
      final Map<String, SqlParameterValue> params, final int limit) {
    return list(sql, params, Integer.valueOf(limit), true);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public Optional<SecurityScope> retrieve(String uid, Optional<SecurityScopeFilter> filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SecurityScopeFilter readyFilter = filter.map(val -> val.withUid(uid))
          .orElseGet(() -> SecurityScopeFilter.builder().uid(uid).build());
      SqlSchematicQuery<SecurityScope> sq = filteredQuery(template, readyFilter);
      return sq.query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public Optional<SecurityScope> retrieveForUpdate(String uid,
      Optional<SecurityScopeFilter> filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SecurityScopeFilter readyFilter = filter.map(val -> val.withUid(uid))
          .orElseGet(() -> SecurityScopeFilter.builder().uid(uid).build());
      SqlSchematicQuery<SecurityScope> sq = filteredQuery(template, readyFilter);
      return sq.forUpdate().query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  public Slider<SecurityScope> slide(SecurityScopeFilter filter, SecurityScopeCursor cursor) {
    return new SecurityScopeSlider(runList(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  public Slider<SecurityScope> slideForUpdate(SecurityScopeFilter filter,
      SecurityScopeCursor cursor) {
    return new SecurityScopeSlider(runListForUpdate(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public SecurityScope update(SecurityScope entity) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlCommand sq = template.createSqlCommand(
          "update \"security_scope\" set  \"trusted_client\" = :trustedClient, \"relying_party\" = :relyingParty, \"resource\" = :resource, \"scope\" = :scope, \"enabled\" = :enabled, \"kind\" = :kind, \"visibility\" = :visibility, \"version\" = \"version\" + 1 where \"uid\" = :uid and \"version\" = :version");
      sq.with(UID, SqlParameterValue.of(entity.getUid().getValue()));
      sq.with(TRUSTED_CLIENT, entity.getTrustedClient().getReferenceValue()
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullString));
      sq.with(RELYING_PARTY, entity.getRelyingParty().getReferenceValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(RESOURCE, SqlParameterValue.of(entity.getResource().getValue()));
      sq.with(SCOPE, SqlParameterValue.of(entity.getScope().getValue()));
      sq.with(ENABLED, entity.getEnabled().getValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullBoolean));
      sq.with(KIND, entity.getKind().getValue().map(SecurityScopeKindOptions::toString)
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullString));
      sq.with(VISIBILITY,
          entity.getVisibility().getValue().map(SecurityScopeVisibilityOptions::toString)
              .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullString));
      sq.with(VERSION, entity.getVersion().getValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      int num = sq.execute();
      if (0 == num) {
        throw new OptimistLockException("No delete from");
      }
      return entity.nextVersion();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @return
   */
  private SqlConverter<SecurityScope> converter() {
    return row -> {
      try {
        return Optional.of(SecurityScope.builder().uid(UidVO.from(row.getString(UID)))
            .trustedClient(TrustedClientVO.fromReference(row.getString(TRUSTED_CLIENT_SNAKE)))
            .relyingParty(RelyingPartyVO.fromReference(row.getString(RELYING_PARTY_SNAKE)))
            .resource(ResourceVO.from(row.getString(RESOURCE)))
            .scope(ScopeVO.from(row.getString(SCOPE)))
            .enabled(EnabledVO.from(row.getBoolean(ENABLED)))
            .kind(KindVO.tryFrom(row.getString(KIND)))
            .visibility(VisibilityVO.tryFrom(row.getString(VISIBILITY)))
            .version(VersionVO.from(row.getInt(VERSION))).build());
      } catch (ConstraintException ce) {
        log.error("Unable to map data for {}", row.getString(1), ce);
        return Optional.empty();
      }
    };
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param template
   * @param filter
   * @return
   */
  private <T> SqlSchematicQuery<T> filteredQuery(SqlTemplate template, SecurityScopeFilter filter) {
    SqlSchematicQuery<T> sq = template.createSqlSchematicQuery(SECURITY_SCOPE_SNAKE);
    sq.selectFields(SECURITY_SCOPE_UID, SECURITY_SCOPE_TRUSTED_CLIENT, SECURITY_SCOPE_RELYING_PARTY,
        SECURITY_SCOPE_RESOURCE, SECURITY_SCOPE_SCOPE, SECURITY_SCOPE_ENABLED, SECURITY_SCOPE_KIND,
        SECURITY_SCOPE_VISIBILITY, SECURITY_SCOPE_VERSION);
    filter.getUid().ifPresent(uid -> sq.where(UID, SqlOperator.EQ, SqlParameterValue.of(uid)));
    if (!filter.getUids().isEmpty()) {
      sq.where(UID, SqlOperator.IN, SqlListParameterValue.strings(filter.getUids()));
    }
    filter.getSearch().ifPresent(
        search -> sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%")));
    filter.getResource()
        .ifPresent(resource -> sq.where(RESOURCE, SqlOperator.EQ, SqlParameterValue.of(resource)));
    filter.getTrustedClient().ifPresent(trustedClient -> sq.where(TRUSTED_CLIENT_SNAKE,
        SqlOperator.EQ, SqlParameterValue.of(trustedClient.getUidValue())));
    if (!filter.getTrustedClients().isEmpty()) {
      sq.where(TRUSTED_CLIENT_SNAKE, SqlOperator.IN,
          SqlListParameterValue.strings(filter.getTrustedClients()));
    }
    filter.getRelyingParty().ifPresent(relyingParty -> sq.where(RELYING_PARTY_SNAKE, SqlOperator.EQ,
        SqlParameterValue.of(relyingParty.getUidValue())));
    if (!filter.getRelyingPartys().isEmpty()) {
      sq.where(RELYING_PARTY_SNAKE, SqlOperator.IN,
          SqlListParameterValue.strings(filter.getRelyingPartys()));
    }
    return sq;
  }

  /**
   * sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @param forUpdate
   * @return sq.where("uid", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  private List<SecurityScope> list(final String sql, final Map<String, SqlParameterValue> params,
      final Integer limit, final boolean forUpdate) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<SecurityScope> createSqlQuery = template.createSqlQuery(sql);
      params.forEach(createSqlQuery::with);
      if (forUpdate) {
        createSqlQuery = createSqlQuery.forUpdate();
      }
      SqlResult<SecurityScope> query = createSqlQuery.query(converter());
      return null == limit ? query.all() : query.limit(limit);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  private SecurityScope runCreate(SecurityScope entity, Predicate<SecurityScope> verifier) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlCommand sq = template.createSqlCommand(
          "insert into \"security_scope\" ( \"uid\", \"trusted_client\", \"relying_party\", \"resource\", \"scope\", \"enabled\", \"kind\", \"visibility\", \"version\") values ( :uid, :trustedClient, :relyingParty, :resource, :scope, :enabled, :kind, :visibility, :version)");
      sq.with(UID, SqlParameterValue.of(entity.getUid().getValue()));
      sq.with(TRUSTED_CLIENT, entity.getTrustedClient().getReferenceValue()
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullString));
      sq.with(RELYING_PARTY, entity.getRelyingParty().getReferenceValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(RESOURCE, SqlParameterValue.of(entity.getResource().getValue()));
      sq.with(SCOPE, SqlParameterValue.of(entity.getScope().getValue()));
      sq.with(ENABLED, entity.getEnabled().getValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullBoolean));
      sq.with(KIND, entity.getKind().getValue().map(SecurityScopeKindOptions::toString)
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullString));
      sq.with(VISIBILITY,
          entity.getVisibility().getValue().map(SecurityScopeVisibilityOptions::toString)
              .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullString));
      sq.with(VERSION, entity.getVersion().getValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      int num = sq.execute();
      if (0 == num) {
        throw new IllegalArgumentException("No insert into");
      }
      return verifier == null ? entity : verified(verifier.test(entity), entity, template);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  private Iterator<SecurityScope> runList(SecurityScopeFilter filter, SecurityScopeCursor cursor) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<SecurityScope> sq = filteredQuery(template, filter);
      cursor.getSinceUid()
          .ifPresent(since -> sq.where(UID, SqlOperator.GT, SqlParameterValue.of(since)));
      sq.orderAsc("uid");
      return sq.query(converter()).limit(cursor.getLimit()).iterator();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  private Iterator<SecurityScope> runListForUpdate(SecurityScopeFilter filter,
      SecurityScopeCursor cursor) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<SecurityScope> sq = filteredQuery(template, filter);
      cursor.getSinceUid()
          .ifPresent(since -> sq.where(UID, SqlOperator.GT, SqlParameterValue.of(since)));
      sq.orderAsc("uid");
      return sq.forUpdate().query(converter()).limit(cursor.getLimit()).iterator();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param exists
   * @param entity
   * @param template
   * @return
   */
  private SecurityScope verified(boolean exists, SecurityScope entity, SqlTemplate template) {
    if (exists) {
      return entity;
    } else {
      template.createSqlCommand("delete from \"security_scope\" where \"uid\" = :uid")
          .with("uid", SqlParameterValue.of(entity.getUidValue())).execute();
      throw new NotFoundException("");
    }
  }
}
