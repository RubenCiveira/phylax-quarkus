/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.usecase;

import java.time.Duration;
import java.time.OffsetDateTime;
import java.time.temporal.TemporalAmount;
import java.util.Optional;

import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.features.access.oauth.application.service.ActiveUserFindService;
import net.civeira.phylax.features.access.oauth.application.service.SecureCodeGenerator;
import net.civeira.phylax.features.access.user.UserFacade;
import net.civeira.phylax.features.access.user.gateway.UserWriteRepositoryGateway;
import net.civeira.phylax.features.access.useraccesstemporalcode.UserAccessTemporalCode;
import net.civeira.phylax.features.access.useraccesstemporalcode.UserAccessTemporalCodeFacade;
import net.civeira.phylax.features.access.useraccesstemporalcode.command.UserAccessTemporalCodeChangeProposal;
import net.civeira.phylax.features.access.useraccesstemporalcode.gateway.UserAccessTemporalCodeWriteRepositoryGateway;
import net.civeira.phylax.features.access.useraccesstemporalcode.query.UserAccessTemporalCodeFilter;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthRequest;

@ApplicationScoped
@RequiredArgsConstructor
public class PasswordRecoverUsecase {
  private final static TemporalAmount RECOVER_TIME = Duration.ofHours(12);

  private final ActiveUserFindService activeUser;
  private final UserFacade userFacade;
  private final UserWriteRepositoryGateway users;
  private final UserAccessTemporalCodeFacade codesFacade;
  private final UserAccessTemporalCodeWriteRepositoryGateway codes;

  public boolean checkRecoverCode(AuthRequest request, String email, String code,
      String newPassoword) {
    return activeUser
        .findEnabledUserByNameOrEmail(request.getTenant(), email, request.getAudiences())
        .map(user -> {
          if (user.getProviderValue().isPresent()) {
            return false;
          }
          Optional<UserAccessTemporalCode> find =
              codes.findForUpdate(UserAccessTemporalCodeFilter.builder().user(user).build());
          if (!find.isPresent()) {
            return false;
          }
          UserAccessTemporalCode tempCode = find.get();
          if (!"".equals(code) && code.equals(tempCode.getRecoveryCodeValue().orElse(""))) {
            codes.update(tempCode, codesFacade.resetPasswordRecover(tempCode));
            // codes.update(tempCode, tempCode.withNullRecoveryCode());
            users.update(user, userFacade.changePassword(user, newPassoword));
            // users.update(user, user.withPlainPassword(newPassoword));
            return true;
          } else {
            return false;
          }
        }).orElse(false);
  }

  public void recover(AuthRequest request, String email, String urlWithParams) {
    activeUser.findEnabledUserByNameOrEmail(request.getTenant(), email, request.getAudiences())
        .ifPresent(user -> {
          if (user.getProviderValue().isPresent()) {
            return;
          }
          String code = SecureCodeGenerator.generate();
          Optional<UserAccessTemporalCode> find =
              codes.findForUpdate(UserAccessTemporalCodeFilter.builder().user(user).build());
          UserAccessTemporalCode userCode;
          if (find.isPresent()) {
            userCode = find.get();
          } else {
            userCode = codes.create(codesFacade
                .create(UserAccessTemporalCodeChangeProposal.builder().newUid().build()));
          }
          // if (find.isPresent()) {
          // UserAccessTemporalCode userCode = find.get();
          // codes.update(userCode, userCode.toBuilder().recoveryCode(code)
          // .recoveryCodeExpiration(OffsetDateTime.now().plus(RECOVER_TIME)).build());
          // } else {
          // codes.create(UserAccessTemporalCode.builder().newUid().user(user).recoveryCode(code)
          // .recoveryCodeExpiration(OffsetDateTime.now().plus(RECOVER_TIME)).build());
          // }
          codes.update(userCode, codesFacade.generatePasswordRecover(userCode, code,
              OffsetDateTime.now().plus(RECOVER_TIME)));
          // users.update(user, user.toBuilder().build());
        });
  }
}
