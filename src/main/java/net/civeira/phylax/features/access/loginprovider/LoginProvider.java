package net.civeira.phylax.features.access.loginprovider;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.value.validation.ConstraintFail;
import net.civeira.phylax.common.value.validation.ConstraintFailList;
import net.civeira.phylax.features.access.loginprovider.command.LoginProviderWriteAttributes;
import net.civeira.phylax.features.access.loginprovider.event.LoginProviderCreateEvent;
import net.civeira.phylax.features.access.loginprovider.event.LoginProviderDeleteEvent;
import net.civeira.phylax.features.access.loginprovider.event.LoginProviderDisableEvent;
import net.civeira.phylax.features.access.loginprovider.event.LoginProviderEnableEvent;
import net.civeira.phylax.features.access.loginprovider.event.LoginProviderEvent;
import net.civeira.phylax.features.access.loginprovider.event.LoginProviderUpdateEvent;
import net.civeira.phylax.features.access.loginprovider.transition.create.LoginProviderCreatePipeline;
import net.civeira.phylax.features.access.loginprovider.transition.delete.LoginProviderDeletePipeline;
import net.civeira.phylax.features.access.loginprovider.transition.disable.LoginProviderDisablePipeline;
import net.civeira.phylax.features.access.loginprovider.transition.enable.LoginProviderEnablePipeline;
import net.civeira.phylax.features.access.loginprovider.transition.update.LoginProviderUpdatePipeline;
import net.civeira.phylax.features.access.loginprovider.valueobject.CertificateVO;
import net.civeira.phylax.features.access.loginprovider.valueobject.DirectAccessVO;
import net.civeira.phylax.features.access.loginprovider.valueobject.DisabledVO;
import net.civeira.phylax.features.access.loginprovider.valueobject.MetadataVO;
import net.civeira.phylax.features.access.loginprovider.valueobject.NameVO;
import net.civeira.phylax.features.access.loginprovider.valueobject.PrivateKeyVO;
import net.civeira.phylax.features.access.loginprovider.valueobject.PublicKeyVO;
import net.civeira.phylax.features.access.loginprovider.valueobject.SourceVO;
import net.civeira.phylax.features.access.loginprovider.valueobject.TenantVO;
import net.civeira.phylax.features.access.loginprovider.valueobject.UidVO;
import net.civeira.phylax.features.access.loginprovider.valueobject.UsersEnabledByDefaultVO;
import net.civeira.phylax.features.access.loginprovider.valueobject.VersionVO;
import net.civeira.phylax.features.access.tenant.TenantRef;

@AllArgsConstructor
@Getter
@ToString
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class LoginProvider implements LoginProviderRef {

  /**
   * @autogenerated EntityGenerator
   * @param attributes
   * @param pipeline
   * @return
   */
  public static LoginProvider create(final LoginProviderWriteAttributes attributes,
      final LoginProviderCreatePipeline pipeline) {
    return pipeline.create(attributes, attr -> {
      LoginProvider instance = new LoginProvider(attr, Optional.empty());
      instance.addEvent(LoginProviderCreateEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * The provider certificate used for signature verification, if required.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private CertificateVO certificate = CertificateVO.nullValue();

  /**
   * If true, the system will default to this login method without requiring selection.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private DirectAccessVO directAccess = DirectAccessVO.nullValue();

  /**
   * Indicates if this provider is currently disabled.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private DisabledVO disabled = DisabledVO.nullValue();

  /**
   * A metadata file required by some providers for configuration (e.g., SAML descriptor).
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private MetadataVO metadata = MetadataVO.nullValue();

  /**
   * A name that identifies this login provider within the tenant.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private NameVO name;

  /**
   * Private key used internally to validate codes returned by the identity provider.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private PrivateKeyVO privateKey = PrivateKeyVO.nullValue();

  /**
   * A public key shared with users to interact with the identity provider.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private PublicKeyVO publicKey = PublicKeyVO.nullValue();

  /**
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private List<LoginProviderEvent> recordedEvents = List.of();

  /**
   * The source protocol or system used for authentication (e.g., GOOGLE, GITHUB, SAML).
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private SourceVO source;

  /**
   * The tenant this login provider is configured for.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private TenantVO tenant;

  /**
   * A uid string to identify the entity
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private UidVO uid;

  /**
   * Defines whether the users created with this provider are enabled by default.
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private UsersEnabledByDefaultVO usersEnabledByDefault;

  /**
   * Campo con el n√∫mero de version de login provider para controlar bloqueos optimistas
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private VersionVO version = VersionVO.nullValue();

  /**
   * @autogenerated EntityGenerator
   * @param attribute
   * @param previous
   */
  private LoginProvider(final LoginProviderWriteAttributes attribute,
      final Optional<LoginProvider> previous) {
    ConstraintFailList list = new ConstraintFailList();
    this.uid = attribute.getUid().orElse(previous.map(LoginProvider::getUid).orElse(null));
    this.tenant = attribute.getTenant().orElse(previous.map(LoginProvider::getTenant).orElse(null));
    this.name = attribute.getName().orElse(previous.map(LoginProvider::getName).orElse(null));
    this.source = attribute.getSource().orElse(previous.map(LoginProvider::getSource).orElse(null));
    this.disabled = attribute.getDisabled()
        .orElse(previous.map(LoginProvider::getDisabled).orElseGet(DisabledVO::nullValue));
    this.directAccess = attribute.getDirectAccess()
        .orElse(previous.map(LoginProvider::getDirectAccess).orElseGet(DirectAccessVO::nullValue));
    this.publicKey = attribute.getPublicKey()
        .orElse(previous.map(LoginProvider::getPublicKey).orElseGet(PublicKeyVO::nullValue));
    this.privateKey = attribute.getPrivateKey()
        .orElse(previous.map(LoginProvider::getPrivateKey).orElseGet(PrivateKeyVO::nullValue));
    this.certificate = attribute.getCertificate()
        .orElse(previous.map(LoginProvider::getCertificate).orElseGet(CertificateVO::nullValue));
    this.metadata = attribute.getMetadata()
        .orElse(previous.map(LoginProvider::getMetadata).orElseGet(MetadataVO::nullValue));
    this.usersEnabledByDefault = attribute.getUsersEnabledByDefault()
        .orElse(previous.map(LoginProvider::getUsersEnabledByDefault).orElse(null));
    this.version = attribute.getVersion()
        .orElse(previous.map(LoginProvider::getVersion).orElseGet(VersionVO::nullValue));
    if (null == uid) {
      list.add(new ConstraintFail("REQUIRED", "uid", null));
    }
    if (null == tenant) {
      list.add(new ConstraintFail("REQUIRED", "tenant", null));
    }
    if (null == name) {
      list.add(new ConstraintFail("REQUIRED", "name", null));
    }
    if (null == source) {
      list.add(new ConstraintFail("REQUIRED", "source", null));
    }
    if (null == usersEnabledByDefault) {
      list.add(new ConstraintFail("REQUIRED", "usersEnabledByDefault", null));
    }
    if (list.hasErrors()) {
      throw new ConstraintException(list);
    }
    this.recordedEvents = previous.map(LoginProvider::getRecordedEvents).orElseGet(List::of);
  }

  /**
   * @autogenerated EntityGenerator
   * @param pipeline
   * @return
   */
  public LoginProvider delete(final LoginProviderDeletePipeline pipeline) {
    return pipeline.delete(this, () -> {
      LoginProvider instance = this;
      instance.addEvent(LoginProviderDeleteEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @param pipeline
   * @return
   */
  public LoginProvider disable(final LoginProviderDisablePipeline pipeline) {
    return pipeline.disable(this, attr -> {
      attr.setDisabled(true);
      LoginProvider instance = new LoginProvider(attr, Optional.of(this));
      instance.addEvent(LoginProviderDisableEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @param pipeline
   * @return
   */
  public LoginProvider enable(final LoginProviderEnablePipeline pipeline) {
    return pipeline.enable(this, attr -> {
      attr.setDisabled(false);
      LoginProvider instance = new LoginProvider(attr, Optional.of(this));
      instance.addEvent(LoginProviderEnableEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<String> getCertificateValue() {
    return getCertificate().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<String> getMetadataValue() {
    return getMetadata().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public String getNameValue() {
    return getName().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<String> getPrivateKeyValue() {
    return getPrivateKey().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<String> getPublicKeyValue() {
    return getPublicKey().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public LoginProviderSourceOptions getSourceValue() {
    return getSource().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public String getTenantReferenceValue() {
    return getTenant().getReferenceValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public TenantRef getTenantValue() {
    return getTenant().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  @Override
  public String getUidValue() {
    return this.uid.getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<Integer> getVersionValue() {
    return getVersion().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public boolean isDirectAccess() {
    return Boolean.TRUE.equals(getDirectAccess().getValue().orElse(Boolean.FALSE));
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public boolean isDisabled() {
    return Boolean.TRUE.equals(getDisabled().getValue().orElse(Boolean.FALSE));
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public boolean isUsersEnabledByDefault() {
    return Boolean.TRUE.equals(getUsersEnabledByDefault().getValue());
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public LoginProvider nextVersion() {
    return LoginProvider.builder().uid(this.uid).tenant(this.tenant).name(this.name)
        .source(this.source).disabled(this.disabled).directAccess(this.directAccess)
        .publicKey(this.publicKey).privateKey(this.privateKey).certificate(this.certificate)
        .metadata(this.metadata).usersEnabledByDefault(this.usersEnabledByDefault)
        .version(VersionVO.from(this.version() + 1)).build();
  }

  /**
   * @autogenerated EntityGenerator
   * @param attributes
   * @param pipeline
   * @return
   */
  public LoginProvider update(final LoginProviderWriteAttributes attributes,
      final LoginProviderUpdatePipeline pipeline) {
    return pipeline.update(attributes, this, attr -> {
      LoginProvider instance = new LoginProvider(attr, Optional.of(this));
      instance.addEvent(LoginProviderUpdateEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Integer version() {
    return this.getVersion().getValue().orElse(0);
  }

  /**
   * @autogenerated EntityGenerator
   * @param event
   */
  private void addEvent(final LoginProviderEvent event) {
    List<LoginProviderEvent> events = new ArrayList<>(this.recordedEvents);
    events.add(event);
    this.recordedEvents = List.copyOf(events);
  }
}
