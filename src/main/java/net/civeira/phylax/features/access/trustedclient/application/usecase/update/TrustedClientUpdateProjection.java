package net.civeira.phylax.features.access.trustedclient.application.usecase.update;

import java.util.Optional;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NoArgsConstructor;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.features.access.trustedclient.application.visibility.TrustedClientVisibleProjection;
import net.civeira.phylax.features.access.trustedclient.domain.TrustedClient;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.AllowedRedirectsVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.CodeVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.EnabledVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.PublicAllowVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.SecretOauthVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.UidVO;
import net.civeira.phylax.features.access.trustedclient.domain.valueobject.VersionVO;

/**
 * A dto transfer to hold trusted client attribute values
 */
@NoArgsConstructor(access = AccessLevel.PRIVATE)
@Getter
public class TrustedClientUpdateProjection {

  /**
   * Create a dto instance with all the values of an entity
   *
   * @autogenerated UpdateProjectionGenerator
   * @param visible The entity who provide values.
   * @return
   */
  public static TrustedClientUpdateProjection from(final TrustedClientVisibleProjection visible) {
    TrustedClientUpdateProjection instance = new TrustedClientUpdateProjection();
    instance.uidValue = visible.getUid();
    instance.codeValue = visible.getCode();
    instance.publicAllowValue = visible.getPublicAllow();
    instance.secretOauthValue = visible.getSecretOauth();
    instance.allowedRedirectsValue = visible.getAllowedRedirects();
    instance.enabledValue = visible.getEnabled();
    instance.versionValue = visible.getVersion();
    return instance;
  }

  /**
   * Si permitimos login directo de la app, obligamos a indicar un secreto.
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<AllowedRedirectsVO> allowedRedirectsValue;

  /**
   * El código identificativo de la aplicación
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<CodeVO> codeValue;

  /**
   * Una marca que permite quitar el acceso a una cuenta sin borrarla
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<EnabledVO> enabledValue;

  /**
   * If true, users can use these client to access with public code flow
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<PublicAllowVO> publicAllowValue;

  /**
   * If the user is not delegated, the phrasse to identify
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<SecretOauthVO> secretOauthValue;

  /**
   * El identificador de la aplicacion
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<UidVO> uidValue;

  /**
   * Campo con el número de version de trusted client para controlar bloqueos optimistas
   *
   * @autogenerated UpdateProjectionGenerator
   */
  private Optional<VersionVO> versionValue;

  /**
   * Create a dto instance with all the values of an entity
   *
   * @autogenerated UpdateProjectionGenerator
   * @param entity The entity who provide values.
   */
  public TrustedClientUpdateProjection(final TrustedClient entity) {
    uidValue = Optional.of(entity.getUidValue());
    codeValue = Optional.of(entity.getCodeValue());
    publicAllowValue = Optional.of(entity.getPublicAllowValue());
    secretOauthValue = Optional.of(entity.getSecretOauthValue());
    allowedRedirectsValue = Optional.of(entity.getAllowedRedirectsValue());
    enabledValue = Optional.of(entity.getEnabledValue());
    versionValue = Optional.of(entity.getVersionValue());
  }

  /**
   * Inform for a possible change propolsal in AllowedRedirects
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for AllowedRedirects, otherwise the value for
   *         AllowedRedirects
   */
  public String getAllowedRedirects() {
    return getAllowedRedirectsOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in AllowedRedirects
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for AllowedRedirects, otherwise the value for
   *         AllowedRedirects
   */
  public String getAllowedRedirectsOrDefault(final String orDefault) {
    return allowedRedirectsValue.flatMap(AllowedRedirectsVO::getAllowedRedirects).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Code
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Code, otherwise the value for Code
   */
  public String getCode() {
    return getCodeOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Code
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Code, otherwise the value for Code
   */
  public String getCodeOrDefault(final String orDefault) {
    return codeValue.map(CodeVO::getCode).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in SecretOauth
   *
   * @autogenerated UpdateProjectionGenerator
   * @param cypher
   * @return empty if there is no change proposal for SecretOauth, otherwise the value for
   *         SecretOauth
   */
  public String getCypheredSecretOauth(final AesCipherService cypher) {
    return getCypheredSecretOauthOrDefault(cypher, null);
  }

  /**
   * Inform for a possible change propolsal in SecretOauth
   *
   * @autogenerated UpdateProjectionGenerator
   * @param cypher
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for SecretOauth, otherwise the value for
   *         SecretOauth
   */
  public String getCypheredSecretOauthOrDefault(final AesCipherService cypher,
      final String orDefault) {
    return secretOauthValue.flatMap(vo -> vo.getCypheredSecretOauth(cypher)).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Enabled
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Enabled, otherwise the value for Enabled
   */
  public Boolean getEnabled() {
    return getEnabledOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Enabled
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Enabled, otherwise the value for Enabled
   */
  public Boolean getEnabledOrDefault(final Boolean orDefault) {
    return enabledValue.map(EnabledVO::isEnabled).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in SecretOauth
   *
   * @autogenerated UpdateProjectionGenerator
   * @param cypher
   * @return empty if there is no change proposal for SecretOauth, otherwise the value for
   *         SecretOauth
   */
  public String getPlainSecretOauth(final AesCipherService cypher) {
    return getPlainSecretOauthOrDefault(cypher, null);
  }

  /**
   * Inform for a possible change propolsal in SecretOauth
   *
   * @autogenerated UpdateProjectionGenerator
   * @param cypher
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for SecretOauth, otherwise the value for
   *         SecretOauth
   */
  public String getPlainSecretOauthOrDefault(final AesCipherService cypher,
      final String orDefault) {
    return secretOauthValue.flatMap(vo -> vo.getPlainSecretOauth(cypher)).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in PublicAllow
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for PublicAllow, otherwise the value for
   *         PublicAllow
   */
  public Boolean getPublicAllow() {
    return getPublicAllowOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in PublicAllow
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for PublicAllow, otherwise the value for
   *         PublicAllow
   */
  public Boolean getPublicAllowOrDefault(final Boolean orDefault) {
    return publicAllowValue.map(PublicAllowVO::isPublicAllow).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Uid
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Uid, otherwise the value for Uid
   */
  public String getUid() {
    return getUidOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Uid
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Uid, otherwise the value for Uid
   */
  public String getUidOrDefault(final String orDefault) {
    return uidValue.map(UidVO::getUid).orElse(orDefault);
  }

  /**
   * Inform for a possible change propolsal in Version
   *
   * @autogenerated UpdateProjectionGenerator
   * @return empty if there is no change proposal for Version, otherwise the value for Version
   */
  public Integer getVersion() {
    return getVersionOrDefault(null);
  }

  /**
   * Inform for a possible change propolsal in Version
   *
   * @autogenerated UpdateProjectionGenerator
   * @param orDefault Default value if is null
   * @return empty if there is no change proposal for Version, otherwise the value for Version
   */
  public Integer getVersionOrDefault(final Integer orDefault) {
    return versionValue.flatMap(VersionVO::getVersion).orElse(orDefault);
  }
}
