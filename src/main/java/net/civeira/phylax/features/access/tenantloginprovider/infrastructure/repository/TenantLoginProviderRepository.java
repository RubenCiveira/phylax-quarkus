package net.civeira.phylax.features.access.tenantloginprovider.infrastructure.repository;

import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Predicate;

import javax.sql.DataSource;

import io.opentelemetry.api.trace.Tracer;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.algorithms.Slider;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.exception.NotFoundException;
import net.civeira.phylax.common.infrastructure.sql.OptimistLockException;
import net.civeira.phylax.common.infrastructure.sql.PartialWhere;
import net.civeira.phylax.common.infrastructure.sql.SqlCommand;
import net.civeira.phylax.common.infrastructure.sql.SqlConverter;
import net.civeira.phylax.common.infrastructure.sql.SqlListParameterValue;
import net.civeira.phylax.common.infrastructure.sql.SqlOperator;
import net.civeira.phylax.common.infrastructure.sql.SqlParameterValue;
import net.civeira.phylax.common.infrastructure.sql.SqlQuery;
import net.civeira.phylax.common.infrastructure.sql.SqlResult;
import net.civeira.phylax.common.infrastructure.sql.SqlSchematicQuery;
import net.civeira.phylax.common.infrastructure.sql.SqlTemplate;
import net.civeira.phylax.features.access.tenantloginprovider.domain.TenantLoginProvider;
import net.civeira.phylax.features.access.tenantloginprovider.domain.TenantLoginProviderRef;
import net.civeira.phylax.features.access.tenantloginprovider.domain.gateway.TenantLoginProviderCursor;
import net.civeira.phylax.features.access.tenantloginprovider.domain.gateway.TenantLoginProviderFilter;
import net.civeira.phylax.features.access.tenantloginprovider.domain.gateway.TenantLoginProviderOrder;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.CertificateVO;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.DirectAccessVO;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.DisabledVO;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.MetadataVO;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.NameVO;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.PrivateKeyVO;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.PublicKeyVO;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.SourceVO;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.TenantVO;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.UidVO;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.UsersEnabledByDefaultVO;
import net.civeira.phylax.features.access.tenantloginprovider.domain.valueobject.VersionVO;

@ApplicationScoped
@RequiredArgsConstructor
@Slf4j
public class TenantLoginProviderRepository {

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_CERTIFICATE =
      "access_tenant_login_provider.certificate";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_DIRECT_ACCESS =
      "access_tenant_login_provider.direct_access";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_DISABLED =
      "access_tenant_login_provider.disabled";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_METADATA =
      "access_tenant_login_provider.metadata";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_NAME =
      "access_tenant_login_provider.name";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_PRIVATE_KEY =
      "access_tenant_login_provider.private_key";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_PUBLIC_KEY =
      "access_tenant_login_provider.public_key";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_SNAKE = "access_tenant_login_provider";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_SOURCE =
      "access_tenant_login_provider.source";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_TENANT =
      "access_tenant_login_provider.tenant";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_UID = "access_tenant_login_provider.uid";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_USERS_ENABLED_BY_DEFAULT =
      "access_tenant_login_provider.users_enabled_by_default";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TENANT_LOGIN_PROVIDER_VERSION =
      "access_tenant_login_provider.version";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String CERTIFICATE = "certificate";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String DIRECT_ACCESS = "directAccess";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String DIRECT_ACCESS_SNAKE = "direct_access";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String DISABLED = "disabled";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String METADATA = "metadata";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String NAME = "name";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String PRIVATE_KEY = "privateKey";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String PRIVATE_KEY_SNAKE = "private_key";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String PUBLIC_KEY = "publicKey";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String PUBLIC_KEY_SNAKE = "public_key";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String SOURCE = "source";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TENANT = "tenant";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String UID = "uid";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USERS_ENABLED_BY_DEFAULT = "usersEnabledByDefault";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String USERS_ENABLED_BY_DEFAULT_SNAKE = "users_enabled_by_default";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String VERSION = "version";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final DataSource datasource;

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final Tracer tracer;

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public long count(TenantLoginProviderFilter filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<Long> sq = filteredQuery(template, filter);
      sq.select("count(uid) as uid");
      return sq.query(row -> Optional.of(row.getLong(1))).one().orElse(0l);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public TenantLoginProvider create(TenantLoginProvider entity) {
    return runCreate(entity, null);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  public TenantLoginProvider create(TenantLoginProvider entity,
      Predicate<TenantLoginProvider> verifier) {
    return runCreate(entity, verifier);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   */
  public void delete(TenantLoginProvider entity) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlCommand sq = template
          .createSqlCommand("delete from \"access_tenant_login_provider\" where \"uid\" = :uid");
      sq.with(UID, SqlParameterValue.of(entity.getUid()));
      int num = sq.execute();
      if (0 == num) {
        throw new IllegalArgumentException("No delete from");
      }
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public boolean exists(String uid, Optional<TenantLoginProviderFilter> filter) {
    return retrieve(uid, filter).isPresent();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public boolean existsForUpdate(String uid, Optional<TenantLoginProviderFilter> filter) {
    return retrieveForUpdate(uid, filter).isPresent();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public Optional<TenantLoginProvider> find(TenantLoginProviderFilter filter) {
    TenantLoginProviderCursor cursor = TenantLoginProviderCursor.builder().build();
    return new TenantLoginProviderSlider(runList(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor).one();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public Optional<TenantLoginProvider> find(final String sql,
      final Map<String, SqlParameterValue> params) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<TenantLoginProvider> createSqlQuery = template.createSqlQuery(sql);
      params.forEach(createSqlQuery::with);
      return createSqlQuery.query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public Optional<TenantLoginProvider> findForUpdate(TenantLoginProviderFilter filter) {
    TenantLoginProviderCursor cursor = TenantLoginProviderCursor.builder().build();
    return new TenantLoginProviderSlider(runListForUpdate(filter, cursor),
        cursor.getLimit().orElse(0), this::runList, filter, cursor).one();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public Optional<TenantLoginProvider> findForUpdate(final String sql,
      final Map<String, SqlParameterValue> params) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<TenantLoginProvider> createSqlQuery = template.createSqlQuery(sql);
      params.forEach(createSqlQuery::with);
      return createSqlQuery.forUpdate().query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public List<TenantLoginProvider> list(TenantLoginProviderFilter filter) {
    TenantLoginProviderCursor cursor = TenantLoginProviderCursor.builder().build();
    return new TenantLoginProviderSlider(runList(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor).all();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<TenantLoginProvider> list(final String sql,
      final Map<String, SqlParameterValue> params) {
    return list(sql, params, null, false);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<TenantLoginProvider> list(final String sql,
      final Map<String, SqlParameterValue> params, final int limit) {
    return list(sql, params, Integer.valueOf(limit), false);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public List<TenantLoginProvider> listForUpdate(TenantLoginProviderFilter filter) {
    TenantLoginProviderCursor cursor = TenantLoginProviderCursor.builder().build();
    return new TenantLoginProviderSlider(runListForUpdate(filter, cursor),
        cursor.getLimit().orElse(0), this::runList, filter, cursor).all();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<TenantLoginProvider> listForUpdate(final String sql,
      final Map<String, SqlParameterValue> params) {
    return list(sql, params, null, true);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<TenantLoginProvider> listForUpdate(final String sql,
      final Map<String, SqlParameterValue> params, final int limit) {
    return list(sql, params, Integer.valueOf(limit), true);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param reference
   * @return
   */
  public TenantLoginProvider resolve(TenantLoginProviderRef reference) {
    return reference instanceof TenantLoginProvider tenantLoginProvider ? tenantLoginProvider
        : retrieve(reference.getUid(), Optional.empty()).orElseThrow(() -> new NotFoundException(
            "Trying to resolve inexistent TenantLoginProvider: " + reference.getUid()));
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param reference
   * @return
   */
  public TenantLoginProvider resolveForUpdate(TenantLoginProviderRef reference) {
    return reference instanceof TenantLoginProvider tenantLoginProvider ? tenantLoginProvider
        : retrieveForUpdate(reference.getUid(), Optional.empty())
            .orElseThrow(() -> new NotFoundException(
                "Trying to resolve inexistent TenantLoginProvider: " + reference.getUid()));
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public Optional<TenantLoginProvider> retrieve(String uid,
      Optional<TenantLoginProviderFilter> filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      TenantLoginProviderFilter readyFilter = filter.map(val -> val.withUid(uid))
          .orElseGet(() -> TenantLoginProviderFilter.builder().uid(uid).build());
      SqlSchematicQuery<TenantLoginProvider> sq = filteredQuery(template, readyFilter);
      return sq.query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public Optional<TenantLoginProvider> retrieveForUpdate(String uid,
      Optional<TenantLoginProviderFilter> filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      TenantLoginProviderFilter readyFilter = filter.map(val -> val.withUid(uid))
          .orElseGet(() -> TenantLoginProviderFilter.builder().uid(uid).build());
      SqlSchematicQuery<TenantLoginProvider> sq = filteredQuery(template, readyFilter);
      return sq.forUpdate().query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  public Slider<TenantLoginProvider> slide(TenantLoginProviderFilter filter,
      TenantLoginProviderCursor cursor) {
    return new TenantLoginProviderSlider(runList(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  public Slider<TenantLoginProvider> slideForUpdate(TenantLoginProviderFilter filter,
      TenantLoginProviderCursor cursor) {
    return new TenantLoginProviderSlider(runListForUpdate(filter, cursor),
        cursor.getLimit().orElse(0), this::runList, filter, cursor);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public TenantLoginProvider update(TenantLoginProvider entity) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlCommand sq = template.createSqlCommand(
          "update \"access_tenant_login_provider\" set  \"tenant\" = :tenant, \"name\" = :name, \"source\" = :source, \"disabled\" = :disabled, \"direct_access\" = :directAccess, \"public_key\" = :publicKey, \"private_key\" = :privateKey, \"certificate\" = :certificate, \"metadata\" = :metadata, \"users_enabled_by_default\" = :usersEnabledByDefault, \"version\" = \"version\" + 1 where \"uid\" = :uid and \"version\" = :version");
      sq.with(UID, SqlParameterValue.of(entity.getUid()));
      sq.with(TENANT, SqlParameterValue.of(entity.getTenantUid()));
      sq.with(NAME, SqlParameterValue.of(entity.getName()));
      sq.with(SOURCE, SqlParameterValue.of(entity.getSource().toString()));
      sq.with(DISABLED, SqlParameterValue.of(entity.isDisabled()));
      sq.with(DIRECT_ACCESS, SqlParameterValue.of(entity.isDirectAccess()));
      sq.with(PUBLIC_KEY, entity.getPublicKey().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(PRIVATE_KEY, entity.getPrivateKey().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(CERTIFICATE, entity.getCertificate().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(METADATA, entity.getMetadata().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(USERS_ENABLED_BY_DEFAULT, SqlParameterValue.of(entity.isUsersEnabledByDefault()));
      sq.with(VERSION, entity.getVersion().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      int num = sq.execute();
      if (0 == num) {
        throw new OptimistLockException("No delete from");
      }
      return entity.withNextVersion();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sq
   * @param cursor
   */
  private void attachWithOrder(SqlSchematicQuery<TenantLoginProvider> sq,
      TenantLoginProviderCursor cursor) {
    PartialWhere[] offset = new PartialWhere[] {PartialWhere.empty(), PartialWhere.empty()};
    for (TenantLoginProviderOrder order : cursor.getOrder()) {
      tryToOrderByNameAsc(sq, offset, cursor, order);
      tryToOrderByNameDesc(sq, offset, cursor, order);
    }
    Optional<String> sinceUid = cursor.getSinceUid();
    if (sinceUid.isPresent()) {
      offset[0] = PartialWhere.or(offset[0], PartialWhere.and(offset[1],
          PartialWhere.where("uid", SqlOperator.GT, SqlParameterValue.of(sinceUid.get()))));
    }
    sq.where(offset[0]);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @return
   */
  private SqlConverter<TenantLoginProvider> converter() {
    return row -> {
      try {
        return Optional.of(TenantLoginProvider.builder().uidValue(UidVO.from(row.getString(UID)))
            .tenantValue(TenantVO.fromReference(row.getString(TENANT)))
            .nameValue(NameVO.from(row.getString(NAME)))
            .sourceValue(SourceVO.tryFrom(row.getString(SOURCE)))
            .disabledValue(DisabledVO.from(row.getBoolean(DISABLED)))
            .directAccessValue(DirectAccessVO.from(row.getBoolean(DIRECT_ACCESS_SNAKE)))
            .publicKeyValue(PublicKeyVO.from(row.getString(PUBLIC_KEY_SNAKE)))
            .privateKeyValue(PrivateKeyVO.from(row.getString(PRIVATE_KEY_SNAKE)))
            .certificateValue(CertificateVO.from(row.getString(CERTIFICATE)))
            .metadataValue(MetadataVO.from(row.getString(METADATA)))
            .usersEnabledByDefaultValue(
                UsersEnabledByDefaultVO.from(row.getBoolean(USERS_ENABLED_BY_DEFAULT_SNAKE)))
            .versionValue(VersionVO.from(row.getInt(VERSION))).build());
      } catch (ConstraintException ce) {
        log.error("Unable to map data for {}", row.getString(1), ce);
        return Optional.empty();
      }
    };
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param template
   * @param filter
   * @return
   */
  private <T> SqlSchematicQuery<T> filteredQuery(SqlTemplate template,
      TenantLoginProviderFilter filter) {
    SqlSchematicQuery<T> sq = template.createSqlSchematicQuery(ACCESS_TENANT_LOGIN_PROVIDER_SNAKE);
    sq.selectFields(ACCESS_TENANT_LOGIN_PROVIDER_UID, ACCESS_TENANT_LOGIN_PROVIDER_TENANT,
        ACCESS_TENANT_LOGIN_PROVIDER_NAME, ACCESS_TENANT_LOGIN_PROVIDER_SOURCE,
        ACCESS_TENANT_LOGIN_PROVIDER_DISABLED, ACCESS_TENANT_LOGIN_PROVIDER_DIRECT_ACCESS,
        ACCESS_TENANT_LOGIN_PROVIDER_PUBLIC_KEY, ACCESS_TENANT_LOGIN_PROVIDER_PRIVATE_KEY,
        ACCESS_TENANT_LOGIN_PROVIDER_CERTIFICATE, ACCESS_TENANT_LOGIN_PROVIDER_METADATA,
        ACCESS_TENANT_LOGIN_PROVIDER_USERS_ENABLED_BY_DEFAULT,
        ACCESS_TENANT_LOGIN_PROVIDER_VERSION);
    filter.getUid().ifPresent(uid -> sq.where(UID, SqlOperator.EQ, SqlParameterValue.of(uid)));
    if (!filter.getUids().isEmpty()) {
      sq.where(UID, SqlOperator.IN, SqlListParameterValue.strings(filter.getUids()));
    }
    filter.getSearch().ifPresent(
        search -> sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%")));
    filter.getName().ifPresent(name -> sq.where(NAME, SqlOperator.EQ, SqlParameterValue.of(name)));
    filter.getTenant().ifPresent(
        tenant -> sq.where(TENANT, SqlOperator.EQ, SqlParameterValue.of(tenant.getUid())));
    if (!filter.getTenants().isEmpty()) {
      sq.where(TENANT, SqlOperator.IN, SqlListParameterValue.strings(filter.getTenants()));
    }
    filter.getTenantTenantAccesible()
        .ifPresent(tenantTenantAccesible -> sq.where(ACCESS_TENANT_LOGIN_PROVIDER_TENANT,
            SqlOperator.EQ, SqlParameterValue.of(tenantTenantAccesible)));
    return sq;
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @param forUpdate
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  private List<TenantLoginProvider> list(final String sql,
      final Map<String, SqlParameterValue> params, final Integer limit, final boolean forUpdate) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<TenantLoginProvider> createSqlQuery = template.createSqlQuery(sql);
      params.forEach(createSqlQuery::with);
      if (forUpdate) {
        createSqlQuery = createSqlQuery.forUpdate();
      }
      SqlResult<TenantLoginProvider> query = createSqlQuery.query(converter());
      return null == limit ? query.all() : query.limit(limit);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  private TenantLoginProvider runCreate(TenantLoginProvider entity,
      Predicate<TenantLoginProvider> verifier) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlCommand sq = template.createSqlCommand(
          "insert into \"access_tenant_login_provider\" ( \"uid\", \"tenant\", \"name\", \"source\", \"disabled\", \"direct_access\", \"public_key\", \"private_key\", \"certificate\", \"metadata\", \"users_enabled_by_default\", \"version\") values ( :uid, :tenant, :name, :source, :disabled, :directAccess, :publicKey, :privateKey, :certificate, :metadata, :usersEnabledByDefault, :version)");
      sq.with(UID, SqlParameterValue.of(entity.getUid()));
      sq.with(TENANT, SqlParameterValue.of(entity.getTenantUid()));
      sq.with(NAME, SqlParameterValue.of(entity.getName()));
      sq.with(SOURCE, SqlParameterValue.of(entity.getSource().toString()));
      sq.with(DISABLED, SqlParameterValue.of(entity.isDisabled()));
      sq.with(DIRECT_ACCESS, SqlParameterValue.of(entity.isDirectAccess()));
      sq.with(PUBLIC_KEY, entity.getPublicKey().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(PRIVATE_KEY, entity.getPrivateKey().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(CERTIFICATE, entity.getCertificate().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(METADATA, entity.getMetadata().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullString));
      sq.with(USERS_ENABLED_BY_DEFAULT, SqlParameterValue.of(entity.isUsersEnabledByDefault()));
      sq.with(VERSION, entity.getVersion().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      int num = sq.execute();
      if (0 == num) {
        throw new IllegalArgumentException("No insert into");
      }
      return verifier == null ? entity : verified(verifier.test(entity), entity, template);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  private Iterator<TenantLoginProvider> runList(TenantLoginProviderFilter filter,
      TenantLoginProviderCursor cursor) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<TenantLoginProvider> sq = filteredQuery(template, filter);
      if (null != cursor.getOrder()) {
        attachWithOrder(sq, cursor);
      } else {
        cursor.getSinceUid()
            .ifPresent(since -> sq.where(UID, SqlOperator.GT, SqlParameterValue.of(since)));
      }
      sq.orderAsc("uid");
      return sq.query(converter()).limit(cursor.getLimit()).iterator();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  private Iterator<TenantLoginProvider> runListForUpdate(TenantLoginProviderFilter filter,
      TenantLoginProviderCursor cursor) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<TenantLoginProvider> sq = filteredQuery(template, filter);
      if (null != cursor.getOrder()) {
        attachWithOrder(sq, cursor);
      } else {
        cursor.getSinceUid()
            .ifPresent(since -> sq.where(UID, SqlOperator.GT, SqlParameterValue.of(since)));
      }
      sq.orderAsc("uid");
      return sq.forUpdate().query(converter()).limit(cursor.getLimit()).iterator();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sq
   * @param offset
   * @param cursor
   * @param order
   * @return
   */
  private PartialWhere[] tryToOrderByNameAsc(SqlSchematicQuery<TenantLoginProvider> sq,
      PartialWhere[] offset, TenantLoginProviderCursor cursor, TenantLoginProviderOrder order) {
    if (order == TenantLoginProviderOrder.NAME_ASC) {
      sq.addOrderAsc("name");
      Optional<String> sinceName = cursor.getSinceName();
      if (sinceName.isPresent()) {
        String sinceNameValue = sinceName.get();
        offset[0] = PartialWhere.or(offset[0], PartialWhere.and(offset[1],
            PartialWhere.where("name", SqlOperator.GT, SqlParameterValue.of(sinceNameValue))));
        offset[1] = PartialWhere.and(offset[1],
            PartialWhere.where("name", SqlOperator.EQ, SqlParameterValue.of(sinceNameValue)));
      }
    }
    return offset;
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sq
   * @param offset
   * @param cursor
   * @param order
   * @return
   */
  private PartialWhere[] tryToOrderByNameDesc(SqlSchematicQuery<TenantLoginProvider> sq,
      PartialWhere[] offset, TenantLoginProviderCursor cursor, TenantLoginProviderOrder order) {
    if (order == TenantLoginProviderOrder.NAME_DESC) {
      sq.addOrderDesc("name");
      Optional<String> sinceName = cursor.getSinceName();
      if (sinceName.isPresent()) {
        String sinceNameValue = sinceName.get();
        offset[0] = PartialWhere.or(offset[0], PartialWhere.and(offset[1],
            PartialWhere.where("name", SqlOperator.GT, SqlParameterValue.of(sinceNameValue))));
        offset[1] = PartialWhere.and(offset[1],
            PartialWhere.where("name", SqlOperator.EQ, SqlParameterValue.of(sinceNameValue)));
      }
    }
    return offset;
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param exists
   * @param entity
   * @param template
   * @return
   */
  private TenantLoginProvider verified(boolean exists, TenantLoginProvider entity,
      SqlTemplate template) {
    if (exists) {
      return entity;
    } else {
      template.createSqlCommand("delete from \"access_tenant_login_provider\" where \"uid\" = :uid")
          .with("uid", SqlParameterValue.of(entity.getUid())).execute();
      throw new NotFoundException("");
    }
  }
}
