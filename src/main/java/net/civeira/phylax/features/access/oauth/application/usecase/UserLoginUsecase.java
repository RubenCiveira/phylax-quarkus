/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.usecase;

import java.time.Duration;
import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.temporal.TemporalAmount;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.features.access.oauth.application.service.ActiveUserFindService;
import net.civeira.phylax.features.access.oauth.application.service.RequiredConsentService;
import net.civeira.phylax.features.access.relyingparty.domain.RelyingParty;
import net.civeira.phylax.features.access.relyingparty.domain.RelyingPartyRef;
import net.civeira.phylax.features.access.relyingparty.domain.gateway.RelyingPartyFilter;
import net.civeira.phylax.features.access.relyingparty.domain.gateway.RelyingPartyReadRepositoryGateway;
import net.civeira.phylax.features.access.role.domain.Role;
import net.civeira.phylax.features.access.tenant.domain.Tenant;
import net.civeira.phylax.features.access.trustedclient.domain.TrustedClient;
import net.civeira.phylax.features.access.trustedclient.domain.TrustedClientRef;
import net.civeira.phylax.features.access.trustedclient.domain.gateway.TrustedClientFilter;
import net.civeira.phylax.features.access.trustedclient.domain.gateway.TrustedClientReadRepositoryGateway;
import net.civeira.phylax.features.access.user.domain.User;
import net.civeira.phylax.features.access.user.domain.gateway.UserWriteRepositoryGateway;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.UserAccessTemporalCode;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.UserAccessTemporalCodeChangeSet;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.gateway.UserAccessTemporalCodeFilter;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.gateway.UserAccessTemporalCodeWriteRepositoryGateway;
import net.civeira.phylax.features.access.useridentity.domain.UserIdentity;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityFilter;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityReadRepositoryGateway;
import net.civeira.phylax.features.oauth.authentication.domain.gateway.EventNotifierGateway;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthRequest;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationChallege;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationData;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationMode;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationResult;
import net.civeira.phylax.features.oauth.client.domain.model.ClientDetails;

@Slf4j
@ApplicationScoped
@RequiredArgsConstructor
public class UserLoginUsecase {
  private static final int LIMIT = 3;
  private static final TemporalAmount BLOCK_TIME = Duration.ofHours(6);

  @ConfigProperty(name = "masterpassword")
  private final String masterpassword;

  private final RequiredConsentService terms;

  private final ActiveUserFindService activeUser;

  private final EventNotifierGateway eventNotifier;

  private final UserWriteRepositoryGateway users;

  private final UserIdentityReadRepositoryGateway identities;

  private final UserAccessTemporalCodeWriteRepositoryGateway codes;

  private final TrustedClientReadRepositoryGateway clients;

  private final RelyingPartyReadRepositoryGateway parties;

  private final AesCipherService cypher;

  private final MfaConfigUsecase otp;

  public AuthenticationResult validatePreAuthenticated(AuthRequest request, String username,
      ClientDetails appkey, List<AuthenticationChallege> challenges) {
    if (log.isInfoEnabled()) {
      log.info("preAuth throught app {}, after {}", appkey, challenges);
    }
    return send(userData(request, username, null, AuthenticationMode.SESSION));
  }

  public AuthenticationResult validateUserData(AuthRequest request, String username,
      String password, ClientDetails appkey, List<AuthenticationChallege> challenges) {
    if (log.isInfoEnabled()) {
      log.info("validate throught app {}, after {}", appkey, challenges);
    }
    return send(userData(request, username, password, AuthenticationMode.PASSWORD));
  }

  public AuthenticationResult validateMfa(AuthRequest request, String username, String secreto,
      ClientDetails client, List<AuthenticationChallege> challenges) {
    if (otp.validateOtp(request.getTenant(), username, request.getAudiences(), secreto)) {
      return send(userData(request, username, null, AuthenticationMode.MFA));
    } else {
      return AuthenticationResult.wrongCredential(request.getTenant(), username);
    }
  }

  public boolean updatePassword(AuthRequest request, String username, String oldPassword,
      String newPassword) {
    return activeUser.findEnabledUser(request.getTenant(), username, request.getAudiences())
        .map(user -> {
          if (oldPassword.equals(user.getPlainPassword(cypher))) {
            users.update(user, user.changePassword(newPassword));
            return true;
          } else {
            return false;
          }
        }).orElse(false);
  }

  private AuthenticationResult send(AuthenticationResult result) {
    if (result.isRight()) {
      eventNotifier.loginOk(result.getData());
    } else {
      eventNotifier.loginFail(result.getFail());
    }
    return result;
  }

  private AuthenticationResult userData(AuthRequest request, String name, String password,
      AuthenticationMode mode) {
    return activeUser.findEnabledTenant(request.getTenant(), request.getAudiences())
        .flatMap(tenant -> activeUser.findEnabledUser(tenant, name)
            .map(user -> userToGrant(request, mode, name, password, tenant, user)))
        .orElseGet(() -> AuthenticationResult.unknownName(request.getTenant(), name));
  }

  private AuthenticationResult userToGrant(AuthRequest request, AuthenticationMode mode,
      String name, String password, Tenant tenant, User user) {
    List<Supplier<Optional<AuthenticationResult>>> calls =
        List.of(() -> checkPassword(request, user, password), () -> checkFirstPass(request, user),
            () -> checkMfa(request, user, mode), () -> checkTerms(request, user));

    for (Supplier<Optional<AuthenticationResult>> call : calls) {
      Optional<AuthenticationResult> value = call.get();
      if (value.isPresent()) {
        return value.get();
      }
    }
    AuthenticationData ud = new AuthenticationData();
    ud.setDetails(new HashMap<>());
    ud.setUid("" + name.hashCode());
    ud.setUsername(name);
    ud.setUsername(name);
    ud.setTenant(user.getTenantUid());
    ud.setMode(mode);
    ud.setTime(Instant.now());

    List<UserIdentity> hisIdentities =
        identities.list(UserIdentityFilter.builder().user(user).build());
    request.getAudiences().forEach(aud -> {
      Optional<RelyingParty> isParty = parties.find(RelyingPartyFilter.builder().code(aud).build());
      if (isParty.isPresent()) {
        RelyingParty relyingParty = isParty.get();
        hisIdentities.stream()
            .filter(identity -> relyingParty.getUid()
                .equals(identity.getRelyingParty().map(RelyingPartyRef::getUid).orElse("")))
            .findFirst().ifPresent(identity -> ud.addRolesTo(aud,
                identities.resolveRoles(identity.getRoles()).stream().map(Role::getName).toList()));
      } else {
        Optional<TrustedClient> isClient =
            clients.find(TrustedClientFilter.builder().code(aud).build());
        if (isClient.isPresent()) {
          TrustedClient trustedClient = isClient.get();
          hisIdentities.stream()
              .filter(identity -> trustedClient.getUid()
                  .equals(identity.getTrustedClient().map(TrustedClientRef::getUid).orElse("")))
              .findFirst().ifPresent(identity -> ud.addRolesTo(aud, identities
                  .resolveRoles(identity.getRoles()).stream().map(Role::getName).toList()));
        }
      }
    });
    if (tenant.isRoot()) {
      ud.getDetails().put("root", true);
    }
    return AuthenticationResult.right(ud);
  }

  private Optional<AuthenticationResult> checkMfa(AuthRequest request, User user,
      AuthenticationMode mode) {
    if (AuthenticationMode.PASSWORD == mode && user.isUseSecondFactors()) {
      if (!user.getCypheredSecondFactorSeed(cypher).isPresent()) {
        return Optional
            .of(AuthenticationResult.newMfaRequired(request.getTenant(), user.getName()));
      } else {
        return Optional.of(AuthenticationResult.mfaRequired(request.getTenant(), user.getName()));
      }
    } else {
      return Optional.empty();
    }
  }

  private Optional<AuthenticationResult> checkFirstPass(AuthRequest request, User user) {
    if (user.isTemporalPassword()) {
      return Optional
          .of(AuthenticationResult.newPasswordRequired(request.getTenant(), user.getName()));
    } else {
      return Optional.empty();
    }
  }

  private Optional<AuthenticationResult> checkTerms(AuthRequest request, User user) {
    return terms.findPendingTerms(user)
        .map(ignore -> AuthenticationResult.consentRequired(request.getTenant(), user.getName()));
  }

  private Optional<AuthenticationResult> checkPassword(AuthRequest request, User user,
      String password) {
    if (null != password
        && !password.equals(cypher.decryptForAll(user.getCypheredPassword(cypher)).orElse(""))) {
      log.error("The provided password for {} is invalid", user.getName());
      markLoginFails(user, true);
      return Optional.of(AuthenticationResult.wrongCredential(request.getTenant(), user.getName()));
    } else {
      markLoginFails(user, false);
      return Optional.empty();
    }
  }

  private void markLoginFails(User user, boolean fail) {
    UserAccessTemporalCodeFilter filter = UserAccessTemporalCodeFilter.builder().user(user).build();
    Optional<UserAccessTemporalCode> find = codes.findForUpdate(filter);
    UserAccessTemporalCode code;
    if (find.isPresent()) {
      code = find.get();
    } else {
      code = codes.create(UserAccessTemporalCode
          .create(UserAccessTemporalCodeChangeSet.builder().newUid().user(user).build()));
    }
    if (fail) {
      int val = code.getFailedLoginAttempts().orElse(Integer.valueOf(0)).intValue() + 1;
      if (val > LIMIT) {
        users.update(user, user.block(OffsetDateTime.now().plus(BLOCK_TIME)));
        codes.update(code, code.markLoginBlock());
      } else {
        codes.update(code, code.markLoginFail());
      }
    } else if (0 != code.getFailedLoginAttempts().orElse(Integer.valueOf(0)).intValue()) {
      codes.update(code, code.markLoginOk());
    }
  }
}
