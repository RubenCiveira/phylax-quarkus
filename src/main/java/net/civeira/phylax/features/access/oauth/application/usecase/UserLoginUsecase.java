/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.usecase;

import java.time.Duration;
import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.temporal.TemporalAmount;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.features.access.oauth.application.service.ActiveUserFindService;
import net.civeira.phylax.features.access.oauth.application.service.RequiredConsentService;
import net.civeira.phylax.features.access.relyingparty.domain.RelyingParty;
import net.civeira.phylax.features.access.relyingparty.domain.RelyingPartyRef;
import net.civeira.phylax.features.access.relyingparty.domain.gateway.RelyingPartyFilter;
import net.civeira.phylax.features.access.relyingparty.domain.gateway.RelyingPartyReadRepositoryGateway;
import net.civeira.phylax.features.access.role.domain.Role;
import net.civeira.phylax.features.access.trustedclient.domain.TrustedClient;
import net.civeira.phylax.features.access.trustedclient.domain.TrustedClientRef;
import net.civeira.phylax.features.access.trustedclient.domain.gateway.TrustedClientFilter;
import net.civeira.phylax.features.access.trustedclient.domain.gateway.TrustedClientReadRepositoryGateway;
import net.civeira.phylax.features.access.user.domain.User;
import net.civeira.phylax.features.access.user.domain.gateway.UserWriteRepositoryGateway;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.UserAccessTemporalCode;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.UserAccessTemporalCodeChangeSet;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.gateway.UserAccessTemporalCodeFilter;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.gateway.UserAccessTemporalCodeWriteRepositoryGateway;
import net.civeira.phylax.features.access.useridentity.domain.UserIdentity;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityFilter;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityReadRepositoryGateway;
import net.civeira.phylax.features.oauth.authentication.domain.gateway.EventNotifierGateway;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthRequest;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationChallege;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationData;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationMode;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationResult;
import net.civeira.phylax.features.oauth.client.domain.model.ClientDetails;

@Slf4j
@ApplicationScoped
@RequiredArgsConstructor
public class UserLoginUsecase {
  private static final int LIMIT = 3;
  private static final TemporalAmount BLOCK_TIME = Duration.ofHours(6);

  @ConfigProperty(name = "masterpassword")
  private final String masterpassword;

  private final RequiredConsentService terms;

  private final ActiveUserFindService activeUser;

  private final EventNotifierGateway eventNotifier;

  private final UserWriteRepositoryGateway users;

  private final UserIdentityReadRepositoryGateway identities;

  private final UserAccessTemporalCodeWriteRepositoryGateway codes;

  private final TrustedClientReadRepositoryGateway clients;

  private final RelyingPartyReadRepositoryGateway parties;

  private final AesCipherService cypher;

  private final MfaConfigUsecase otp;

  public AuthenticationResult validatePreAuthenticated(AuthRequest request, String username,
      ClientDetails appkey, List<AuthenticationChallege> challenges) {
    if (log.isInfoEnabled()) {
      log.info("preAuth throught app {}, after {}", appkey, challenges);
    }
    return send(userData(request, username, null, AuthenticationMode.SESSION));
  }

  public AuthenticationResult validateUserData(AuthRequest request, String username,
      String password, ClientDetails appkey, List<AuthenticationChallege> challenges) {
    if (log.isInfoEnabled()) {
      log.info("validate throught app {}, after {}", appkey, challenges);
    }
    return send(userData(request, username, password, AuthenticationMode.PASSWORD));
  }

  public AuthenticationResult validateMfa(AuthRequest request, String username, String secreto,
      ClientDetails client, List<AuthenticationChallege> challenges) {
    if (otp.validateOtp(request.getTenant(), username, request.getAudiences(), secreto)) {
      return send(userData(request, username, null, AuthenticationMode.MFA));
    } else {
      return AuthenticationResult.wrongCredential(request.getTenant(), username);
    }
  }

  public boolean updatePassword(AuthRequest request, String username, String oldPassword,
      String newPassword) {
    return activeUser.findEnabledUser(request.getTenant(), username, request.getAudiences())
        .map(user -> {
          if (oldPassword.equals(user.getPlainPassword(cypher))) {
            users.update(user, user.changePassword(newPassword));
            return true;
          } else {
            return false;
          }
        }).orElse(false);
  }

  private AuthenticationResult send(AuthenticationResult result) {
    if (result.isRight()) {
      eventNotifier.loginOk(result.getData());
    } else {
      eventNotifier.loginFail(result.getFail());
    }
    return result;
  }

  private AuthenticationResult userData(AuthRequest request, String name, String password,
      AuthenticationMode mode) {
    return activeUser.findEnabledUser(request.getTenant(), name, request.getAudiences())
        .map(user -> {
          List<Supplier<Optional<AuthenticationResult>>> calls = List.of(
              () -> checkPassword(request, user, password), () -> checkFirstPass(request, user),
              () -> checkMfa(request, user, mode), () -> checkTerms(request, user));

          for (Supplier<Optional<AuthenticationResult>> call : calls) {
            Optional<AuthenticationResult> value = call.get();
            if (value.isPresent()) {
              return value.get();
            }
          }
          AuthenticationData ud = new AuthenticationData();
          ud.setDetails(new HashMap<>());
          ud.setUid("" + name.hashCode());
          ud.setUsername(name);
          ud.setUsername(name);
          ud.setTenant(user.getTenantUid().orElse(null));
          ud.setMode(mode);
          ud.setTime(Instant.now());

          List<UserIdentity> hisIdentities =
              identities.list(UserIdentityFilter.builder().user(user).build());
          request.getAudiences().forEach(aud -> {
            Optional<RelyingParty> isParty =
                parties.find(RelyingPartyFilter.builder().code(aud).build());
            if (isParty.isPresent()) {
              RelyingParty relyingParty = isParty.get();
              hisIdentities.stream()
                  .filter(identity -> relyingParty.getUidValue().equals(
                      identity.getRelyingParty().map(RelyingPartyRef::getUid).orElse("")))
                  .findFirst()
                  .ifPresent(identity -> ud.addRolesTo(aud,
                      identities.resolveRoles(identity.getRoles()).stream()
                          .map(Role::getName).toList()));
            } else {
              Optional<TrustedClient> isClient =
                  clients.find(TrustedClientFilter.builder().code(aud).build());
              if (isClient.isPresent()) {
                TrustedClient trustedClient = isClient.get();
                hisIdentities.stream()
                    .filter(identity -> trustedClient.getUidValue()
                        .equals(identity
                            .getTrustedClient().map(TrustedClientRef::getUid).orElse("")))
                    .findFirst()
                    .ifPresent(identity -> ud.addRolesTo(aud,
                        identities.resolveRoles(identity.getRoles()).stream()
                            .map(Role::getName).toList()));
              }
            }
          });
          if (user.getTenant().isEmpty()) {
            ud.getDetails().put("root", true);
          }
          return AuthenticationResult.right(ud);
        }).orElseGet(() -> AuthenticationResult.unknownName(request.getTenant(), name));
  }

  private Optional<AuthenticationResult> checkMfa(AuthRequest request, User user,
      AuthenticationMode mode) {
    if (AuthenticationMode.PASSWORD == mode && user.isUseSecondFactors()) {
      if (!user.getCypheredSecondFactorSeed(cypher).isPresent()) {
        return Optional
            .of(AuthenticationResult.newMfaRequired(request.getTenant(), user.getName()));
      } else {
        return Optional
            .of(AuthenticationResult.mfaRequired(request.getTenant(), user.getName()));
      }
    } else {
      return Optional.empty();
    }
  }

  private Optional<AuthenticationResult> checkFirstPass(AuthRequest request, User user) {
    if (user.isTemporalPassword()) {
      return Optional
          .of(AuthenticationResult.newPasswordRequired(request.getTenant(), user.getName()));
    } else {
      return Optional.empty();
    }
  }

  private Optional<AuthenticationResult> checkTerms(AuthRequest request, User user) {
    return terms.findPendingTerms(user).map(
        ignore -> AuthenticationResult.consentRequired(request.getTenant(), user.getName()));
  }

  private Optional<AuthenticationResult> checkPassword(AuthRequest request, User user,
      String password) {
    if (null != password && !password
        .equals(cypher.decryptForAll(user.getCypheredPassword(cypher)).orElse(""))) {
      log.error("The provided password for {} is invalid", user.getName());
      markLoginFails(user, true);
      return Optional
          .of(AuthenticationResult.wrongCredential(request.getTenant(), user.getName()));
    } else {
      markLoginFails(user, false);
      return Optional.empty();
    }
  }

  private void markLoginFails(User user, boolean fail) {
    UserAccessTemporalCodeFilter filter = UserAccessTemporalCodeFilter.builder().user(user).build();
    Optional<UserAccessTemporalCode> find = codes.findForUpdate(filter);
    UserAccessTemporalCode code;
    if (find.isPresent()) {
      code = find.get();
    } else {
      code = codes.create(UserAccessTemporalCode
          .create(UserAccessTemporalCodeChangeSet.builder().newUid().user(user).build()));
    }
    if (fail) {
      int val = code.getFailedLoginAttempts().orElse(Integer.valueOf(0)).intValue() + 1;
      if (val > LIMIT) {
        users.update(user, user.block(OffsetDateTime.now().plus(BLOCK_TIME)));
        codes.update(code, code.markLoginBlock());
      } else {
        codes.update(code, code.markLoginFail());
      }
    } else if (0 != code.getFailedLoginAttempts().orElse(Integer.valueOf(0)).intValue()) {
      codes.update(code, code.markLoginOk());
    }
  }
}
