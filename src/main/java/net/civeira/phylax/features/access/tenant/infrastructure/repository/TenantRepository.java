package net.civeira.phylax.features.access.tenant.infrastructure.repository;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Predicate;

import javax.sql.DataSource;

import io.opentelemetry.api.trace.Tracer;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.algorithms.Slider;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.exception.NotFoundException;
import net.civeira.phylax.common.infrastructure.sql.AbstractSqlParametrized;
import net.civeira.phylax.common.infrastructure.sql.OptimistLockException;
import net.civeira.phylax.common.infrastructure.sql.PartialWhere;
import net.civeira.phylax.common.infrastructure.sql.SqlCommand;
import net.civeira.phylax.common.infrastructure.sql.SqlConverter;
import net.civeira.phylax.common.infrastructure.sql.SqlListParameterValue;
import net.civeira.phylax.common.infrastructure.sql.SqlOperator;
import net.civeira.phylax.common.infrastructure.sql.SqlParameterValue;
import net.civeira.phylax.common.infrastructure.sql.SqlQuery;
import net.civeira.phylax.common.infrastructure.sql.SqlResult;
import net.civeira.phylax.common.infrastructure.sql.SqlSchematicQuery;
import net.civeira.phylax.common.infrastructure.sql.SqlTemplate;
import net.civeira.phylax.features.access.relyingparty.RelyingParty;
import net.civeira.phylax.features.access.relyingparty.infrastructure.repository.RelyingPartyRepository;
import net.civeira.phylax.features.access.tenant.RelingParties;
import net.civeira.phylax.features.access.tenant.Tenant;
import net.civeira.phylax.features.access.tenant.TenantRef;
import net.civeira.phylax.features.access.tenant.TrustedClients;
import net.civeira.phylax.features.access.tenant.query.TenantCursor;
import net.civeira.phylax.features.access.tenant.query.TenantFilter;
import net.civeira.phylax.features.access.tenant.query.TenantOrder;
import net.civeira.phylax.features.access.tenant.valueobject.AccessToAllApplicationsVO;
import net.civeira.phylax.features.access.tenant.valueobject.DomainVO;
import net.civeira.phylax.features.access.tenant.valueobject.EnabledVO;
import net.civeira.phylax.features.access.tenant.valueobject.NameVO;
import net.civeira.phylax.features.access.tenant.valueobject.RelingPartiesVO;
import net.civeira.phylax.features.access.tenant.valueobject.TrustedClientsVO;
import net.civeira.phylax.features.access.tenant.valueobject.UidVO;
import net.civeira.phylax.features.access.tenant.valueobject.VersionVO;
import net.civeira.phylax.features.access.trustedclient.TrustedClient;
import net.civeira.phylax.features.access.trustedclient.infrastructure.repository.TrustedClientRepository;

@ApplicationScoped
@RequiredArgsConstructor
@Slf4j
public class TenantRepository {

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TO_ALL_APPLICATIONS = "accessToAllApplications";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ACCESS_TO_ALL_APPLICATIONS_SNAKE = "access_to_all_applications";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String DOMAIN = "domain";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String ENABLED = "enabled";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String NAME = "name";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String RELYING_PARTY = "relyingParty";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String RELYING_PARTY_SNAKE = "relying_party";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TENANT = "tenant";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TENANT_ACCESS_TO_ALL_APPLICATIONS =
      "tenant.access_to_all_applications";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TENANT_DOMAIN = "tenant.domain";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TENANT_ENABLED = "tenant.enabled";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TENANT_NAME = "tenant.name";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TENANT_UID = "tenant.uid";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TENANT_VERSION = "tenant.version";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TOMAP = "tomap";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TRUSTED_CLIENT = "trustedClient";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String TRUSTED_CLIENT_SNAKE = "trusted_client";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String UID = "uid";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private static final String VERSION = "version";

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final DataSource datasource;

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final RelyingPartyRepository relyingPartyRepository;

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final Tracer tracer;

  /**
   * @autogenerated RepositoryJdbcGenerator
   */
  private final TrustedClientRepository trustedClientRepository;

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public long count(TenantFilter filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<Long> sq = filteredQuery(template, filter);
      sq.select("count(uid) as uid");
      return sq.query(row -> Optional.of(row.getLong(1))).one().orElse(0l);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public Tenant create(Tenant entity) {
    return runCreate(entity, null);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  public Tenant create(Tenant entity, Predicate<Tenant> verifier) {
    return runCreate(entity, verifier);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   */
  public void delete(Tenant entity) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      deleteTrustedClients(entity, template);
      deleteRelingParties(entity, template);
      SqlCommand sq = template.createSqlCommand("delete from \"tenant\" where \"uid\" = :uid");
      sq.with(UID, SqlParameterValue.of(entity.getUidValue()));
      int num = sq.execute();
      if (0 == num) {
        throw new IllegalArgumentException("No delete from");
      }
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param reference
   * @return
   */
  public Tenant enrich(TenantRef reference) {
    return reference instanceof Tenant tenant ? tenant
        : retrieve(reference.getUidValue(), Optional.empty())
            .orElseThrow(() -> new NotFoundException(
                "Trying to enrich inexistent Tenant: " + reference.getUidValue()));
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param reference
   * @return
   */
  public Tenant enrichForUpdate(TenantRef reference) {
    return reference instanceof Tenant tenant ? tenant
        : retrieveForUpdate(reference.getUidValue(), Optional.empty())
            .orElseThrow(() -> new NotFoundException(
                "Trying to enrich inexistent Tenant: " + reference.getUidValue()));
  }

  /**
   * Retrieve one single value
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param childs
   * @return Retrieve one single value
   */
  public List<RelyingParty> enrichRelingParties(final List<RelingParties> childs) {
    return relyingPartyRepository.list(
        "select \"relying_party\".* from \"relying_party\" join \"tenant_relying_party\" on \"relying_party\".\"uid\" = \"tenant_relying_party\".\"relying_party\" "
            + " where \"tenant_relying_party\".\"uid\" in ( :availables )",
        Map.of("availables", SqlListParameterValue
            .strings(childs.stream().map(RelingParties::getUidValue).toList())));
  }

  /**
   * Retrieve one single value
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param childs
   * @return Retrieve one single value
   */
  public List<TrustedClient> enrichTrustedClients(final List<TrustedClients> childs) {
    return trustedClientRepository.list(
        "select \"trusted_client\".* from \"trusted_client\" join \"tenant_trusted_client\" on \"trusted_client\".\"uid\" = \"tenant_trusted_client\".\"trusted_client\" "
            + " where \"tenant_trusted_client\".\"uid\" in ( :availables )",
        Map.of("availables", SqlListParameterValue
            .strings(childs.stream().map(TrustedClients::getUidValue).toList())));
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public boolean exists(String uid, Optional<TenantFilter> filter) {
    return retrieve(uid, filter).isPresent();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public boolean existsForUpdate(String uid, Optional<TenantFilter> filter) {
    return retrieveForUpdate(uid, filter).isPresent();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public Optional<Tenant> find(TenantFilter filter) {
    TenantCursor cursor = TenantCursor.builder().build();
    return new TenantSlider(runList(filter, cursor), cursor.getLimit().orElse(0), this::runList,
        filter, cursor).one();
  }

  /**
   * sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public Optional<Tenant> find(final String sql, final Map<String, SqlParameterValue> params) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<Tenant> createSqlQuery = template.createSqlQuery(sql);
      withChilds(createSqlQuery);
      params.forEach(createSqlQuery::with);
      return createSqlQuery.query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public Optional<Tenant> findForUpdate(TenantFilter filter) {
    TenantCursor cursor = TenantCursor.builder().build();
    return new TenantSlider(runListForUpdate(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor).one();
  }

  /**
   * sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public Optional<Tenant> findForUpdate(final String sql,
      final Map<String, SqlParameterValue> params) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<Tenant> createSqlQuery = template.createSqlQuery(sql);
      withChilds(createSqlQuery);
      params.forEach(createSqlQuery::with);
      return createSqlQuery.forUpdate().query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public List<Tenant> list(TenantFilter filter) {
    TenantCursor cursor = TenantCursor.builder().build();
    return new TenantSlider(runList(filter, cursor), cursor.getLimit().orElse(0), this::runList,
        filter, cursor).all();
  }

  /**
   * sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<Tenant> list(final String sql, final Map<String, SqlParameterValue> params) {
    return list(sql, params, null, false);
  }

  /**
   * sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<Tenant> list(final String sql, final Map<String, SqlParameterValue> params,
      final int limit) {
    return list(sql, params, Integer.valueOf(limit), false);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @return
   */
  public List<Tenant> listForUpdate(TenantFilter filter) {
    TenantCursor cursor = TenantCursor.builder().build();
    return new TenantSlider(runListForUpdate(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor).all();
  }

  /**
   * sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<Tenant> listForUpdate(final String sql, final Map<String, SqlParameterValue> params) {
    return list(sql, params, null, true);
  }

  /**
   * sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  public List<Tenant> listForUpdate(final String sql, final Map<String, SqlParameterValue> params,
      final int limit) {
    return list(sql, params, Integer.valueOf(limit), true);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public Optional<Tenant> retrieve(String uid, Optional<TenantFilter> filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      TenantFilter readyFilter = filter.map(val -> val.withUid(uid))
          .orElseGet(() -> TenantFilter.builder().uid(uid).build());
      SqlSchematicQuery<Tenant> sq = filteredQuery(template, readyFilter);
      return sq.query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param uid
   * @param filter
   * @return
   */
  public Optional<Tenant> retrieveForUpdate(String uid, Optional<TenantFilter> filter) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      TenantFilter readyFilter = filter.map(val -> val.withUid(uid))
          .orElseGet(() -> TenantFilter.builder().uid(uid).build());
      SqlSchematicQuery<Tenant> sq = filteredQuery(template, readyFilter);
      return sq.forUpdate().query(converter()).one();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  public Slider<Tenant> slide(TenantFilter filter, TenantCursor cursor) {
    return new TenantSlider(runList(filter, cursor), cursor.getLimit().orElse(0), this::runList,
        filter, cursor);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  public Slider<Tenant> slideForUpdate(TenantFilter filter, TenantCursor cursor) {
    return new TenantSlider(runListForUpdate(filter, cursor), cursor.getLimit().orElse(0),
        this::runList, filter, cursor);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @return
   */
  public Tenant update(Tenant entity) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlCommand sq = template.createSqlCommand(
          "update \"tenant\" set  \"name\" = :name, \"domain\" = :domain, \"enabled\" = :enabled, \"access_to_all_applications\" = :accessToAllApplications, \"version\" = \"version\" + 1 where \"uid\" = :uid and \"version\" = :version");
      sq.with(UID, SqlParameterValue.of(entity.getUid().getValue()));
      sq.with(NAME, SqlParameterValue.of(entity.getName().getValue()));
      sq.with(DOMAIN, SqlParameterValue.of(entity.getDomain().getValue()));
      sq.with(ENABLED, SqlParameterValue.of(entity.getEnabled().getValue()));
      sq.with(ACCESS_TO_ALL_APPLICATIONS, entity.getAccessToAllApplications().getValue()
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullBoolean));
      sq.with(VERSION, entity.getVersion().getValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      int num = sq.execute();
      if (0 == num) {
        throw new OptimistLockException("No delete from");
      }
      Tenant result = entity.nextVersion();
      saveTrustedClients(result, result.getTrustedClients().getValue());
      saveRelingParties(result, result.getRelingParties().getValue());
      return result;
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sq
   * @param cursor
   */
  private void attachWithOrder(SqlSchematicQuery<Tenant> sq, TenantCursor cursor) {
    PartialWhere[] offset = new PartialWhere[] {PartialWhere.empty(), PartialWhere.empty()};
    for (TenantOrder order : cursor.getOrder()) {
      tryToOrderByNameAsc(sq, offset, cursor, order);
      tryToOrderByNameDesc(sq, offset, cursor, order);
    }
    Optional<String> sinceUid = cursor.getSinceUid();
    if (sinceUid.isPresent()) {
      offset[0] = PartialWhere.or(offset[0], PartialWhere.and(offset[1],
          PartialWhere.where("uid", SqlOperator.GT, SqlParameterValue.of(sinceUid.get()))));
    }
    sq.where(offset[0]);
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @return
   */
  private SqlConverter<Tenant> converter() {
    return row -> {
      try {
        List<TrustedClients> trustedClientsFromChilds = new ArrayList<>();
        row.<TrustedClients>getChilds("trustedClients")
            .whenComplete((childlist, fail) -> trustedClientsFromChilds.addAll(childlist));
        List<RelingParties> relingPartiesFromChilds = new ArrayList<>();
        row.<RelingParties>getChilds("relingParties")
            .whenComplete((childlist, fail) -> relingPartiesFromChilds.addAll(childlist));
        return Optional.of(Tenant.builder().uid(UidVO.from(row.getString(UID)))
            .name(NameVO.from(row.getString(NAME))).domain(DomainVO.from(row.getString(DOMAIN)))
            .enabled(EnabledVO.from(row.getBoolean(ENABLED)))
            .accessToAllApplications(
                AccessToAllApplicationsVO.from(row.getBoolean(ACCESS_TO_ALL_APPLICATIONS_SNAKE)))
            .trustedClients(TrustedClientsVO.from(trustedClientsFromChilds))
            .relingParties(RelingPartiesVO.from(relingPartiesFromChilds))
            .version(VersionVO.from(row.getInt(VERSION))).build());
      } catch (ConstraintException ce) {
        log.error("Unable to map data for {}", row.getString(1), ce);
        return Optional.empty();
      }
    };
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param template
   */
  private void deleteRelingParties(Tenant entity, SqlTemplate template) {
    SqlCommand sq = template
        .createSqlCommand("delete from \"tenant_relying_party\" where \"tenant\" = :tenant");
    sq.with(TENANT, SqlParameterValue.of(entity.getUidValue()));
    sq.execute();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param template
   */
  private void deleteTrustedClients(Tenant entity, SqlTemplate template) {
    SqlCommand sq = template
        .createSqlCommand("delete from \"tenant_trusted_client\" where \"tenant\" = :tenant");
    sq.with(TENANT, SqlParameterValue.of(entity.getUidValue()));
    sq.execute();
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param template
   * @param filter
   * @return
   */
  private <T> SqlSchematicQuery<T> filteredQuery(SqlTemplate template, TenantFilter filter) {
    SqlSchematicQuery<T> sq = template.createSqlSchematicQuery(TENANT);
    sq.selectFields(TENANT_UID, TENANT_NAME, TENANT_DOMAIN, TENANT_ENABLED,
        TENANT_ACCESS_TO_ALL_APPLICATIONS, TENANT_VERSION);
    withChilds(sq);
    filter.getUid().ifPresent(uid -> sq.where(UID, SqlOperator.EQ, SqlParameterValue.of(uid)));
    if (!filter.getUids().isEmpty()) {
      sq.where(UID, SqlOperator.IN, SqlListParameterValue.strings(filter.getUids()));
    }
    filter.getSearch().ifPresent(
        search -> sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%")));
    filter.getName().ifPresent(name -> sq.where(NAME, SqlOperator.EQ, SqlParameterValue.of(name)));
    filter.getTenantAccesible().ifPresent(
        tenantAccesible -> sq.where(UID, SqlOperator.EQ, SqlParameterValue.of(tenantAccesible)));
    return sq;
  }

  /**
   * sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   *
   * @autogenerated RepositoryJdbcGenerator
   * @param sql
   * @param params
   * @param limit
   * @param forUpdate
   * @return sq.where("name", SqlOperator.LIKE, SqlParameterValue.of("%" + search + "%"))
   */
  private List<Tenant> list(final String sql, final Map<String, SqlParameterValue> params,
      final Integer limit, final boolean forUpdate) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<Tenant> createSqlQuery = template.createSqlQuery(sql);
      withChilds(createSqlQuery);
      params.forEach(createSqlQuery::with);
      if (forUpdate) {
        createSqlQuery = createSqlQuery.forUpdate();
      }
      SqlResult<Tenant> query = createSqlQuery.query(converter());
      return null == limit ? query.all() : query.limit(limit);
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param verifier
   * @return
   */
  private Tenant runCreate(Tenant entity, Predicate<Tenant> verifier) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlCommand sq = template.createSqlCommand(
          "insert into \"tenant\" ( \"uid\", \"name\", \"domain\", \"enabled\", \"access_to_all_applications\", \"version\") values ( :uid, :name, :domain, :enabled, :accessToAllApplications, :version)");
      sq.with(UID, SqlParameterValue.of(entity.getUid().getValue()));
      sq.with(NAME, SqlParameterValue.of(entity.getName().getValue()));
      sq.with(DOMAIN, SqlParameterValue.of(entity.getDomain().getValue()));
      sq.with(ENABLED, SqlParameterValue.of(entity.getEnabled().getValue()));
      sq.with(ACCESS_TO_ALL_APPLICATIONS, entity.getAccessToAllApplications().getValue()
          .map(SqlParameterValue::of).orElseGet(SqlParameterValue::ofNullBoolean));
      sq.with(VERSION, entity.getVersion().getValue().map(SqlParameterValue::of)
          .orElseGet(SqlParameterValue::ofNullInteger));
      int num = sq.execute();
      if (0 == num) {
        throw new IllegalArgumentException("No insert into");
      }
      Tenant result = verifier == null ? entity : verified(verifier.test(entity), entity, template);
      result = saveTrustedClients(result, result.getTrustedClients().getValue());
      result = saveRelingParties(result, result.getRelingParties().getValue());
      return result;
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  private Iterator<Tenant> runList(TenantFilter filter, TenantCursor cursor) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<Tenant> sq = filteredQuery(template, filter);
      if (null != cursor.getOrder()) {
        attachWithOrder(sq, cursor);
      } else {
        cursor.getSinceUid()
            .ifPresent(since -> sq.where(UID, SqlOperator.GT, SqlParameterValue.of(since)));
      }
      sq.orderAsc("uid");
      return sq.query(converter()).limit(cursor.getLimit()).iterator();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param filter
   * @param cursor
   * @return
   */
  private Iterator<Tenant> runListForUpdate(TenantFilter filter, TenantCursor cursor) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlSchematicQuery<Tenant> sq = filteredQuery(template, filter);
      if (null != cursor.getOrder()) {
        attachWithOrder(sq, cursor);
      } else {
        cursor.getSinceUid()
            .ifPresent(since -> sq.where(UID, SqlOperator.GT, SqlParameterValue.of(since)));
      }
      sq.orderAsc("uid");
      return sq.forUpdate().query(converter()).limit(cursor.getLimit()).iterator();
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param childs
   * @return
   */
  private Tenant saveRelingParties(Tenant entity, List<RelingParties> childs) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<Object[]> sq = template.createSqlQuery(
          "select \"uid\", \"tenant\" from \"tenant_relying_party\" where (\"tenant\" = :tenant)"
              + " or ( \"uid\" in (:tomap) and \"tenant\" != :tenant )");
      sq.with(TENANT, SqlParameterValue.of(entity.getUidValue()));
      sq.with(TOMAP,
          SqlListParameterValue.strings(childs.stream().map(RelingParties::getUidValue).toList()));
      List<Object[]> list =
          sq.query(row -> Optional.of(new Object[] {row.getString(1), row.getString(2)})).all();
      if (list.stream().anyMatch(arr -> !entity.getUidValue().equals(arr[1]))) {
        throw new IllegalArgumentException("Try to move from another parent");
      }
      List<RelingParties> response = new ArrayList<>();
      List<String> codes = new ArrayList<>(list.stream().map(arr -> (String) arr[0]).toList());
      childs.forEach(child -> codes.remove(child.getUidValue()));
      if (!codes.isEmpty()) {
        SqlCommand deleted = template
            .createSqlCommand("delete from\"tenant_relying_party\" where \"uid\" in (:codes)");
        deleted.with("codes", SqlListParameterValue.strings(codes));
        deleted.execute();
      }
      childs.forEach(child -> {
        SqlCommand command = template.createSqlCommand(codes.contains(child.getUidValue())
            ? "update \"tenant_relying_party\" set \"verify\" = :verify, \"medal\" = :medal, \"version\" = \"version\" + 1 where \"uid\" = :uid and \"version\" = :version"
            : "insert into \"tenant_relying_party\" ( \"uid\", \"tenant\", \"relying_party\", \"version\") values ( :uid, :tenant, :relyingParty, :version)");
        command.with(UID, SqlParameterValue.of(child.getUid().getValue()));
        command.with(TENANT, SqlParameterValue.of(entity.getUidValue()));
        command.with(RELYING_PARTY,
            SqlParameterValue.of(child.getRelyingParty().getReferenceValue()));
        command.with(VERSION, child.getVersion().getValue().map(SqlParameterValue::of)
            .orElseGet(SqlParameterValue::ofNullInteger));
        int val = command.execute();
        if (val != 1) {
          throw new OptimistLockException("No child processed");
        } else {
          response.add(child.withVersion(child.getVersionValue().orElse(0) + 1));
        }
      });
      // TODO: need to save througn entity RelingParties => RelingPartiesVO::from[ result ] ;
      return entity;
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param entity
   * @param childs
   * @return
   */
  private Tenant saveTrustedClients(Tenant entity, List<TrustedClients> childs) {
    try (SqlTemplate template = new SqlTemplate(datasource, tracer)) {
      SqlQuery<Object[]> sq = template.createSqlQuery(
          "select \"uid\", \"tenant\" from \"tenant_trusted_client\" where (\"tenant\" = :tenant)"
              + " or ( \"uid\" in (:tomap) and \"tenant\" != :tenant )");
      sq.with(TENANT, SqlParameterValue.of(entity.getUidValue()));
      sq.with(TOMAP,
          SqlListParameterValue.strings(childs.stream().map(TrustedClients::getUidValue).toList()));
      List<Object[]> list =
          sq.query(row -> Optional.of(new Object[] {row.getString(1), row.getString(2)})).all();
      if (list.stream().anyMatch(arr -> !entity.getUidValue().equals(arr[1]))) {
        throw new IllegalArgumentException("Try to move from another parent");
      }
      List<TrustedClients> response = new ArrayList<>();
      List<String> codes = new ArrayList<>(list.stream().map(arr -> (String) arr[0]).toList());
      childs.forEach(child -> codes.remove(child.getUidValue()));
      if (!codes.isEmpty()) {
        SqlCommand deleted = template
            .createSqlCommand("delete from\"tenant_trusted_client\" where \"uid\" in (:codes)");
        deleted.with("codes", SqlListParameterValue.strings(codes));
        deleted.execute();
      }
      childs.forEach(child -> {
        SqlCommand command = template.createSqlCommand(codes.contains(child.getUidValue())
            ? "update \"tenant_trusted_client\" set \"verify\" = :verify, \"medal\" = :medal, \"version\" = \"version\" + 1 where \"uid\" = :uid and \"version\" = :version"
            : "insert into \"tenant_trusted_client\" ( \"uid\", \"tenant\", \"trusted_client\", \"version\") values ( :uid, :tenant, :trustedClient, :version)");
        command.with(UID, SqlParameterValue.of(child.getUid().getValue()));
        command.with(TENANT, SqlParameterValue.of(entity.getUidValue()));
        command.with(TRUSTED_CLIENT,
            SqlParameterValue.of(child.getTrustedClient().getReferenceValue()));
        command.with(VERSION, child.getVersion().getValue().map(SqlParameterValue::of)
            .orElseGet(SqlParameterValue::ofNullInteger));
        int val = command.execute();
        if (val != 1) {
          throw new OptimistLockException("No child processed");
        } else {
          response.add(child.withVersion(child.getVersionValue().orElse(0) + 1));
        }
      });
      // TODO: need to save througn entity TrustedClients => TrustedClientsVO::from[ result ] ;
      return entity;
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sq
   * @param offset
   * @param cursor
   * @param order
   * @return
   */
  private PartialWhere[] tryToOrderByNameAsc(SqlSchematicQuery<Tenant> sq, PartialWhere[] offset,
      TenantCursor cursor, TenantOrder order) {
    if (order == TenantOrder.NAME_ASC) {
      sq.addOrderAsc("name");
      Optional<String> sinceName = cursor.getSinceName();
      if (sinceName.isPresent()) {
        String sinceNameValue = sinceName.get();
        offset[0] = PartialWhere.or(offset[0], PartialWhere.and(offset[1],
            PartialWhere.where("name", SqlOperator.GT, SqlParameterValue.of(sinceNameValue))));
        offset[1] = PartialWhere.and(offset[1],
            PartialWhere.where("name", SqlOperator.EQ, SqlParameterValue.of(sinceNameValue)));
      }
    }
    return offset;
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sq
   * @param offset
   * @param cursor
   * @param order
   * @return
   */
  private PartialWhere[] tryToOrderByNameDesc(SqlSchematicQuery<Tenant> sq, PartialWhere[] offset,
      TenantCursor cursor, TenantOrder order) {
    if (order == TenantOrder.NAME_DESC) {
      sq.addOrderDesc("name");
      Optional<String> sinceName = cursor.getSinceName();
      if (sinceName.isPresent()) {
        String sinceNameValue = sinceName.get();
        offset[0] = PartialWhere.or(offset[0], PartialWhere.and(offset[1],
            PartialWhere.where("name", SqlOperator.GT, SqlParameterValue.of(sinceNameValue))));
        offset[1] = PartialWhere.and(offset[1],
            PartialWhere.where("name", SqlOperator.EQ, SqlParameterValue.of(sinceNameValue)));
      }
    }
    return offset;
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param exists
   * @param entity
   * @param template
   * @return
   */
  private Tenant verified(boolean exists, Tenant entity, SqlTemplate template) {
    if (exists) {
      return entity;
    } else {
      template.createSqlCommand("delete from \"tenant\" where \"uid\" = :uid")
          .with("uid", SqlParameterValue.of(entity.getUidValue())).execute();
      throw new NotFoundException("");
    }
  }

  /**
   * @autogenerated RepositoryJdbcGenerator
   * @param sq
   */
  private void withChilds(AbstractSqlParametrized<?> sq) {
    sq.child(100, "trustedClients",
        "select \"tenant\",\"uid\",\"trusted_client\",\"version\" from \"tenant_trusted_client\"  where \"tenant\" in (:tenant)",
        "uid", "tenant", row -> {
          try {
            return Optional.of(TrustedClients.builder().uid(row.getString(UID))
                .trustedClient(row.getString(TRUSTED_CLIENT_SNAKE)).version(row.getInt(VERSION))
                .build());
          } catch (ConstraintException ce) {
            log.error("Unable to map trustedClients child data for {}", row.getString(2), ce);
            return Optional.empty();
          }
        });
    sq.child(100, "relingParties",
        "select \"tenant\",\"uid\",\"relying_party\",\"version\" from \"tenant_relying_party\"  where \"tenant\" in (:tenant)",
        "uid", "tenant", row -> {
          try {
            return Optional.of(RelingParties.builder().uid(row.getString(UID))
                .relyingParty(row.getString(RELYING_PARTY_SNAKE)).version(row.getInt(VERSION))
                .build());
          } catch (ConstraintException ce) {
            log.error("Unable to map relingParties child data for {}", row.getString(2), ce);
            return Optional.empty();
          }
        });
  }
}
