package net.civeira.phylax.features.access.tenant.application.visibility;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Event;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.common.exception.NotFoundException;
import net.civeira.phylax.common.security.Interaction;
import net.civeira.phylax.features.access.relyingparty.application.visibility.RelyingPartysVisibility;
import net.civeira.phylax.features.access.tenant.domain.Tenant;
import net.civeira.phylax.features.access.tenant.domain.TenantChangeSet;
import net.civeira.phylax.features.access.tenant.domain.TenantRef;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantCacheGateway;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantCached;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantCursor;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantFilter;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantReadRepositoryGateway;
import net.civeira.phylax.features.access.tenant.domain.gateway.TenantWriteRepositoryGateway;
import net.civeira.phylax.features.access.tenant.domain.valueobject.RelingPartiesVO;
import net.civeira.phylax.features.access.tenant.domain.valueobject.TrustedClientsVO;
import net.civeira.phylax.features.access.trustedclient.application.visibility.TrustedClientsVisibility;

@ApplicationScoped
@RequiredArgsConstructor
public class TenantsVisibility {

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final TenantCacheGateway cache;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<TenantVisibilityCheck> filterProposalEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<TenantFixedFieldsCheck> fixedFieldsEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<TenantAccesibleCheck> guardEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<TenantHiddenFieldsCheck> hiddenFieldsEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<TenantEntityEnrichment> presetEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final RelyingPartysVisibility relyingPartysVisibility;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final TenantReadRepositoryGateway tenantReadRepositoryGateway;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final TenantWriteRepositoryGateway tenantWriteRepositoryGateway;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final TrustedClientsVisibility trustedClientsVisibility;

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public boolean checkVisibility(Interaction prev, String uid) {
    return retrieveVisible(prev, uid).isPresent();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uids
   * @return The input entity with the copy values without hidden
   */
  public boolean checkVisibility(Interaction prev, List<String> uids) {
    return uids.size() == listVisibles(prev, TenantVisibilityFilter.builder().uids(uids).build(),
        TenantCursor.builder().build()).size();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   * @param original The source interaction
   * @return The input entity with the copy values without hidden
   */
  public TenantChangeSet copyWithFixed(Interaction prev, TenantChangeSet source, Tenant original) {
    TenantChangeSet withReferences = visiblesReferences(prev, source);
    fieldsToFix(prev, original).forEach(withReferences::unset);
    TenantEntityEnrichment proposal = TenantEntityEnrichment.builder().dto(withReferences)
        .interaction(prev).original(original).build();
    presetEmitter.fire(proposal);
    return proposal.getDto();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   * @return The input entity with the copy values without hidden
   */
  public TenantChangeSet copyWithFixed(Interaction prev, TenantChangeSet source) {
    TenantChangeSet withReferences = visiblesReferences(prev, source);
    fieldsToFix(prev).forEach(withReferences::unset);
    TenantEntityEnrichment proposal =
        TenantEntityEnrichment.builder().dto(withReferences).interaction(prev).build();
    presetEmitter.fire(proposal);
    return proposal.getDto();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param tenant
   * @return The input dto with hidden values
   */
  public TenantVisibleProjection copyWithHidden(Interaction prev, Tenant tenant) {
    TenantVisibleProjection target = new TenantVisibleProjection(tenant);
    fieldsToHide(prev, tenant).forEach(target::unset);
    return target;
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public long countVisibles(Interaction prev, TenantVisibilityFilter filter) {
    return tenantReadRepositoryGateway.count(applyPreVisibilityFilter(prev, filter));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @return initialsFixFields
   */
  public Set<String> fieldsToFix(Interaction prev) {
    Set<String> fields = new HashSet<>(fieldsToHide(prev));
    TenantFixedFieldsCheck proposal =
        TenantFixedFieldsCheck.builder().fields(fields).query(prev).build();
    fixedFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param tenant
   * @return initialsFixFields
   */
  public Set<String> fieldsToFix(Interaction prev, TenantRef tenant) {
    Set<String> fields = new HashSet<>(fieldsToHide(prev, tenant));
    TenantFixedFieldsCheck proposal =
        TenantFixedFieldsCheck.builder().fields(fields).tenant(tenant).query(prev).build();
    fixedFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @return initialsHideFields
   */
  public Set<String> fieldsToHide(Interaction prev) {
    Set<String> fields = new HashSet<>();
    TenantHiddenFieldsCheck proposal =
        TenantHiddenFieldsCheck.builder().fields(fields).query(prev).build();
    hiddenFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param tenant
   * @return initialsHideFields
   */
  public Set<String> fieldsToHide(Interaction prev, TenantRef tenant) {
    Set<String> fields = new HashSet<>(fieldsToHide(prev));
    TenantHiddenFieldsCheck proposal =
        TenantHiddenFieldsCheck.builder().fields(fields).tenant(tenant).query(prev).build();
    hiddenFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public TenantCached listCachedVisibles(Interaction prev, TenantVisibilityFilter filter,
      TenantCursor cursor) {
    TenantFilter visibleFilter = applyPreVisibilityFilter(prev, filter);
    return cache.retrieve(visibleFilter, cursor)
        .orElseGet(() -> cache.store(visibleFilter, cursor, listVisibles(prev, filter, cursor)));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public List<Tenant> listVisibles(Interaction prev, TenantVisibilityFilter filter,
      TenantCursor cursor) {
    return queryItems(prev, applyPreVisibilityFilter(prev, filter), cursor);
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public List<Tenant> listVisiblesForUpdate(Interaction prev, TenantVisibilityFilter filter,
      TenantCursor cursor) {
    return queryItemsForUpdate(prev, applyPreVisibilityFilter(prev, filter), cursor);
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public TenantCached retrieveCachedVisible(Interaction prev, String uid) {
    TenantCursor cursor = TenantCursor.builder().limit(1).build();
    TenantFilter visibleFilter =
        applyPreVisibilityFilter(prev, TenantVisibilityFilter.builder().uid(uid).build());
    return cache.retrieve(visibleFilter, cursor).orElseGet(() -> {
      List<Tenant> list =
          retrieveVisible(prev, uid).<List<Tenant>>map(List::of).orElseGet(List::of);
      return cache.store(visibleFilter, cursor, list);
    });
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public Optional<Tenant> retrieveVisible(Interaction prev, String uid) {
    TenantFilter filter =
        applyPreVisibilityFilter(prev, TenantVisibilityFilter.builder().uid(uid).build());
    return queryItem(prev, uid, filter);
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public Optional<Tenant> retrieveVisibleForUpdate(Interaction prev, String uid) {
    TenantFilter filter =
        applyPreVisibilityFilter(prev, TenantVisibilityFilter.builder().uid(uid).build());
    return queryItemForUpdate(prev, uid, filter);
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @return The self filter modified with the prepared values.
   */
  private TenantFilter applyPreVisibilityFilter(Interaction prev, TenantVisibilityFilter filter) {
    TenantVisibilityCheck proposal =
        TenantVisibilityCheck.builder().filter(filter).interaction(prev).build();
    filterProposalEmitter.fire(proposal);
    TenantVisibilityFilter modified = proposal.getFilter();
    return TenantFilter.builder().uid(modified.getUid().orElse(null))
        .uids(modified.getUids().stream().toList()).search(modified.getSearch().orElse(null))
        .name(modified.getName().orElse(null))
        .tenantAccesible(modified.getTenantAccesible().orElse(null)).build();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param tenantRef The source interaction
   * @return The input dto with hidden values
   */
  private boolean evaluatePostVisibility(Interaction prev, Tenant tenantRef) {
    TenantAccesibleCheck proposal =
        TenantAccesibleCheck.builder().visible(true).entity(tenantRef).interaction(prev).build();
    guardEmitter.fire(proposal);
    return Boolean.TRUE.equals(proposal.getVisible());
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @param filter The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private Optional<Tenant> queryItem(Interaction prev, String uid, TenantFilter filter) {
    return tenantReadRepositoryGateway.retrieve(uid, Optional.of(filter))
        .filter(values -> evaluatePostVisibility(prev, values));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @param filter The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private Optional<Tenant> queryItemForUpdate(Interaction prev, String uid, TenantFilter filter) {
    return tenantWriteRepositoryGateway.retrieveForUpdate(uid, Optional.of(filter))
        .filter(values -> evaluatePostVisibility(prev, values));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private List<Tenant> queryItems(Interaction prev, TenantFilter filter, TenantCursor cursor) {
    List<Tenant> list = new ArrayList<>();
    Iterator<Tenant> slide = tenantReadRepositoryGateway.slide(filter, cursor)
        .slide(values -> evaluatePostVisibility(prev, values));
    while (slide.hasNext()) {
      list.add(slide.next());
    }
    return list;
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private List<Tenant> queryItemsForUpdate(Interaction prev, TenantFilter filter,
      TenantCursor cursor) {
    List<Tenant> list = new ArrayList<>();
    Iterator<Tenant> slide = tenantWriteRepositoryGateway.slideForUpdate(filter, cursor)
        .slide(values -> evaluatePostVisibility(prev, values));
    while (slide.hasNext()) {
      list.add(slide.next());
    }
    return list;
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   * @return The input entity with the copy values without hidden
   */
  private TenantChangeSet visiblesReferences(Interaction prev, TenantChangeSet source) {
    visiblesReferencesFromTrustedClients(prev, source);
    visiblesReferencesFromRelingParties(prev, source);
    return source;
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   */
  private void visiblesReferencesFromRelingParties(Interaction prev, TenantChangeSet source) {
    source.getRelingParties().map(RelingPartiesVO::getRelingParties).ifPresent(collector -> {
      List<String> collectRelyingParty = new ArrayList<>();
      collector.forEach(item -> {
        if (null != item.getRelyingParty()) {
          String idRelyingParty = item.getRelyingPartyUid();
          if (!collectRelyingParty.contains(idRelyingParty)) {
            collectRelyingParty.add(idRelyingParty);
          }
        }
      });
      if (!collectRelyingParty.isEmpty()) {
        boolean visible = relyingPartysVisibility.checkVisibility(prev, collectRelyingParty);
        if (!visible) {
          throw new NotFoundException("No all relying party exists: " + collectRelyingParty);
        }
      }
    });
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   */
  private void visiblesReferencesFromTrustedClients(Interaction prev, TenantChangeSet source) {
    source.getTrustedClients().map(TrustedClientsVO::getTrustedClients).ifPresent(collector -> {
      List<String> collectTrustedClient = new ArrayList<>();
      collector.forEach(item -> {
        if (null != item.getTrustedClient()) {
          String idTrustedClient = item.getTrustedClientUid();
          if (!collectTrustedClient.contains(idTrustedClient)) {
            collectTrustedClient.add(idTrustedClient);
          }
        }
      });
      if (!collectTrustedClient.isEmpty()) {
        boolean visible = trustedClientsVisibility.checkVisibility(prev, collectTrustedClient);
        if (!visible) {
          throw new NotFoundException("No all trusted client exists: " + collectTrustedClient);
        }
      }
    });
  }
}
