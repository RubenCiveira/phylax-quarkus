package net.civeira.phylax.features.access.tenant.domain;

import lombok.NoArgsConstructor;
import lombok.experimental.Delegate;
import net.civeira.phylax.common.value.Uuid;
import net.civeira.phylax.features.access.tenant.domain.valueobject.DomainValueHolder;
import net.civeira.phylax.features.access.tenant.domain.valueobject.EnabledValueHolder;
import net.civeira.phylax.features.access.tenant.domain.valueobject.MarkForDeleteTimeValueHolder;
import net.civeira.phylax.features.access.tenant.domain.valueobject.MarkForDeleteValueHolder;
import net.civeira.phylax.features.access.tenant.domain.valueobject.NameValueHolder;
import net.civeira.phylax.features.access.tenant.domain.valueobject.RootValueHolder;
import net.civeira.phylax.features.access.tenant.domain.valueobject.UidValueHolder;
import net.civeira.phylax.features.access.tenant.domain.valueobject.VersionValueHolder;

/**
 * A dto transfer to hold tenant attribute values
 */
@NoArgsConstructor
public class TenantChangeSet {

  /**
   * A domain suffix to identify the account
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private DomainValueHolder<TenantChangeSet> domainValue = new DomainValueHolder<>(this);

  /**
   * The indicator to allow the account be used without deleting it
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private EnabledValueHolder<TenantChangeSet> enabledValue = new EnabledValueHolder<>(this);

  /**
   * A tenant mark for deleted will be deleted soon
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private MarkForDeleteTimeValueHolder<TenantChangeSet> markForDeleteTimeValue =
      new MarkForDeleteTimeValueHolder<>(this);

  /**
   * a tenant mark for deleted will be
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private MarkForDeleteValueHolder<TenantChangeSet> markForDeleteValue =
      new MarkForDeleteValueHolder<>(this);

  /**
   * The name to identify the account.
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private NameValueHolder<TenantChangeSet> nameValue = new NameValueHolder<>(this);

  /**
   * El root de tenant
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private RootValueHolder<TenantChangeSet> rootValue = new RootValueHolder<>(this);

  /**
   * A number to identify the db record
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private UidValueHolder<TenantChangeSet> uidValue = new UidValueHolder<>(this);

  /**
   * Campo con el n√∫mero de version de tenant para controlar bloqueos optimistas
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private VersionValueHolder<TenantChangeSet> versionValue = new VersionValueHolder<>(this);

  /**
   * @autogenerated EntityChangeSetGenerator
   * @return
   */
  public TenantChangeSet newUid() {
    return version(0).uid(Uuid.comb().toString());
  }

  /**
   * Unset a value by the property name. Unset values will no provide command change neither provide
   * information to the output context (hidden or readonly fields, or policy restrictions).
   *
   * @autogenerated EntityChangeSetGenerator
   * @param field The field name to unset.
   */
  public void unset(final String field) {
    uidValue.unsetUidIfMatches(field);
    nameValue.unsetNameIfMatches(field);
    rootValue.unsetRootIfMatches(field);
    domainValue.unsetDomainIfMatches(field);
    enabledValue.unsetEnabledIfMatches(field);
    markForDeleteValue.unsetMarkForDeleteIfMatches(field);
    markForDeleteTimeValue.unsetMarkForDeleteTimeIfMatches(field);
    versionValue.unsetVersionIfMatches(field);
  }
}
