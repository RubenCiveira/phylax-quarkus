package net.civeira.phylax.features.access.user.domain;

import lombok.NoArgsConstructor;
import lombok.experimental.Delegate;
import net.civeira.phylax.common.value.Uuid;
import net.civeira.phylax.features.access.user.domain.valueobject.ApproveValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.BlockedUntilValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.EmailValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.EnabledValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.NameValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.PasswordValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.ProviderValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.SecondFactorSeedValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.TemporalPasswordValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.TenantValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.UidValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.UseSecondFactorsValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.VersionValueHolder;
import net.civeira.phylax.features.access.user.domain.valueobject.WellcomeAtValueHolder;

/**
 * A dto transfer to hold user attribute values
 */
@NoArgsConstructor
public class UserChangeSet {

  /**
   * El approve de user
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private ApproveValueHolder<UserChangeSet> approveValue = new ApproveValueHolder<>(this);

  /**
   * A bloqued user cant login on the system, until these date. On his login attempst, hue will
   * recive a generic not allowed message.
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private BlockedUntilValueHolder<UserChangeSet> blockedUntilValue =
      new BlockedUntilValueHolder<>(this);

  /**
   * An optional email used to send notifications to the user
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private EmailValueHolder<UserChangeSet> emailValue = new EmailValueHolder<>(this);

  /**
   * A disabled user cant login on the system. On his login attempts, he will recive a specific warn
   * of his disabled account.
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private EnabledValueHolder<UserChangeSet> enabledValue = new EnabledValueHolder<>(this);

  /**
   * The user name to identify on the login screen
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private NameValueHolder<UserChangeSet> nameValue = new NameValueHolder<>(this);

  /**
   * If the user is not delegated, the phrasse to identify
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private PasswordValueHolder<UserChangeSet> passwordValue = new PasswordValueHolder<>(this);

  /**
   * Si se identificó con un proveedor, se marca con cual (aunque el provvedor cambie luego)
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private ProviderValueHolder<UserChangeSet> providerValue = new ProviderValueHolder<>(this);

  /**
   * the seed used to the otp login
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private SecondFactorSeedValueHolder<UserChangeSet> secondFactorSeedValue =
      new SecondFactorSeedValueHolder<>(this);

  /**
   * El temporal password de user
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private TemporalPasswordValueHolder<UserChangeSet> temporalPasswordValue =
      new TemporalPasswordValueHolder<>(this);

  /**
   * El tenant de user
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private TenantValueHolder<UserChangeSet> tenantValue = new TenantValueHolder<>(this);

  /**
   * A number to identify the db record
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private UidValueHolder<UserChangeSet> uidValue = new UidValueHolder<>(this);

  /**
   * If is true, the user has a otp to force mfa on login
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private UseSecondFactorsValueHolder<UserChangeSet> useSecondFactorsValue =
      new UseSecondFactorsValueHolder<>(this);

  /**
   * Campo con el número de version de user para controlar bloqueos optimistas
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private VersionValueHolder<UserChangeSet> versionValue = new VersionValueHolder<>(this);

  /**
   * The date when a wellcome email is send
   *
   * @autogenerated EntityChangeSetGenerator
   */
  @Delegate
  private WellcomeAtValueHolder<UserChangeSet> wellcomeAtValue = new WellcomeAtValueHolder<>(this);

  /**
   * @autogenerated EntityChangeSetGenerator
   * @return
   */
  public UserChangeSet newUid() {
    return version(0).uid(Uuid.comb().toString());
  }

  /**
   * Unset a value by the property name. Unset values will no provide command change neither provide
   * information to the output context (hidden or readonly fields, or policy restrictions).
   *
   * @autogenerated EntityChangeSetGenerator
   * @param field The field name to unset.
   */
  public void unset(final String field) {
    uidValue.unsetUidIfMatches(field);
    tenantValue.unsetTenantIfMatches(field);
    nameValue.unsetNameIfMatches(field);
    passwordValue.unsetPasswordIfMatches(field);
    emailValue.unsetEmailIfMatches(field);
    wellcomeAtValue.unsetWellcomeAtIfMatches(field);
    enabledValue.unsetEnabledIfMatches(field);
    approveValue.unsetApproveIfMatches(field);
    temporalPasswordValue.unsetTemporalPasswordIfMatches(field);
    useSecondFactorsValue.unsetUseSecondFactorsIfMatches(field);
    secondFactorSeedValue.unsetSecondFactorSeedIfMatches(field);
    blockedUntilValue.unsetBlockedUntilIfMatches(field);
    providerValue.unsetProviderIfMatches(field);
    versionValue.unsetVersionIfMatches(field);
  }
}
