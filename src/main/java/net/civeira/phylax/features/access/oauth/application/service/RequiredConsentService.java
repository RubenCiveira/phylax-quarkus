/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.service;

import java.time.OffsetDateTime;
import java.util.Optional;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.features.access.tenant.domain.TenantRef;
import net.civeira.phylax.features.access.tenanttermsofuse.domain.TenantTermsOfUse;
import net.civeira.phylax.features.access.tenanttermsofuse.domain.TenantTermsOfUseReference;
import net.civeira.phylax.features.access.tenanttermsofuse.domain.gateway.TenantTermsOfUseFilter;
import net.civeira.phylax.features.access.tenanttermsofuse.domain.gateway.TenantTermsOfUseReadRepositoryGateway;
import net.civeira.phylax.features.access.user.domain.User;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.UserAcceptedTermnsOfUse;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.UserAcceptedTermnsOfUseChangeSet;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.gateway.UserAcceptedTermnsOfUseFilter;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.gateway.UserAcceptedTermnsOfUseReadRepositoryGateway;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.gateway.UserAcceptedTermnsOfUseWriteRepositoryGateway;

@ApplicationScoped
@RequiredArgsConstructor
public class RequiredConsentService {

  private final TenantTermsOfUseReadRepositoryGateway terms;

  private final UserAcceptedTermnsOfUseReadRepositoryGateway userTerms;

  private final UserAcceptedTermnsOfUseWriteRepositoryGateway userTermsWriter;

  public Optional<TenantTermsOfUse> findPendingTerms(User user) {
    Optional<TenantRef> optionalTenant = user.getTenant();
    if (optionalTenant.isPresent()) {
      TenantRef tenantRef = optionalTenant.get();
      Optional<TenantTermsOfUse> find =
          terms.list(TenantTermsOfUseFilter.builder().tenant(tenantRef).build()).stream()
              .filter(term -> term.getActivationDate().map(d -> d.isBefore(OffsetDateTime.now()))
                  .orElse(false))
              .sorted((a, b) -> a.getActivationDate().orElseThrow()
                  .compareTo(b.getActivationDate().orElseThrow()))
              .findFirst();
      if (find.isPresent()) {
        TenantTermsOfUse conditions = find.get();
        Optional<OffsetDateTime> activationDateValue = conditions.getActivationDate();
        if (activationDateValue.isPresent()
            && activationDateValue.get().isBefore(OffsetDateTime.now())) {
          Optional<UserAcceptedTermnsOfUse> accepted = userTerms.find(
              UserAcceptedTermnsOfUseFilter.builder().conditions(conditions).user(user).build());
          if (!accepted.isPresent()) {
            return Optional.of(conditions);
          }
        }
      }
    }
    return Optional.empty();
  }

  public void acceptPendingTerms(User user, String conditionsUid) {
    userTermsWriter.create(UserAcceptedTermnsOfUse.create(UserAcceptedTermnsOfUseChangeSet.builder()
        .newUid().user(user).conditions(TenantTermsOfUseReference.of(conditionsUid))
        .acceptDate(OffsetDateTime.now()).build()));
  }
}
