/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.service;

import java.time.OffsetDateTime;
import java.util.Optional;

import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.features.access.tenant.domain.TenantRef;
import net.civeira.phylax.features.access.tenanttermsofuse.domain.TenantTermsOfUse;
import net.civeira.phylax.features.access.tenanttermsofuse.domain.TenantTermsOfUseReference;
import net.civeira.phylax.features.access.tenanttermsofuse.domain.gateway.TenantTermsOfUseFilter;
import net.civeira.phylax.features.access.tenanttermsofuse.domain.gateway.TenantTermsOfUseReadRepositoryGateway;
import net.civeira.phylax.features.access.user.domain.User;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.UserAcceptedTermnsOfUse;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.UserAcceptedTermnsOfUseChangeSet;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.gateway.UserAcceptedTermnsOfUseFilter;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.gateway.UserAcceptedTermnsOfUseReadRepositoryGateway;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.domain.gateway.UserAcceptedTermnsOfUseWriteRepositoryGateway;

@ApplicationScoped
@RequiredArgsConstructor
public class RequiredConsentService {

  private final TenantTermsOfUseReadRepositoryGateway terms;

  private final UserAcceptedTermnsOfUseReadRepositoryGateway userTerms;

  private final UserAcceptedTermnsOfUseWriteRepositoryGateway userTermsWriter;

  public Optional<TenantTermsOfUse> findPendingTerms(User user) {
    TenantRef tenantRef = user.getTenant();
    Optional<TenantTermsOfUse> find =
        terms.list(TenantTermsOfUseFilter.builder().tenant(tenantRef).build()).stream()
            .filter(term -> term.getActivationDate().map(d -> d.isBefore(OffsetDateTime.now()))
                .orElse(false))
            .sorted((a, b) -> a.getActivationDate().orElseThrow()
                .compareTo(b.getActivationDate().orElseThrow()))
            .findFirst();
    if (find.isPresent()) {
      TenantTermsOfUse conditions = find.get();
      Optional<OffsetDateTime> activationDateValue = conditions.getActivationDate();
      if (activationDateValue.isPresent()
          && activationDateValue.get().isBefore(OffsetDateTime.now())) {
        Optional<UserAcceptedTermnsOfUse> accepted = userTerms.find(
            UserAcceptedTermnsOfUseFilter.builder().conditions(conditions).user(user).build());
        if (!accepted.isPresent()) {
          return Optional.of(conditions);
        }
      }
    }
    return Optional.empty();
  }

  public void acceptPendingTerms(User user, String conditionsUid) {
    userTermsWriter.create(UserAcceptedTermnsOfUse.create(new UserAcceptedTermnsOfUseChangeSet()
        .newUid().user(user).conditions(TenantTermsOfUseReference.of(conditionsUid))
        .acceptDate(OffsetDateTime.now())));
  }
}
