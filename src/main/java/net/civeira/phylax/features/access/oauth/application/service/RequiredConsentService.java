/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.service;

import java.time.OffsetDateTime;
import java.util.Optional;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.features.access.tenant.TenantRef;
import net.civeira.phylax.features.access.tenanttermsofuse.TenantTermsOfUse;
import net.civeira.phylax.features.access.tenanttermsofuse.TenantTermsOfUseReference;
import net.civeira.phylax.features.access.tenanttermsofuse.gateway.TenantTermsOfUseReadRepositoryGateway;
import net.civeira.phylax.features.access.tenanttermsofuse.query.TenantTermsOfUseFilter;
import net.civeira.phylax.features.access.user.User;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.UserAcceptedTermnsOfUse;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.UserAcceptedTermnsOfUseFacade;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.command.UserAcceptedTermnsOfUseChangeProposal;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.gateway.UserAcceptedTermnsOfUseReadRepositoryGateway;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.gateway.UserAcceptedTermnsOfUseWriteRepositoryGateway;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.query.UserAcceptedTermnsOfUseFilter;

@ApplicationScoped
@RequiredArgsConstructor
public class RequiredConsentService {

  private final TenantTermsOfUseReadRepositoryGateway terms;

  private final UserAcceptedTermnsOfUseReadRepositoryGateway userTerms;

  private final UserAcceptedTermnsOfUseFacade termsFacade;

  private final UserAcceptedTermnsOfUseWriteRepositoryGateway userTermsWriter;

  public Optional<TenantTermsOfUse> findPendingTerms(User user) {
    Optional<TenantRef> optionalTenant = user.getTenantValue();
    if (optionalTenant.isPresent()) {
      TenantRef tenantRef = optionalTenant.get();
      Optional<TenantTermsOfUse> find =
          terms.list(TenantTermsOfUseFilter.builder().tenant(tenantRef).build()).stream()
              .filter(term -> term.getActivationDateValue()
                  .map(d -> d.isBefore(OffsetDateTime.now())).orElse(false))
              .sorted((a, b) -> a.getActivationDateValue().orElseThrow()
                  .compareTo(b.getActivationDateValue().orElseThrow()))
              .findFirst();
      if (find.isPresent()) {
        TenantTermsOfUse conditions = find.get();
        Optional<OffsetDateTime> activationDateValue = conditions.getActivationDateValue();
        if (activationDateValue.isPresent()
            && activationDateValue.get().isBefore(OffsetDateTime.now())) {
          Optional<UserAcceptedTermnsOfUse> accepted = userTerms.find(
              UserAcceptedTermnsOfUseFilter.builder().conditions(conditions).user(user).build());
          if (!accepted.isPresent()) {
            return Optional.of(conditions);
          }
        }
      }
    }
    return Optional.empty();
  }

  public void acceptPendingTerms(User user, String conditionsUid) {
    userTermsWriter.create(termsFacade.create(UserAcceptedTermnsOfUseChangeProposal.builder()
        .newUid().user(user).conditions(TenantTermsOfUseReference.of(conditionsUid))
        .acceptDate(OffsetDateTime.now()).build()));
  }
}
