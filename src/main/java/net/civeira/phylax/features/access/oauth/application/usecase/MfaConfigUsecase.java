/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.usecase;

import java.time.Duration;
import java.time.OffsetDateTime;
import java.time.temporal.TemporalAmount;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import jakarta.activation.DataSource;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.features.access.oauth.application.service.ActiveUserFindService;
import net.civeira.phylax.features.access.oauth.application.service.OtpMfaService;
import net.civeira.phylax.features.access.oauth.application.service.OtpMfaService.ApplicationInfo;
import net.civeira.phylax.features.access.user.domain.gateway.UserWriteRepositoryGateway;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.UserAccessTemporalCode;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.UserAccessTemporalCodeChangeSet;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.gateway.UserAccessTemporalCodeFilter;
import net.civeira.phylax.features.access.useraccesstemporalcode.domain.gateway.UserAccessTemporalCodeWriteRepositoryGateway;

@Slf4j
@ApplicationScoped
@RequiredArgsConstructor
public class MfaConfigUsecase {
  private final static TemporalAmount EXPIRATION_TIME = Duration.ofHours(6);

  private final OtpMfaService otp;
  private final ActiveUserFindService finder;
//  private final UserFacade userFacade;
  private final UserWriteRepositoryGateway users;
//  private final UserAccessTemporalCodeFacade codeFacade;
  private final UserAccessTemporalCodeWriteRepositoryGateway codes;
  private final AesCipherService cypher;

  public Optional<DataSource> configQr(String tenant, String username, List<String> audiences,
      Locale locale) {
    return finder.findEnabledUser(tenant, username, audiences).map(user -> {
      Optional<UserAccessTemporalCode> find =
          codes.findForUpdate(UserAccessTemporalCodeFilter.builder().user(user).build());
      Optional<String> prev = find
          .filter(code -> code.getTempSecondFactorSeedExpiration()
              .map(date -> date.isAfter(OffsetDateTime.now())).orElse(false))
          .flatMap(code -> code.getCypheredTempSecondFactorSeed(cypher));
      if (prev.isPresent()) {
        return otp.getQr(
            ApplicationInfo.builder().label(user.getName() + " at ").issuer("no").build(),
            prev.get());
      } else {
        return otp.getQr(
            ApplicationInfo.builder().label(user.getName() + " at ").issuer("no").build(),
            secret -> {
              UserAccessTemporalCode code;
              if (find.isPresent()) {
                code = find.get();
              } else {
                code = codes.create(UserAccessTemporalCode.create(
                    UserAccessTemporalCodeChangeSet.builder().newUid().user(user).build()));
              }
              codes.update(code, code.generateMfaTemporalCode(secret,
                  OffsetDateTime.now().plus(EXPIRATION_TIME)));
            });
      }
    });
  }

  public boolean validateOtp(String tenant, String username, List<String> audiences, String code) {
    return finder.findEnabledUser(tenant, username, audiences).map(user -> {
      Optional<String> find = user.getCypheredSecondFactorSeed(cypher);
      if (find.isPresent()) {
        String seed = find.get();
        return otp.validateOtp(code, seed);
      } else {
        log.error("There is no temp second factor seed to config validate");
        return false;
      }
    }).orElse(false);
  }

  public boolean validateOtpConfig(String tenant, String username, List<String> audiences,
      String code) {
    return finder.findEnabledUser(tenant, username, audiences).map(user -> {
      Optional<UserAccessTemporalCode> find =
          codes.findForUpdate(UserAccessTemporalCodeFilter.builder().user(user).build());
      Optional<String> prev = find
          .filter(temps -> temps.getTempSecondFactorSeedExpiration()
              .map(date -> date.isAfter(OffsetDateTime.now())).orElse(false))
          .flatMap(second -> second.getCypheredTempSecondFactorSeed(cypher));
      if (prev.isPresent()) {
        String seed = prev.get();
        boolean valid = otp.validateOtp(code, seed);
        if (valid) {
          if (find.isPresent()) {
            UserAccessTemporalCode temps = find.get();
            codes.update(temps, temps.resetMfaTemporalCode());
            users.update(user, user.setMfaSeed(
                temps.getPlainTempSecondFactorSeed(cypher).orElseThrow()));
          } else {
            log.error("We have a part but not the hole item");
            throw new IllegalStateException("");
          }
        }
        return valid;
      } else {
        log.error("There is no temp second factor seed to config validate");
        return false;
      }
    }).orElse(false);
  }
}
