/* @autogenerated */
package net.civeira.phylax.features.access.oauth.application.usecase;

import java.time.Duration;
import java.time.OffsetDateTime;
import java.time.temporal.TemporalAmount;
import java.util.List;
import java.util.Locale;
import java.util.Optional;

import jakarta.activation.DataSource;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.features.access.oauth.application.service.ActiveUserFindService;
import net.civeira.phylax.features.access.oauth.application.service.OtpMfaService;
import net.civeira.phylax.features.access.oauth.application.service.OtpMfaService.ApplicationInfo;
import net.civeira.phylax.features.access.user.UserFacade;
import net.civeira.phylax.features.access.user.gateway.UserWriteRepositoryGateway;
import net.civeira.phylax.features.access.useraccesstemporalcode.UserAccessTemporalCode;
import net.civeira.phylax.features.access.useraccesstemporalcode.UserAccessTemporalCodeFacade;
import net.civeira.phylax.features.access.useraccesstemporalcode.command.UserAccessTemporalCodeChangeProposal;
import net.civeira.phylax.features.access.useraccesstemporalcode.gateway.UserAccessTemporalCodeWriteRepositoryGateway;
import net.civeira.phylax.features.access.useraccesstemporalcode.query.UserAccessTemporalCodeFilter;

@Slf4j
@ApplicationScoped
@RequiredArgsConstructor
public class MfaConfigUsecase {
  private final static TemporalAmount EXPIRATION_TIME = Duration.ofHours(6);

  private final OtpMfaService otp;
  private final ActiveUserFindService finder;
  private final UserFacade userFacade;
  private final UserWriteRepositoryGateway users;
  private final UserAccessTemporalCodeFacade codeFacade;
  private final UserAccessTemporalCodeWriteRepositoryGateway codes;
  private final AesCipherService cypher;

  public Optional<DataSource> configQr(String tenant, String username, List<String> audiences,
      Locale locale) {
    return finder.findEnabledUser(tenant, username, audiences).map(user -> {
      Optional<UserAccessTemporalCode> find =
          codes.findForUpdate(UserAccessTemporalCodeFilter.builder().user(user).build());
      Optional<String> prev = find
          .filter(code -> code.getTempSecondFactorSeedExpirationValue()
              .map(date -> date.isAfter(OffsetDateTime.now())).orElse(false))
          .flatMap(code -> code.getTempSecondFactorSeedCypheredValue(cypher));
      if (prev.isPresent()) {
        return otp.getQr(
            ApplicationInfo.builder().label(user.getName() + " at ").issuer("no").build(),
            prev.get());
      } else {
        return otp.getQr(
            ApplicationInfo.builder().label(user.getName() + " at ").issuer("no").build(),
            secret -> {
              UserAccessTemporalCode code;
              if (find.isPresent()) {
                code = find.get();
              } else {
                code = codes.create(codeFacade.create(
                    UserAccessTemporalCodeChangeProposal.builder().newUid().user(user).build()));
              }
              codes.update(code, codeFacade.generateMfaTemporalCode(code, secret,
                  OffsetDateTime.now().plus(EXPIRATION_TIME)));
              // if (find.isPresent()) {
              // UserAccessTemporalCode code = find.get();
              // codes.update(code,
              // code.toBuilder().cypheredTempSecondFactorSeed(cypher.encryptForAll(secret))
              // .tempSecondFactorSeedExpiration(OffsetDateTime.now().plus(EXPIRATION_TIME))
              // .build());
              // } else {
              // codes.create(UserAccessTemporalCode.builder().newUid().user(user)
              // .cypheredTempSecondFactorSeed(cypher.encryptForAll(secret))
              // .tempSecondFactorSeedExpiration(OffsetDateTime.now().plus(EXPIRATION_TIME))
              // .build());
              // }
            });
      }
    });
  }

  public boolean validateOtp(String tenant, String username, List<String> audiences, String code) {
    return finder.findEnabledUser(tenant, username, audiences).map(user -> {
      Optional<String> find = user.getSecondFactorSeedCypheredValue(cypher);
      if (find.isPresent()) {
        String seed = find.get();
        return otp.validateOtp(code, seed);
      } else {
        log.error("There is no temp second factor seed to config validate");
        return false;
      }
    }).orElse(false);
  }

  public boolean validateOtpConfig(String tenant, String username, List<String> audiences,
      String code) {
    return finder.findEnabledUser(tenant, username, audiences).map(user -> {
      Optional<UserAccessTemporalCode> find =
          codes.findForUpdate(UserAccessTemporalCodeFilter.builder().user(user).build());
      Optional<String> prev = find
          .filter(temps -> temps.getTempSecondFactorSeedExpirationValue()
              .map(date -> date.isAfter(OffsetDateTime.now())).orElse(false))
          .flatMap(second -> second.getTempSecondFactorSeedCypheredValue(cypher));
      if (prev.isPresent()) {
        String seed = prev.get();
        boolean valid = otp.validateOtp(code, seed);
        if (valid) {
          if (find.isPresent()) {
            UserAccessTemporalCode temps = find.get();
            codes.update(temps, codeFacade.resetMfaTemporalCode(temps));
            // codes.update(temps, temps.toBuilder().nullTempSecondFactorSeed()
            // .nullTempSecondFactorSeedExpiration().build());
            users.update(user, userFacade.setMfaSeed(user,
                temps.getTempSecondFactorSeedPlainValue(cypher).orElseThrow()));
            // users
            // .update(user,
            // user.toBuilder().useSecondFactors(Boolean.TRUE)
            // .cypheredSecondFactorSeed(
            // temps.getTempSecondFactorSeedCypheredValue(cypher).orElseThrow())
            // .build());
          } else {
            log.error("We have a part but not the hole item");
            throw new IllegalStateException("");
          }
        }
        return valid;
      } else {
        log.error("There is no temp second factor seed to config validate");
        return false;
      }
    }).orElse(false);
  }
}
