package net.civeira.phylax.features.access.useridentity.application.visibility;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Event;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.common.exception.NotFoundException;
import net.civeira.phylax.common.security.Interaction;
import net.civeira.phylax.features.access.relyingparty.application.visibility.RelyingPartysVisibility;
import net.civeira.phylax.features.access.role.application.visibility.RolesVisibility;
import net.civeira.phylax.features.access.trustedclient.application.visibility.TrustedClientsVisibility;
import net.civeira.phylax.features.access.user.application.visibility.UsersVisibility;
import net.civeira.phylax.features.access.useridentity.domain.UserIdentity;
import net.civeira.phylax.features.access.useridentity.domain.UserIdentityChangeSet;
import net.civeira.phylax.features.access.useridentity.domain.UserIdentityRef;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityCacheGateway;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityCached;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityCursor;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityFilter;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityReadRepositoryGateway;
import net.civeira.phylax.features.access.useridentity.domain.gateway.UserIdentityWriteRepositoryGateway;
import net.civeira.phylax.features.access.useridentity.domain.valueobject.RelyingPartyVO;
import net.civeira.phylax.features.access.useridentity.domain.valueobject.RolesVO;
import net.civeira.phylax.features.access.useridentity.domain.valueobject.TrustedClientVO;
import net.civeira.phylax.features.access.useridentity.domain.valueobject.UserVO;

@ApplicationScoped
@RequiredArgsConstructor
public class UserIdentitysVisibility {

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final UserIdentityCacheGateway cache;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<UserIdentityVisibilityCheck> filterProposalEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<UserIdentityFixedFieldsCheck> fixedFieldsEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<UserIdentityAccesibleCheck> guardEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<UserIdentityHiddenFieldsCheck> hiddenFieldsEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<UserIdentityEntityEnrichment> presetEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final RelyingPartysVisibility relyingPartysVisibility;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final RolesVisibility rolesVisibility;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final TrustedClientsVisibility trustedClientsVisibility;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final UserIdentityReadRepositoryGateway userIdentityReadRepositoryGateway;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final UserIdentityWriteRepositoryGateway userIdentityWriteRepositoryGateway;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final UsersVisibility usersVisibility;

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public boolean checkVisibility(Interaction prev, String uid) {
    return retrieveVisible(prev, uid).isPresent();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uids
   * @return The input entity with the copy values without hidden
   */
  public boolean checkVisibility(Interaction prev, List<String> uids) {
    return uids
        .size() == listVisibles(prev, UserIdentityVisibilityFilter.builder().uids(uids).build(),
            UserIdentityCursor.builder().build()).size();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   * @param original The source interaction
   * @return The input entity with the copy values without hidden
   */
  public UserIdentityChangeSet copyWithFixed(Interaction prev, UserIdentityChangeSet source,
      UserIdentity original) {
    UserIdentityChangeSet withReferences = visiblesReferences(prev, source);
    fieldsToFix(prev, original).forEach(withReferences::unset);
    UserIdentityEntityEnrichment proposal = UserIdentityEntityEnrichment.builder()
        .dto(withReferences).interaction(prev).original(original).build();
    presetEmitter.fire(proposal);
    return proposal.getDto();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   * @return The input entity with the copy values without hidden
   */
  public UserIdentityChangeSet copyWithFixed(Interaction prev, UserIdentityChangeSet source) {
    UserIdentityChangeSet withReferences = visiblesReferences(prev, source);
    fieldsToFix(prev).forEach(withReferences::unset);
    UserIdentityEntityEnrichment proposal =
        UserIdentityEntityEnrichment.builder().dto(withReferences).interaction(prev).build();
    presetEmitter.fire(proposal);
    return proposal.getDto();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param userIdentity
   * @return The input dto with hidden values
   */
  public UserIdentityVisibleProjection copyWithHidden(Interaction prev, UserIdentity userIdentity) {
    UserIdentityVisibleProjection target = new UserIdentityVisibleProjection(userIdentity);
    fieldsToHide(prev, userIdentity).forEach(target::unset);
    return target;
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public long countVisibles(Interaction prev, UserIdentityVisibilityFilter filter) {
    return userIdentityReadRepositoryGateway.count(applyPreVisibilityFilter(prev, filter));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @return initialsFixFields
   */
  public Set<String> fieldsToFix(Interaction prev) {
    Set<String> fields = new HashSet<>(fieldsToHide(prev));
    UserIdentityFixedFieldsCheck proposal =
        UserIdentityFixedFieldsCheck.builder().fields(fields).query(prev).build();
    fixedFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param userIdentity
   * @return initialsFixFields
   */
  public Set<String> fieldsToFix(Interaction prev, UserIdentityRef userIdentity) {
    Set<String> fields = new HashSet<>(fieldsToHide(prev, userIdentity));
    UserIdentityFixedFieldsCheck proposal = UserIdentityFixedFieldsCheck.builder().fields(fields)
        .userIdentity(userIdentity).query(prev).build();
    fixedFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @return initialsHideFields
   */
  public Set<String> fieldsToHide(Interaction prev) {
    Set<String> fields = new HashSet<>();
    UserIdentityHiddenFieldsCheck proposal =
        UserIdentityHiddenFieldsCheck.builder().fields(fields).query(prev).build();
    hiddenFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param userIdentity
   * @return initialsHideFields
   */
  public Set<String> fieldsToHide(Interaction prev, UserIdentityRef userIdentity) {
    Set<String> fields = new HashSet<>(fieldsToHide(prev));
    UserIdentityHiddenFieldsCheck proposal = UserIdentityHiddenFieldsCheck.builder().fields(fields)
        .userIdentity(userIdentity).query(prev).build();
    hiddenFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public UserIdentityCached listCachedVisibles(Interaction prev,
      UserIdentityVisibilityFilter filter, UserIdentityCursor cursor) {
    UserIdentityFilter visibleFilter = applyPreVisibilityFilter(prev, filter);
    return cache.retrieve(visibleFilter, cursor)
        .orElseGet(() -> cache.store(visibleFilter, cursor, listVisibles(prev, filter, cursor)));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public List<UserIdentity> listVisibles(Interaction prev, UserIdentityVisibilityFilter filter,
      UserIdentityCursor cursor) {
    return queryItems(prev, applyPreVisibilityFilter(prev, filter), cursor);
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public List<UserIdentity> listVisiblesForUpdate(Interaction prev,
      UserIdentityVisibilityFilter filter, UserIdentityCursor cursor) {
    return queryItemsForUpdate(prev, applyPreVisibilityFilter(prev, filter), cursor);
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public UserIdentityCached retrieveCachedVisible(Interaction prev, String uid) {
    UserIdentityCursor cursor = UserIdentityCursor.builder().limit(1).build();
    UserIdentityFilter visibleFilter =
        applyPreVisibilityFilter(prev, UserIdentityVisibilityFilter.builder().uid(uid).build());
    return cache.retrieve(visibleFilter, cursor).orElseGet(() -> {
      List<UserIdentity> list =
          retrieveVisible(prev, uid).<List<UserIdentity>>map(List::of).orElseGet(List::of);
      return cache.store(visibleFilter, cursor, list);
    });
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public Optional<UserIdentity> retrieveVisible(Interaction prev, String uid) {
    UserIdentityFilter filter =
        applyPreVisibilityFilter(prev, UserIdentityVisibilityFilter.builder().uid(uid).build());
    return queryItem(prev, uid, filter);
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public Optional<UserIdentity> retrieveVisibleForUpdate(Interaction prev, String uid) {
    UserIdentityFilter filter =
        applyPreVisibilityFilter(prev, UserIdentityVisibilityFilter.builder().uid(uid).build());
    return queryItemForUpdate(prev, uid, filter);
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @return The self filter modified with the prepared values.
   */
  private UserIdentityFilter applyPreVisibilityFilter(Interaction prev,
      UserIdentityVisibilityFilter filter) {
    UserIdentityVisibilityCheck proposal =
        UserIdentityVisibilityCheck.builder().filter(filter).interaction(prev).build();
    filterProposalEmitter.fire(proposal);
    UserIdentityVisibilityFilter modified = proposal.getFilter();
    return UserIdentityFilter.builder().uid(modified.getUid().orElse(null))
        .uids(modified.getUids().stream().toList()).search(modified.getSearch().orElse(null))
        .user(modified.getUser().orElse(null)).users(modified.getUsers())
        .relyingParty(modified.getRelyingParty().orElse(null))
        .relyingPartys(modified.getRelyingPartys())
        .trustedClient(modified.getTrustedClient().orElse(null))
        .trustedClients(modified.getTrustedClients())
        .userTenantTenantAccesible(modified.getUserTenantTenantAccesible().orElse(null)).build();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param userIdentityRef The source interaction
   * @return The input dto with hidden values
   */
  private boolean evaluatePostVisibility(Interaction prev, UserIdentity userIdentityRef) {
    UserIdentityAccesibleCheck proposal = UserIdentityAccesibleCheck.builder().visible(true)
        .entity(userIdentityRef).interaction(prev).build();
    guardEmitter.fire(proposal);
    return Boolean.TRUE.equals(proposal.getVisible());
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @param filter The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private Optional<UserIdentity> queryItem(Interaction prev, String uid,
      UserIdentityFilter filter) {
    return userIdentityReadRepositoryGateway.retrieve(uid, Optional.of(filter))
        .filter(values -> evaluatePostVisibility(prev, values));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @param filter The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private Optional<UserIdentity> queryItemForUpdate(Interaction prev, String uid,
      UserIdentityFilter filter) {
    return userIdentityWriteRepositoryGateway.retrieveForUpdate(uid, Optional.of(filter))
        .filter(values -> evaluatePostVisibility(prev, values));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private List<UserIdentity> queryItems(Interaction prev, UserIdentityFilter filter,
      UserIdentityCursor cursor) {
    List<UserIdentity> list = new ArrayList<>();
    Iterator<UserIdentity> slide = userIdentityReadRepositoryGateway.slide(filter, cursor)
        .slide(values -> evaluatePostVisibility(prev, values));
    while (slide.hasNext()) {
      list.add(slide.next());
    }
    return list;
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private List<UserIdentity> queryItemsForUpdate(Interaction prev, UserIdentityFilter filter,
      UserIdentityCursor cursor) {
    List<UserIdentity> list = new ArrayList<>();
    Iterator<UserIdentity> slide = userIdentityWriteRepositoryGateway.slideForUpdate(filter, cursor)
        .slide(values -> evaluatePostVisibility(prev, values));
    while (slide.hasNext()) {
      list.add(slide.next());
    }
    return list;
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   * @return The input entity with the copy values without hidden
   */
  private UserIdentityChangeSet visiblesReferences(Interaction prev, UserIdentityChangeSet source) {
    source.getUser().map(UserVO::getUserUid).ifPresent(user -> {
      boolean visible = usersVisibility.checkVisibility(prev, user);
      if (!visible) {
        throw new NotFoundException("No user - " + user);
      }
    });
    source.getRelyingParty().flatMap(RelyingPartyVO::getRelyingPartyUid).ifPresent(ref -> {
      boolean visible = relyingPartysVisibility.checkVisibility(prev, ref);
      if (!visible) {
        throw new NotFoundException("No relying party - " + ref);
      }
    });
    source.getTrustedClient().flatMap(TrustedClientVO::getTrustedClientUid).ifPresent(ref -> {
      boolean visible = trustedClientsVisibility.checkVisibility(prev, ref);
      if (!visible) {
        throw new NotFoundException("No trusted client - " + ref);
      }
    });
    visiblesReferencesFromRoles(prev, source);
    return source;
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   */
  private void visiblesReferencesFromRoles(Interaction prev, UserIdentityChangeSet source) {
    source.getRoles().map(RolesVO::getRoles).ifPresent(collector -> {
      List<String> collectRole = new ArrayList<>();
      collector.forEach(item -> {
        if (null != item.getRole()) {
          String idRole = item.getRoleUid();
          if (!collectRole.contains(idRole)) {
            collectRole.add(idRole);
          }
        }
      });
      if (!collectRole.isEmpty()) {
        boolean visible = rolesVisibility.checkVisibility(prev, collectRole);
        if (!visible) {
          throw new NotFoundException("No all role exists: " + collectRole);
        }
      }
    });
  }
}
