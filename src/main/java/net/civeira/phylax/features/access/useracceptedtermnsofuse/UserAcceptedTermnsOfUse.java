package net.civeira.phylax.features.access.useracceptedtermnsofuse;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;
import net.civeira.phylax.common.exception.ConstraintException;
import net.civeira.phylax.common.value.validation.ConstraintFail;
import net.civeira.phylax.common.value.validation.ConstraintFailList;
import net.civeira.phylax.features.access.tenanttermsofuse.TenantTermsOfUseRef;
import net.civeira.phylax.features.access.user.UserRef;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.command.UserAcceptedTermnsOfUseWriteAttributes;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.event.UserAcceptedTermnsOfUseCreateEvent;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.event.UserAcceptedTermnsOfUseDeleteEvent;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.event.UserAcceptedTermnsOfUseEvent;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.event.UserAcceptedTermnsOfUseUpdateEvent;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.transition.create.UserAcceptedTermnsOfUseCreatePipeline;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.transition.delete.UserAcceptedTermnsOfUseDeletePipeline;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.transition.update.UserAcceptedTermnsOfUseUpdatePipeline;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.valueobject.AcceptDateVO;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.valueobject.ConditionsVO;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.valueobject.UidVO;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.valueobject.UserVO;
import net.civeira.phylax.features.access.useracceptedtermnsofuse.valueobject.VersionVO;

@AllArgsConstructor
@Getter
@ToString
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class UserAcceptedTermnsOfUse implements UserAcceptedTermnsOfUseRef {

  /**
   * @autogenerated EntityGenerator
   * @param attributes
   * @param pipeline
   * @return
   */
  public static UserAcceptedTermnsOfUse create(
      final UserAcceptedTermnsOfUseWriteAttributes attributes,
      final UserAcceptedTermnsOfUseCreatePipeline pipeline) {
    return pipeline.create(attributes, attr -> {
      UserAcceptedTermnsOfUse instance = new UserAcceptedTermnsOfUse(attr, Optional.empty());
      instance.addEvent(UserAcceptedTermnsOfUseCreateEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * El accept date de user accepted termns of use
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private AcceptDateVO acceptDate = AcceptDateVO.nullValue();

  /**
   * El conditions de user accepted termns of use
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private ConditionsVO conditions;

  /**
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private List<UserAcceptedTermnsOfUseEvent> recordedEvents = List.of();

  /**
   * A uid string to identify the entity
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private UidVO uid;

  /**
   * El user de user accepted termns of use
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  private UserVO user;

  /**
   * Campo con el n√∫mero de version de user accepted termns of use para controlar bloqueos
   * optimistas
   *
   * @autogenerated EntityGenerator
   */
  @NonNull
  @Builder.Default
  private VersionVO version = VersionVO.nullValue();

  /**
   * @autogenerated EntityGenerator
   * @param attribute
   * @param previous
   */
  private UserAcceptedTermnsOfUse(final UserAcceptedTermnsOfUseWriteAttributes attribute,
      final Optional<UserAcceptedTermnsOfUse> previous) {
    ConstraintFailList list = new ConstraintFailList();
    this.uid =
        attribute.getUid().orElse(previous.map(UserAcceptedTermnsOfUse::getUid).orElse(null));
    this.user =
        attribute.getUser().orElse(previous.map(UserAcceptedTermnsOfUse::getUser).orElse(null));
    this.conditions = attribute.getConditions()
        .orElse(previous.map(UserAcceptedTermnsOfUse::getConditions).orElse(null));
    this.acceptDate = attribute.getAcceptDate().orElse(
        previous.map(UserAcceptedTermnsOfUse::getAcceptDate).orElseGet(AcceptDateVO::nullValue));
    this.version = attribute.getVersion()
        .orElse(previous.map(UserAcceptedTermnsOfUse::getVersion).orElseGet(VersionVO::nullValue));
    if (null == uid) {
      list.add(new ConstraintFail("REQUIRED", "uid", null));
    }
    if (null == user) {
      list.add(new ConstraintFail("REQUIRED", "user", null));
    }
    if (null == conditions) {
      list.add(new ConstraintFail("REQUIRED", "conditions", null));
    }
    if (list.hasErrors()) {
      throw new ConstraintException(list);
    }
    this.recordedEvents =
        previous.map(UserAcceptedTermnsOfUse::getRecordedEvents).orElseGet(List::of);
  }

  /**
   * @autogenerated EntityGenerator
   * @param pipeline
   * @return
   */
  public UserAcceptedTermnsOfUse delete(final UserAcceptedTermnsOfUseDeletePipeline pipeline) {
    return pipeline.delete(this, () -> {
      UserAcceptedTermnsOfUse instance = this;
      instance.addEvent(UserAcceptedTermnsOfUseDeleteEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<OffsetDateTime> getAcceptDateValue() {
    return getAcceptDate().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public String getConditionsReferenceValue() {
    return getConditions().getReferenceValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public TenantTermsOfUseRef getConditionsValue() {
    return getConditions().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  @Override
  public String getUidValue() {
    return this.uid.getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public String getUserReferenceValue() {
    return getUser().getReferenceValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public UserRef getUserValue() {
    return getUser().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Optional<Integer> getVersionValue() {
    return getVersion().getValue();
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public UserAcceptedTermnsOfUse nextVersion() {
    return UserAcceptedTermnsOfUse.builder().uid(this.uid).user(this.user)
        .conditions(this.conditions).acceptDate(this.acceptDate)
        .version(VersionVO.from(this.version() + 1)).build();
  }

  /**
   * @autogenerated EntityGenerator
   * @param attributes
   * @param pipeline
   * @return
   */
  public UserAcceptedTermnsOfUse update(final UserAcceptedTermnsOfUseWriteAttributes attributes,
      final UserAcceptedTermnsOfUseUpdatePipeline pipeline) {
    return pipeline.update(attributes, this, attr -> {
      UserAcceptedTermnsOfUse instance = new UserAcceptedTermnsOfUse(attr, Optional.of(this));
      instance.addEvent(UserAcceptedTermnsOfUseUpdateEvent.builder().payload(instance).build());
      return instance;
    });
  }

  /**
   * @autogenerated EntityGenerator
   * @return
   */
  public Integer version() {
    return this.getVersion().getValue().orElse(0);
  }

  /**
   * @autogenerated EntityGenerator
   * @param event
   */
  private void addEvent(final UserAcceptedTermnsOfUseEvent event) {
    List<UserAcceptedTermnsOfUseEvent> events = new ArrayList<>(this.recordedEvents);
    events.add(event);
    this.recordedEvents = List.copyOf(events);
  }
}
