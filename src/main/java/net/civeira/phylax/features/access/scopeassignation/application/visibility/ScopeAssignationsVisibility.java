package net.civeira.phylax.features.access.scopeassignation.application.visibility;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Event;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.common.exception.NotFoundException;
import net.civeira.phylax.common.security.Interaction;
import net.civeira.phylax.features.access.scopeassignation.domain.ScopeAssignation;
import net.civeira.phylax.features.access.scopeassignation.domain.ScopeAssignationChangeSet;
import net.civeira.phylax.features.access.scopeassignation.domain.ScopeAssignationRef;
import net.civeira.phylax.features.access.scopeassignation.domain.gateway.ScopeAssignationCacheGateway;
import net.civeira.phylax.features.access.scopeassignation.domain.gateway.ScopeAssignationCached;
import net.civeira.phylax.features.access.scopeassignation.domain.gateway.ScopeAssignationCursor;
import net.civeira.phylax.features.access.scopeassignation.domain.gateway.ScopeAssignationFilter;
import net.civeira.phylax.features.access.scopeassignation.domain.gateway.ScopeAssignationReadRepositoryGateway;
import net.civeira.phylax.features.access.scopeassignation.domain.gateway.ScopeAssignationWriteRepositoryGateway;
import net.civeira.phylax.features.access.scopeassignation.domain.valueobject.SecurityDomainVO;
import net.civeira.phylax.features.access.scopeassignation.domain.valueobject.SecurityScopeVO;
import net.civeira.phylax.features.access.securitydomain.application.visibility.SecurityDomainsVisibility;
import net.civeira.phylax.features.access.securityscope.application.visibility.SecurityScopesVisibility;

@ApplicationScoped
@RequiredArgsConstructor
public class ScopeAssignationsVisibility {

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final ScopeAssignationCacheGateway cache;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<ScopeAssignationVisibilityCheck> filterProposalEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<ScopeAssignationFixedFieldsCheck> fixedFieldsEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<ScopeAssignationAccesibleCheck> guardEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<ScopeAssignationHiddenFieldsCheck> hiddenFieldsEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final Event<ScopeAssignationEntityEnrichment> presetEmitter;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final ScopeAssignationReadRepositoryGateway scopeAssignationReadRepositoryGateway;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final ScopeAssignationWriteRepositoryGateway scopeAssignationWriteRepositoryGateway;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final SecurityDomainsVisibility securityDomainsVisibility;

  /**
   * @autogenerated VisibilityServiceGenerator
   */
  private final SecurityScopesVisibility securityScopesVisibility;

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public boolean checkVisibility(Interaction prev, String uid) {
    return retrieveVisible(prev, uid).isPresent();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uids
   * @return The input entity with the copy values without hidden
   */
  public boolean checkVisibility(Interaction prev, List<String> uids) {
    return uids
        .size() == listVisibles(prev, ScopeAssignationVisibilityFilter.builder().uids(uids).build(),
            ScopeAssignationCursor.builder().build()).size();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   * @param original The source interaction
   * @return The input entity with the copy values without hidden
   */
  public ScopeAssignationChangeSet copyWithFixed(Interaction prev, ScopeAssignationChangeSet source,
      ScopeAssignation original) {
    ScopeAssignationChangeSet withReferences = visiblesReferences(prev, source);
    fieldsToFix(prev, original).forEach(withReferences::unset);
    ScopeAssignationEntityEnrichment proposal = ScopeAssignationEntityEnrichment.builder()
        .dto(withReferences).interaction(prev).original(original).build();
    presetEmitter.fire(proposal);
    return proposal.getDto();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   * @return The input entity with the copy values without hidden
   */
  public ScopeAssignationChangeSet copyWithFixed(Interaction prev,
      ScopeAssignationChangeSet source) {
    ScopeAssignationChangeSet withReferences = visiblesReferences(prev, source);
    fieldsToFix(prev).forEach(withReferences::unset);
    ScopeAssignationEntityEnrichment proposal =
        ScopeAssignationEntityEnrichment.builder().dto(withReferences).interaction(prev).build();
    presetEmitter.fire(proposal);
    return proposal.getDto();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param scopeAssignation
   * @return The input dto with hidden values
   */
  public ScopeAssignationVisibleProjection copyWithHidden(Interaction prev,
      ScopeAssignation scopeAssignation) {
    ScopeAssignationVisibleProjection target =
        new ScopeAssignationVisibleProjection(scopeAssignation);
    fieldsToHide(prev, scopeAssignation).forEach(target::unset);
    return target;
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public long countVisibles(Interaction prev, ScopeAssignationVisibilityFilter filter) {
    return scopeAssignationReadRepositoryGateway.count(applyPreVisibilityFilter(prev, filter));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @return initialsFixFields
   */
  public Set<String> fieldsToFix(Interaction prev) {
    Set<String> fields = new HashSet<>(fieldsToHide(prev));
    ScopeAssignationFixedFieldsCheck proposal =
        ScopeAssignationFixedFieldsCheck.builder().fields(fields).query(prev).build();
    fixedFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param scopeAssignation
   * @return initialsFixFields
   */
  public Set<String> fieldsToFix(Interaction prev, ScopeAssignationRef scopeAssignation) {
    Set<String> fields = new HashSet<>(fieldsToHide(prev, scopeAssignation));
    ScopeAssignationFixedFieldsCheck proposal = ScopeAssignationFixedFieldsCheck.builder()
        .fields(fields).scopeAssignation(scopeAssignation).query(prev).build();
    fixedFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @return initialsHideFields
   */
  public Set<String> fieldsToHide(Interaction prev) {
    Set<String> fields = new HashSet<>();
    ScopeAssignationHiddenFieldsCheck proposal =
        ScopeAssignationHiddenFieldsCheck.builder().fields(fields).query(prev).build();
    hiddenFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param scopeAssignation
   * @return initialsHideFields
   */
  public Set<String> fieldsToHide(Interaction prev, ScopeAssignationRef scopeAssignation) {
    Set<String> fields = new HashSet<>(fieldsToHide(prev));
    ScopeAssignationHiddenFieldsCheck proposal = ScopeAssignationHiddenFieldsCheck.builder()
        .fields(fields).scopeAssignation(scopeAssignation).query(prev).build();
    hiddenFieldsEmitter.fire(proposal);
    return proposal.getFields();
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public ScopeAssignationCached listCachedVisibles(Interaction prev,
      ScopeAssignationVisibilityFilter filter, ScopeAssignationCursor cursor) {
    ScopeAssignationFilter visibleFilter = applyPreVisibilityFilter(prev, filter);
    return cache.retrieve(visibleFilter, cursor)
        .orElseGet(() -> cache.store(visibleFilter, cursor, listVisibles(prev, filter, cursor)));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public List<ScopeAssignation> listVisibles(Interaction prev,
      ScopeAssignationVisibilityFilter filter, ScopeAssignationCursor cursor) {
    return queryItems(prev, applyPreVisibilityFilter(prev, filter), cursor);
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  public List<ScopeAssignation> listVisiblesForUpdate(Interaction prev,
      ScopeAssignationVisibilityFilter filter, ScopeAssignationCursor cursor) {
    return queryItemsForUpdate(prev, applyPreVisibilityFilter(prev, filter), cursor);
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public ScopeAssignationCached retrieveCachedVisible(Interaction prev, String uid) {
    ScopeAssignationCursor cursor = ScopeAssignationCursor.builder().limit(1).build();
    ScopeAssignationFilter visibleFilter =
        applyPreVisibilityFilter(prev, ScopeAssignationVisibilityFilter.builder().uid(uid).build());
    return cache.retrieve(visibleFilter, cursor).orElseGet(() -> {
      List<ScopeAssignation> list =
          retrieveVisible(prev, uid).<List<ScopeAssignation>>map(List::of).orElseGet(List::of);
      return cache.store(visibleFilter, cursor, list);
    });
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public Optional<ScopeAssignation> retrieveVisible(Interaction prev, String uid) {
    ScopeAssignationFilter filter =
        applyPreVisibilityFilter(prev, ScopeAssignationVisibilityFilter.builder().uid(uid).build());
    return queryItem(prev, uid, filter);
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @return The input entity with the copy values without hidden
   */
  public Optional<ScopeAssignation> retrieveVisibleForUpdate(Interaction prev, String uid) {
    ScopeAssignationFilter filter =
        applyPreVisibilityFilter(prev, ScopeAssignationVisibilityFilter.builder().uid(uid).build());
    return queryItemForUpdate(prev, uid, filter);
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @return The self filter modified with the prepared values.
   */
  private ScopeAssignationFilter applyPreVisibilityFilter(Interaction prev,
      ScopeAssignationVisibilityFilter filter) {
    ScopeAssignationVisibilityCheck proposal =
        ScopeAssignationVisibilityCheck.builder().filter(filter).interaction(prev).build();
    filterProposalEmitter.fire(proposal);
    ScopeAssignationVisibilityFilter modified = proposal.getFilter();
    return ScopeAssignationFilter.builder().uid(modified.getUid().orElse(null))
        .uids(modified.getUids().stream().toList()).search(modified.getSearch().orElse(null))
        .securityDomain(modified.getSecurityDomain().orElse(null))
        .securityDomains(modified.getSecurityDomains())
        .securityScope(modified.getSecurityScope().orElse(null))
        .securityScopes(modified.getSecurityScopes()).build();
  }

  /**
   * Retrieve the list of fields
   *
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param scopeAssignationRef The source interaction
   * @return The input dto with hidden values
   */
  private boolean evaluatePostVisibility(Interaction prev, ScopeAssignation scopeAssignationRef) {
    ScopeAssignationAccesibleCheck proposal = ScopeAssignationAccesibleCheck.builder().visible(true)
        .entity(scopeAssignationRef).interaction(prev).build();
    guardEmitter.fire(proposal);
    return Boolean.TRUE.equals(proposal.getVisible());
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @param filter The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private Optional<ScopeAssignation> queryItem(Interaction prev, String uid,
      ScopeAssignationFilter filter) {
    return scopeAssignationReadRepositoryGateway.retrieve(uid, Optional.of(filter))
        .filter(values -> evaluatePostVisibility(prev, values));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param uid
   * @param filter The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private Optional<ScopeAssignation> queryItemForUpdate(Interaction prev, String uid,
      ScopeAssignationFilter filter) {
    return scopeAssignationWriteRepositoryGateway.retrieveForUpdate(uid, Optional.of(filter))
        .filter(values -> evaluatePostVisibility(prev, values));
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private List<ScopeAssignation> queryItems(Interaction prev, ScopeAssignationFilter filter,
      ScopeAssignationCursor cursor) {
    List<ScopeAssignation> list = new ArrayList<>();
    Iterator<ScopeAssignation> slide = scopeAssignationReadRepositoryGateway.slide(filter, cursor)
        .slide(values -> evaluatePostVisibility(prev, values));
    while (slide.hasNext()) {
      list.add(slide.next());
    }
    return list;
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param filter The filter to retrieve values
   * @param cursor The filter to retrieve values
   * @return The input entity with the copy values without hidden
   */
  private List<ScopeAssignation> queryItemsForUpdate(Interaction prev,
      ScopeAssignationFilter filter, ScopeAssignationCursor cursor) {
    List<ScopeAssignation> list = new ArrayList<>();
    Iterator<ScopeAssignation> slide = scopeAssignationWriteRepositoryGateway
        .slideForUpdate(filter, cursor).slide(values -> evaluatePostVisibility(prev, values));
    while (slide.hasNext()) {
      list.add(slide.next());
    }
    return list;
  }

  /**
   * @autogenerated VisibilityServiceGenerator
   * @param prev The source interaction
   * @param source The source interaction
   * @return The input entity with the copy values without hidden
   */
  private ScopeAssignationChangeSet visiblesReferences(Interaction prev,
      ScopeAssignationChangeSet source) {
    source.getSecurityDomain().map(SecurityDomainVO::getSecurityDomainUid)
        .ifPresent(securityDomain -> {
          boolean visible = securityDomainsVisibility.checkVisibility(prev, securityDomain);
          if (!visible) {
            throw new NotFoundException("No security domain - " + securityDomain);
          }
        });
    source.getSecurityScope().map(SecurityScopeVO::getSecurityScopeUid).ifPresent(securityScope -> {
      boolean visible = securityScopesVisibility.checkVisibility(prev, securityScope);
      if (!visible) {
        throw new NotFoundException("No security scope - " + securityScope);
      }
    });
    return source;
  }
}
