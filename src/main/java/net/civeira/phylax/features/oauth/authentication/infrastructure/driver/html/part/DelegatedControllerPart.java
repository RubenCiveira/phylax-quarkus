/* @autogenerated */
package net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html.part;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.Locale;
import java.util.Optional;
import java.util.function.Function;

import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.enterprise.context.RequestScoped;
import jakarta.ws.rs.core.MultivaluedMap;
import jakarta.ws.rs.core.Response;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthRequest;
import net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html.FrontAcessController;
import net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html.FrontAcessController.StepResult;
import net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html.SecureHtmlBuilder;
import net.civeira.phylax.features.oauth.client.domain.model.ClientDetails;
import net.civeira.phylax.features.oauth.delegated.domain.gateway.DelegatedStoreGateway;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedAccessExternalProvider;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedAccessExternalProvider.TokenInfo;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedAccessExternalProvider.UserData;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedRequestDetails;
import net.civeira.phylax.features.oauth.delegated.domain.spi.DelegatedAccessAuthValidatorSpi;

@Slf4j
@RequestScoped
@RequiredArgsConstructor
public class DelegatedControllerPart {
  private final ObjectMapper mapper;
  private final SecureHtmlBuilder securer;
  private final DelegatedStoreGateway repository;
  private final DelegatedAccessAuthValidatorSpi manager;

  public Optional<Response> process(String step, Optional<String> oUser,
      ClientDetails clientDetails, AuthRequest request, MultivaluedMap<String, String> paramMap,
      Function<StepResult, Response> resolver) {
    String usercode = paramMap.getFirst("user-code");
    String appprovider = paramMap.getFirst("app-provider");
    if ("query-delegated".equals(step) && usercode != null && appprovider != null) {
      return repository.load(request, usercode).filter(token -> {
        boolean accepted = token.getProvider().equals(appprovider);
        if (!accepted) {
          log.error("No se acepta consultar un token de " + token.getProvider() + " por parte de "
              + appprovider);
        }
        return accepted;
      }).flatMap(info -> lookupUser(request, info)).map(username -> resolver.apply(StepResult
          .builder().request(request).username(username).clientDetails(clientDetails).build()));
    } else {
      return Optional.empty();
    }
  }

  private Optional<String> lookupUser(AuthRequest request, TokenInfo info) {
    Optional<String> username = Optional.empty();
    DelegatedRequestDetails drequest = DelegatedRequestDetails.builder()
        .provider(info.getProvider()).externalUrl(info.getExternUrl()).build();

    for (DelegatedAccessExternalProvider ssoProvider : manager.providers(request)) {
      if (ssoProvider.getId(request).equals(info.getProvider())) {
        UserData userInfo = ssoProvider.userInfo(request, drequest, info.getInnerToken());
        username = manager.retrieveUsername(request, ssoProvider.getId(request), userInfo);
        break;
      }
    }
    return username;
  }

  public Response doBackLoginForm(String tenant, String provider, String code, Locale locale,
      String msg) {
    // No se puede crear nada, porque no estamos seguros que el navegador sea el mismmo.
    String js = securer.configureScripts(securer.addSignAndSend("sign", "form"));
    return securer.secureHtmlResponse(Response
        .ok(js + "<form id=\"form\" method=\"POST\">"
            + "<input type=\"hidden\" name=\"csid\" id=\"sign\" />"
            + "<input type=\"hidden\" name=\"user-code\" value=\"" + code + "\" />"
            + "<input type=\"hidden\" name=\"app-provider\" value=\"" + provider + "\" />"
            + "<input type=\"hidden\" name=\"step\" value=\"query-delegated\" />" + "</form>"
            + "<script>" + "function getCookie(cname) {" + "let name = cname + \"=\";"
            + "let decodedCookie = decodeURIComponent(document.cookie);"
            + "let ca = decodedCookie.split(';');" + "for(let i = 0; i <ca.length; i++) {"
            + "let c = ca[i];" + "while (c.charAt(0) == ' ') {"
            + "c = c.substring(1); } if (c.indexOf(name) == 0) {"
            + "return c.substring(name.length, c.length);}}return \"\";" + "}"
            + "var target = getCookie(\"post-auth-target\");"
            + "document.getElementById(\"form\").action = target;" + "</script>" + "")
        .type(FrontAcessController.TEXT_HTML));
  }

  public Response doPaintLoginForm(String tenant, String provider, Locale locale, String msg) {
    String back = "/oauth/openid/" + tenant + "/delegated-auth?provider=" + provider + "&code=";
    return securer.secureHtmlResponse(Response
        .ok("" + "<script>" + "function setCookie(cname, cvalue, exhours) {"
            + "const d = new Date();" + "d.setTime(d.getTime() + (exhours*60*60*1000));"
            + "let expires = \"expires=\"+ d.toUTCString();"
            + "document.cookie = cname + \"=\" + cvalue + \";\" + expires + \";path=/\";" + "}"
            + "setCookie(\"post-auth-target\", document.location, 1);"
            + "document.location = \"/oauth/openid/" + tenant + "/delegated/redirect/" + provider
            + "?back=" + encode(back) + "\";" + "</script>" + "")
        .type(FrontAcessController.TEXT_HTML));
  }

  private String encode(String param) {
    return URLEncoder.encode(param, StandardCharsets.UTF_8);
  }

  public Optional<TokenInfo> readToken(String str) {
    String res = new String(Base64.getDecoder().decode(str), StandardCharsets.UTF_8);
    try {
      return Optional.of(mapper.readValue(res, TokenInfo.class));
    } catch (IOException ex) {
      log.warn("Se intenta login con un token sso invalido", ex);
      return Optional.empty();
    }
  }
}
