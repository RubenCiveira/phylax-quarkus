/* @autogenerated */
package net.civeira.phylax.features.oauth.delegated.infrastructure.driven;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Base64;
import java.util.Optional;

import javax.sql.DataSource;

import com.fasterxml.jackson.databind.ObjectMapper;

import io.quarkus.scheduler.Scheduled;
import jakarta.enterprise.context.RequestScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthRequest;
import net.civeira.phylax.features.oauth.delegated.domain.gateway.DelegatedStoreGateway;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedAccessExternalProvider.TokenInfo;

@Slf4j
@RequestScoped
@RequiredArgsConstructor
public class DelegateRepositoryJdbcAdapter implements DelegatedStoreGateway {
  private final DataSource source;
  private final ObjectMapper mapper;

  @Scheduled(every = "1h")
  public void cleanTemp() throws SQLException {
    try (Connection connection = source.getConnection()) {
      try (PreparedStatement prepareStatement =
          connection.prepareStatement("DELETE FROM _oauth_delegated_codes where expiration < ?")) {
        prepareStatement.setTimestamp(1, new Timestamp(System.currentTimeMillis() - 60000));
        prepareStatement.execute();
      }
    }
  }

  @Override
  public void save(AuthRequest request, String code, TokenInfo token) {
    write(code, Base64.getEncoder().encodeToString(format(token).getBytes(StandardCharsets.UTF_8)));
  }

  private String format(TokenInfo json) {
    try {
      return mapper.writeValueAsString(json);
    } catch (IOException ex) {
      log.warn("Unable to build sso token", ex);
      return "{ tenant: \"" + json.getRequest().getTenant() + "\", provider: \""
          + json.getProvider() + "\", externUrl: \"" + json.getExternUrl() + "\", innerToken: \""
          + json.getInnerToken() + "\"}";
    }
  }

  private void write(String code, String token) {
    try (Connection conn = source.getConnection();
        PreparedStatement stat = conn.prepareStatement(
            "INSERT INTO _oauth_delegated_codes (expiration, code, token) VALUES (?, ?, ?)")) {
      stat.setTimestamp(1, new Timestamp(System.currentTimeMillis() + 60000));
      stat.setString(2, code);
      stat.setString(3, token);
      stat.execute();
    } catch (SQLException ex) {
      throw new IllegalStateException(ex);
    }
  }

  @Override
  public Optional<TokenInfo> load(AuthRequest request, String code) {
    Optional<String> response = Optional.empty();
    try (Connection connection = source.getConnection();
        PreparedStatement stat = connection.prepareStatement(
            "SELECT token from _oauth_delegated_codes where code=? and expiration > ?")) {
      stat.setString(1, code);
      stat.setTimestamp(2, new Timestamp(System.currentTimeMillis()));
      try (ResultSet res = stat.executeQuery()) {
        if (res.next()) {
          response = Optional.of(res.getString(1));
        }
      }
    } catch (SQLException ex) {
      throw new IllegalStateException(ex);
    }
    return response.flatMap(this::readToken).filter(token -> {
      boolean acepted = request.getTenant().equals(token.getRequest().getTenant());
      if (!acepted) {
        log.error("El token que se intenta cargar es de " + token.getRequest().getTenant()
            + " y no de " + request.getTenant());
      }
      return acepted;
    });
  }

  public Optional<TokenInfo> readToken(String str) {
    String res = new String(Base64.getDecoder().decode(str), StandardCharsets.UTF_8);
    try {
      return Optional.of(mapper.readValue(res, TokenInfo.class));
    } catch (IOException ex) {
      log.warn("Se intenta login con un token sso invalido", ex);
      return Optional.empty();
    }
  }
}
