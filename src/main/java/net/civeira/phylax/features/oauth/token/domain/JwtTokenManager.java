/* @autogenerated */
package net.civeira.phylax.features.oauth.token.domain;

import java.io.IOException;
import java.math.BigInteger;
import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.EncodedKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.RSAPrivateKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.text.StringEscapeUtils;
import org.eclipse.microprofile.config.inject.ConfigProperty;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTDecodeException;
import com.auth0.jwt.exceptions.SignatureVerificationException;
import com.auth0.jwt.exceptions.TokenExpiredException;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.auth0.jwt.interfaces.RSAKeyProvider;

import jakarta.enterprise.context.RequestScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.exception.NotAllowedException;
import net.civeira.phylax.common.infrastructure.CurrentRequest;
import net.civeira.phylax.features.oauth.token.domain.gateway.TokenStoreGateway;
import net.civeira.phylax.features.oauth.token.domain.model.Jks;
import net.civeira.phylax.features.oauth.token.domain.model.KeyInformation;
import net.civeira.phylax.features.oauth.token.domain.model.PublicKeyInformation;

@Slf4j
@RequestScoped
@RequiredArgsConstructor
public class JwtTokenManager {

  private final long futureKeysNumber = 2;
  private final CurrentRequest current;
  @ConfigProperty(name = "oauth.jwt.authorization.key-duration")
  private final Duration keyDuration;
  private final TokenStoreGateway repository;
  @ConfigProperty(name = "oauth.jwt.authorization.store-pass")
  private final String storePass;
  @ConfigProperty(name = "oauth.jwt.authorization.store-pair")
  private final String storePair;

  public Optional<String> extractSignerId(String token) {
    DecodedJWT jwt = JWT.decode(token);
    return Optional.ofNullable(jwt.getKeyId());
  }

  public String getIssuer(String tenant) {
    return current.getPublicHost() + "/oauth/openid/" + tenant;
  }

  public List<PublicKeyInformation> getPublicKeys() {
    return repository.listPublicKeys();
  }

  public List<Jks> getJks() throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
    List<Jks> syncCopy = new ArrayList<>();
    List<PublicKeyInformation> publicKeys = repository.listPublicKeys();
    for (PublicKeyInformation stream : publicKeys) {
      syncCopy.add(generateJWK(stream.getKeyId(), readKey(stream.getPublicKey())));
    }
    return syncCopy;
  }

  public KeyInformation currentKey() {
    checkNewNeeded();
    return repository.currentKey()
        .orElseThrow(() -> new IllegalStateException("There is no active key"));
  }

  public Optional<DecodedJWT> decode(PublicKeyInformation key, String tenant, String token) {
    try {
      return Optional.of(JWT.require(Algorithm.RSA256(readKey(key.getPublicKey())))
          .withIssuer(getIssuer(tenant)).build().verify(token));
    } catch (TokenExpiredException ex) {
      logError("Expired token", ex);
      throw new NotAllowedException("");
    } catch (JWTDecodeException de) {
      logError("Unable to decode token", de);
      return Optional.empty();
    } catch (SignatureVerificationException se) {
      logError("Wrong signature", se);
      return Optional.empty();
    } catch (IOException | GeneralSecurityException e) {
      logError("General auth error", e);
      return Optional.empty();
    }
  }

  public Optional<DecodedJWT> decodeWithoutTenant(PublicKeyInformation key, String token) {
    try {
      return Optional
          .of(JWT.require(Algorithm.RSA256(readKey(key.getPublicKey()))).build().verify(token));
    } catch (TokenExpiredException ex) {
      logError("Expired token", ex);
      throw new NotAllowedException("");
    } catch (JWTDecodeException de) {
      logError("Unable to decode token", de);
      return Optional.empty();
    } catch (SignatureVerificationException se) {
      logError("Wrong signature", se);
      return Optional.empty();
    } catch (IOException | GeneralSecurityException e) {
      logError("General auth error", e);
      return Optional.empty();
    }
  }

  public Algorithm signAlgoritm(KeyInformation key) {
    try {
      // Tengo que obtener el token store actual.
      byte[] privateKeyBytes = java.util.Base64.getDecoder().decode(key.getPrivateKey());
      String publicKeyPEM = key.getPublicKey().replace("-----BEGIN PUBLIC KEY-----", "")
          .replace("-----END PUBLIC KEY-----", "").replaceAll("\\s", "");
      byte[] keyBytes = java.util.Base64.getDecoder().decode(publicKeyPEM);

      KeyFactory keyFactory = KeyFactory.getInstance("RSA");
      PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);
      RSAPrivateKeySpec rsaSpec =
          keyFactory.getKeySpec(keyFactory.generatePrivate(keySpec), RSAPrivateKeySpec.class);

      PrivateKey privateKey = keyFactory.generatePrivate(
          new RSAPrivateKeySpec(rsaSpec.getModulus(), rsaSpec.getPrivateExponent()));

      X509EncodedKeySpec pkeySpec = new X509EncodedKeySpec(keyBytes);
      PublicKey publicKey = keyFactory.generatePublic(pkeySpec);
      if (!(publicKey instanceof RSAPublicKey)) {
        throw new IllegalArgumentException("La clave p√∫blica no es de tipo RSA");
      }

      RSAKeyProvider provider = new RSAKeyProvider() {
        @Override
        public RSAPublicKey getPublicKeyById(String keyId) {
          return (RSAPublicKey) publicKey;
        }

        @Override
        public RSAPrivateKey getPrivateKey() {
          return (RSAPrivateKey) privateKey;
        }

        @Override
        public String getPrivateKeyId() {
          return key.getKeyId();
        }
      };
      return Algorithm.RSA256(provider);
    } catch (GeneralSecurityException e) {
      throw new NotAllowedException(
          "Imposible generar el token, por un error [" + e.getClass() + "]: " + e.getMessage());
    }
  }

  private RSAPublicKey readKey(String publicKeyContent)
      throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
    String base64 = publicKeyContent.replace("\\n", "").replace("-----BEGIN PUBLIC KEY-----", "")
        .replace("-----END PUBLIC KEY-----", "").trim();

    java.util.Base64.Decoder decoder = java.util.Base64.getDecoder();
    byte[] decode = decoder.decode(base64);
    KeyFactory keyFactory = KeyFactory.getInstance("RSA");
    EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(decode);
    return (RSAPublicKey) keyFactory.generatePublic(publicKeySpec);
  }

  private void checkNewNeeded() {
    Instant expected = Instant.now();
    for (int i = 0; i < futureKeysNumber; i++) {
      expected = expected.plus(keyDuration);
    }
    Instant end = repository.nextKeysExpiration();

    if (expected.isAfter(end)) {
      Instant since = Instant.now().minusSeconds(3600);
      long differenceInSeconds = Duration.between(since, expected).getSeconds();
      long intervalInSeconds = keyDuration.getSeconds();
      long numberOfIntervals = (differenceInSeconds / intervalInSeconds) + 1;

      for (int i = 0; i < numberOfIntervals; i++) {
        KeyInformation pair = createKeys();
        repository.saveKey(pair, since, keyDuration);
        since = since.plus(keyDuration);
      }
    }
  }

  private KeyInformation createKeys() {
    try {
      KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
      keyGen.initialize(4096, new SecureRandom());
      KeyPair pair = keyGen.generateKeyPair();
      PublicKey pub = pair.getPublic();
      java.util.Base64.Encoder encoder = java.util.Base64.getEncoder();
      String publicString = "-----BEGIN PUBLIC KEY-----\r\n"
          + encoder.encodeToString(pub.getEncoded()) + "\r\n" + "-----END PUBLIC KEY-----";

      String privateString = encoder.encodeToString(pair.getPrivate().getEncoded());

      return KeyInformation.builder().keyId(UUID.randomUUID().toString()).keyUse("sig").alg("RS256")
          .publicKey(publicString).privateKey(privateString).build();
    } catch (NoSuchAlgorithmException ex) {
      throw new IllegalStateException("There is no RSA algorim to sign", ex);
    }
  }

  private Jks generateJWK(String key, RSAPublicKey rsa) {
    return Jks.builder().kty(rsa.getAlgorithm()).kid(key)
        .n(Base64.encodeBase64URLSafeString(toByteArray(rsa.getModulus())))
        .e(Base64.encodeBase64URLSafeString(rsa.getPublicExponent().toByteArray())).alg("RS256")
        .use("sig").build();
  }

  private static byte[] toByteArray(BigInteger bigInteger) {
    byte[] bytes = bigInteger.toByteArray();
    byte[] result;
    if (bytes.length > 1 && bytes[0] == 0) {
      result = new byte[bytes.length - 1];
      System.arraycopy(bytes, 1, result, 0, result.length);
    } else {
      result = bytes;
    }
    return result;
  }

  private void logError(String message, Exception ex) {
    if (log.isErrorEnabled()) {
      log.error(message + ": {0}", StringEscapeUtils.escapeJson(ex.getMessage()));
    }
  }
}
