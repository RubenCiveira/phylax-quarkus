/* @autogenerated */
package net.civeira.phylax.features.oauth.token.infrastructure.driven;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import javax.sql.DataSource;

import jakarta.enterprise.context.RequestScoped;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.features.oauth.token.domain.gateway.TokenStoreGateway;
import net.civeira.phylax.features.oauth.token.domain.model.KeyInformation;
import net.civeira.phylax.features.oauth.token.domain.model.PublicKeyInformation;

@RequestScoped
@RequiredArgsConstructor
public class TokenRepositoryJdbcAdapter implements TokenStoreGateway {
  private final DataSource datasource;

  @Override
  public Optional<KeyInformation> currentKey() {
    try (Connection connection = datasource.getConnection()) {
      deleteOldKeys(connection);
      try (PreparedStatement prepareStatement = connection.prepareStatement(
          "select private, keyid, public from _oauth_jwt_keys where since <= ? order by expiration desc")) {
        prepareStatement.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
        try (ResultSet executeQuery = prepareStatement.executeQuery()) {
          return executeQuery.next() ? Optional.of(KeyInformation.builder()
              .publicKey(executeQuery.getString(3)).privateKey(executeQuery.getString(1))
              .keyUse("sig").alg("RS256").keyId(executeQuery.getString(2)).build())
              : Optional.empty();
        }
      }
    } catch (SQLException ex) {
      throw new IllegalStateException(ex);
    }
  }

  private void deleteOldKeys(Connection connection) throws SQLException {
    try (PreparedStatement prepareStatement =
        connection.prepareStatement("delete from _oauth_jwt_keys where expiration < ?")) {
      prepareStatement.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
      prepareStatement.execute();
    }
  }

  @Override
  public Instant nextKeysExpiration() {
    try (Connection connection = datasource.getConnection()) {
      try (PreparedStatement prepareStatement = connection.prepareStatement(
          "select expiration from _oauth_jwt_keys where since > ? order by expiration desc")) {
        prepareStatement.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
        try (ResultSet executeQuery = prepareStatement.executeQuery()) {
          return executeQuery.next() ? Instant.ofEpochMilli(executeQuery.getTimestamp(1).getTime())
              : Instant.now().minusSeconds(3600);
        }
      }
    } catch (SQLException ex) {
      throw new IllegalStateException(ex);
    }
  }

  @Override
  public List<PublicKeyInformation> listPublicKeys() {
    try (Connection connection = datasource.getConnection()) {
      List<PublicKeyInformation> data = new ArrayList<>();
      try (
          PreparedStatement prepareStatement = connection.prepareStatement(
              "select keyid,public from _oauth_jwt_keys order by expiration desc");
          ResultSet executeQuery = prepareStatement.executeQuery()) {
        while (executeQuery.next()) {
          data.add(PublicKeyInformation.builder().keyId(executeQuery.getString(1))
              .publicKey(executeQuery.getString(2)).build());
        }
      }
      return data;
    } catch (SQLException ex) {
      throw new IllegalStateException(ex);
    }
  }

  @Override
  public void saveKey(KeyInformation key, Instant since, Duration caducidad) {
    // public String saveKey(String privateString, String publicString, long since, long caducidad)
    // {
    try (Connection connection = datasource.getConnection()) {
      try (PreparedStatement prepareStatement = connection.prepareStatement(
          "INSERT INTO _oauth_jwt_keys (expiration, private, public, since, keyid) VALUES (?, ?, ?, ?, ?)")) {
        prepareStatement.setTimestamp(1, new Timestamp(since.plus(caducidad).toEpochMilli()));
        prepareStatement.setString(2, key.getPrivateKey());
        prepareStatement.setString(3, key.getPublicKey());
        prepareStatement.setTimestamp(4, new Timestamp(since.toEpochMilli()));
        prepareStatement.setString(5, key.getKeyId());
        if (prepareStatement.executeUpdate() != 1) {
          throw new SQLException("Imposible insertar valores");
        }
      }
    } catch (SQLException ex) {
      throw new IllegalStateException(ex);
    }
  }

}
