/* @autogenerated */
package net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html;

import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.function.Function;
import java.util.function.Supplier;

import org.apache.commons.lang3.StringUtils;
import org.jboss.resteasy.reactive.server.ServerExceptionMapper;

import io.quarkus.runtime.annotations.RegisterForReflection;
import jakarta.enterprise.context.RequestScoped;
import jakarta.ws.rs.CookieParam;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.HttpHeaders;
import jakarta.ws.rs.core.MultivaluedMap;
import jakarta.ws.rs.core.NewCookie;
import jakarta.ws.rs.core.NewCookie.SameSite;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.UriInfo;
import lombok.Builder;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.Synchronized;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.value.YamlLocaleMessages;
import net.civeira.phylax.features.oauth.authentication.application.spi.DecoratePageSpi;
import net.civeira.phylax.features.oauth.authentication.domain.exception.AuthenticationException;
import net.civeira.phylax.features.oauth.authentication.domain.exception.ConsentRequiredException;
import net.civeira.phylax.features.oauth.authentication.domain.exception.MfaRequiredException;
import net.civeira.phylax.features.oauth.authentication.domain.exception.NewMfaRequiredException;
import net.civeira.phylax.features.oauth.authentication.domain.exception.NewPasswordRequiredException;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthRequest;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationChallege;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationData;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationResult;
import net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html.SecureHtmlBuilder.EncrytFieldTransfer;
import net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html.part.ConsentControllerPart;
import net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html.part.DelegatedControllerPart;
import net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html.part.MfaControllerPart;
import net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html.part.NewMfaControllerPart;
import net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html.part.NewPassControllerPart;
import net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html.part.RecoverControllerPart;
import net.civeira.phylax.features.oauth.client.domain.gateway.ClientStoreGateway;
import net.civeira.phylax.features.oauth.client.domain.model.ClientDetails;
import net.civeira.phylax.features.oauth.delegated.application.DelegateLogin;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedAccessExternalProvider;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedProviderDescription;
import net.civeira.phylax.features.oauth.session.domain.gateway.SessionStoreGateway;
import net.civeira.phylax.features.oauth.session.domain.gateway.TemporalKeysGateway;
import net.civeira.phylax.features.oauth.session.domain.model.SessionInfo;
import net.civeira.phylax.features.oauth.session.domain.model.TemporalAuthCode;
import net.civeira.phylax.features.oauth.token.domain.JwtTokenBuilder;
import net.civeira.phylax.features.oauth.token.domain.model.IdToken;
import net.civeira.phylax.features.oauth.user.application.LoginUsecase;

@Slf4j
@Path("")
@RequestScoped
@RequiredArgsConstructor
public class FrontAcessController {
  private static final String TENANT = "tenant";
  private static final String USERNAME = "username";
  private static final String OAUTH_OPENID = "/oauth/openid/";
  private static final String AUTH_SESSION_ID = "AUTH_SESSION_ID";
  private static final String PRE_SESSION_ID = "PRE_SESSION_ID";
  private static Map<Locale, YamlLocaleMessages> TRANSLATIONS = new HashMap<>();
  public static final String TEXT_HTML = "text/html";

  @Data
  @Builder
  public static class StepResult {
    private final String csid;
    private final String username;
    private final AuthRequest request;
    private final ClientDetails clientDetails;
  }

  @Data
  @Builder
  private static class StartFormFlow {
    private final Locale locale;
    private final AuthRequest request;
    private final String username;
    private final List<AuthenticationChallege> challenges;
    private final NewCookie session;
  }

  @Data
  @Builder
  private static class FlowInfo {
    private final AuthenticationChallege chageller;
    private final Function<StartFormFlow, Response> function;
  }

  @Data
  @RegisterForReflection
  public static class Challenge {
    private String username;
    private List<AuthenticationChallege> challenges = new ArrayList<>();
  }

  private MultivaluedMap<String, String> formParams;
  private Challenge currentChallenge;

  private final LoginUsecase loginUsecase;
  private final SecureHtmlBuilder securer;
  private final DecoratePageSpi decorator;

  private final RecoverControllerPart recoverController;
  private final MfaControllerPart mfaController;
  private final ConsentControllerPart consentController;
  private final NewPassControllerPart newPassController;
  private final NewMfaControllerPart newMfaController;
  private final DelegatedControllerPart delegatedController;

  private final ClientStoreGateway clientRetrieve;
  private final JwtTokenBuilder tokenBuilder;
  private final SessionStoreGateway sessionStore;
  private final TemporalKeysGateway temporalStore;
  private final DelegateLogin delegateLogin;

  private Map<Class<? extends AuthenticationException>, FlowInfo> loginErrorMappers =
      new HashMap<>();

  @ServerExceptionMapper
  @Produces(TEXT_HTML)
  public Response showError(Exception ex, @Context HttpHeaders headers) {
    Locale locale = headers.getAcceptableLanguages().get(0);
    log.error("There was an error with son outh step", ex);
    return Response.ok(decorator.getFullPage("Error",
        "" + "<h1>There was an error</h1>"
            + "<p>Please, <a href=\"#\" click=\"window.history.back();\">go back</a> and again</p>"
            + "",
        locale)).header("Content-Type", "text/html").build();
  }

  @GET
  @Produces(TEXT_HTML)
  @Path("oauth/openid/{tenant}/me")
  public Response showInfo(final @PathParam(TENANT) String tenant,
      @CookieParam(AUTH_SESSION_ID) String cookie, final @Context UriInfo req,
      @Context HttpHeaders headers) {
    AuthRequest request = new AuthRequest(tenant, req, headers);
    return loadClient(request).flatMap(loadClient -> sessionStore.loadSession(cookie))
        .map(sessionInfo -> securer.secureHtmlResponse(Response.ok(decorator.getFullPage("Data",
            "<h1>Ficha de " + sessionInfo.getValidationData().getUsername() + "</h1>",
            request.getLocale()))))
        .orElseGet(() -> Response.status(403, "Client not allowed.").build());
  }

  @GET
  @Produces(TEXT_HTML)
  @Path("oauth/openid/{tenant}/delegated-auth")
  public Response processDelegated(final @PathParam(TENANT) String tenant,
      @QueryParam("provider") String provider, @QueryParam("code") String code,
      final @Context UriInfo req, @Context HttpHeaders headers) {
    Locale locale = headers.getAcceptableLanguages().get(0);
    return delegatedController.doBackLoginForm(tenant, provider, code, locale, null);
  }

  @GET
  @Path("oauth/openid/{tenant}/auth")
  public Response showForm(final @PathParam(TENANT) String tenant,
      @CookieParam(AUTH_SESSION_ID) String session, final @Context UriInfo req,
      @Context HttpHeaders headers) {
    AuthRequest request = new AuthRequest(tenant, req, headers);
    return loadClient(request).map(loadClient -> {
      return sessionStore.loadSession(session)
          .map(sessionInfo -> doPaintVerifySession(sessionInfo, loadClient, request, session))
          .orElseGet(() -> {
            return "none".equals(request.getPrompt().orElse(""))
                ? redirectError(request, "no session")
                : doPaintLoginForm(request, null, null);
          });
    }).orElseGet(() -> Response.status(403, "Client not allowed.").build());
  }

  @POST
  @Path("oauth/openid/{tenant}/auth")
  public Response processForm(final @PathParam(TENANT) String tenant, final @Context UriInfo req,
      @Context HttpHeaders headers, final MultivaluedMap<String, String> paramMap,
      @CookieParam(AUTH_SESSION_ID) String session, @CookieParam(PRE_SESSION_ID) String cookie) {
    formParams = paramMap;

    AuthRequest request = new AuthRequest(tenant, req, headers);

    return loadClient(request)
        .map(loadClient -> sessionStore.loadSession(session)
            .map(sessionInfo -> doCheckSession(sessionInfo, loadClient, request, paramMap, session))
            .orElseGet(() -> doExecStep(loadClient, request, paramMap, cookie)))
        .orElseGet(() -> Response.status(403, "Client not allowed.").build());
  }

  @GET
  @Path("oauth/openid/{tenant}/mfa-setup")
  public Response showMfaSelector(final @PathParam(TENANT) String tenant,
      final @Context UriInfo req, @Context HttpHeaders headers,
      @CookieParam(PRE_SESSION_ID) String cookie) {
    AuthRequest request = new AuthRequest(tenant, req, headers);

    return preSessionUsername(cookie, tenant).map(Challenge::getUsername)
        .flatMap(user -> newMfaController.mfaSelector(request, user))
        .orElseGet(() -> Response.status(403, "Client not allowed.").build());
  }

  @GET
  @Path("oauth/openid/{tenant}/recover")
  public Response showRecover(final @PathParam(TENANT) String tenant, final @Context UriInfo req,
      @Context HttpHeaders headers, @QueryParam(USERNAME) String username,
      @QueryParam("recovercode") String recovercode) {
    AuthRequest request = new AuthRequest(tenant, req, headers);

    return loadClient(request)
        .map(clientDetails -> recoverController.doPaintWaitRecover(request.getLocale(), null,
            username, recovercode))
        .orElseGet(() -> Response.status(403, "Client not allowed.").build());
  }

  @POST
  @Path("oauth/openid/{tenant}/recover")
  public Response checkRecover(final @PathParam(TENANT) String tenant,
      @QueryParam(USERNAME) String username, @Context UriInfo req,
      final MultivaluedMap<String, String> paramMap, @Context HttpHeaders headers) {
    formParams = paramMap;

    AuthRequest request = new AuthRequest(tenant, req, headers);

    return loadClient(request)
        .map(clientDetails -> recoverController.doExecFinal(clientDetails, request, username,
            paramMap, this::revolve))
        .orElseGet(() -> Response.status(403, "Client not allowed.").build());
  }

  @POST
  @Path("oauth/openid/{tenant}/revocation")
  public Response revoke(final @PathParam(TENANT) String tenant,
      @CookieParam(PRE_SESSION_ID) String cookie, final MultivaluedMap<String, String> paramMap,
      final @Context HttpHeaders headers) {
    sessionStore.deleteSession(cookie);
    return Response.ok().build();
  }

  @GET
  @Path("oauth/openid/{tenant}/logout")
  public Response logout(final @PathParam(TENANT) String tenant,
      @CookieParam("AUTH_SESSION_ID") String cookie,
      @QueryParam("post_logout_redirect_uri") String redirect) {
    sessionStore.deleteSession(cookie);
    String to = redirect;
    int onClean = to.indexOf('?');
    if (-1 != onClean) {
      to = to.substring(0, onClean);
    }
    return Response.status(302).cookie(new NewCookie.Builder(AUTH_SESSION_ID).value("").build())
        .location(buildUrl(to)).build();
  }

  @GET
  @Path("oauth/openid/{tenant}/login-status-iframe")
  @Produces(TEXT_HTML)
  public String checkSession(final @PathParam(TENANT) String tenant) {
    return "<h1>Check</h1>";
  }

  private Response doCheckSession(SessionInfo sessionInfo, ClientDetails loadClient,
      AuthRequest request, final MultivaluedMap<String, String> paramMap, String cookie) {
    String prompt = request.getPrompt().orElse("");

    String csid = securer.verifyToken(first(paramMap, "csid")).orElse("-");
    if (sessionInfo.getCsid().equals(csid)) {
      return redirect(Optional.of(cookie), loadClient, sessionInfo.getGrant(), request,
          sessionInfo.getValidationData());
    } else if ("none".equals(prompt)) {
      return redirectError(request, "invalid client");
    } else {
      return doPaintLoginForm(request, null, null);
    }
  }

  private Response doPaintVerifySession(SessionInfo sDDessionInfo, ClientDetails loadClient,
      AuthRequest request, String cookie) {
    String js = securer.configureScripts(securer.addSignAndSend("sign", "enter"));
    return securer.secureHtmlResponse(Response
        .ok(decorator.getFullPage("Login",
            js + "<form id=\"enter\" method=\"POST\">"
                + "<input type=\"hidden\" name=\"csid\" id=\"sign\" />"
                + "<input type=\"submit\" />" + "</form>" + "",
            request.getLocale()))
        .type(TEXT_HTML));
  }

  private Response doPaintLoginForm(AuthRequest request, String msg, String chagenlle) {
    Locale locale = request.getLocale();
    String js = securer.configureScripts(securer.focusOn(USERNAME), securer.addSign("sign"),
        securer.cypher(
            Arrays
                .asList(EncrytFieldTransfer.builder().from("type_password").to("password").build()),
            "login"));
    String title = i18n(locale, "login.title");
    String error = i18n(locale, "login.error-format", msg);
    String help = i18n(locale, "login.help", request.getTenant());
    String username = i18n(locale, "login.username");
    String password = i18n(locale, "login.password");
    String recoverLabel = i18n(locale, "login.recover-label");
    String recoverText = "<input class=\"inline\" type=\"submit\" value=\"" + recoverLabel + "\"/>";
    String enter = i18n(locale, "login.enter");

    StringBuilder delegatedLogins = new StringBuilder();
    StringBuilder execAuto = new StringBuilder();

    for (DelegatedAccessExternalProvider provider : delegateLogin.providers(request)) {
      DelegatedProviderDescription info = provider.info(request);
      delegatedLogins.append("                    <form method=\"POST\" id=\"social-form-"
          + info.getId() + "\" class=\"social-form\">\r\n"
          + "                        <input type=\"hidden\" name=\"step\" value=\"delegated-login\" />"
          + "                        <input type=\"hidden\" name=\"delegated-provider\" value=\""
          + info.getId() + "\" />"
          + "                        <button type=\"submit\" class=\"social-button\">\r\n"
          + "                            <img src=\"" + info.getLogo() + "\" alt=\""
          + info.getName() + "\">\r\n" + "                        </button>\r\n"
          + "                    </form>\r\n");

      if (info.isAutomatic()) {
        execAuto.append(
            "<script>" + "document.addEventListener('DOMContentLoaded', function(event) {\r\n"
                + "document.getElementById(\"social-form-" + info.getId() + "\").submit();" + "});"
                + "</script>");
      }

    }

    if (!delegatedLogins.isEmpty()) {
      delegatedLogins.append(
          " <div class=\"social-login-buttons\">\r\n" + "" + delegatedLogins + "" + "</div>");
    }

    return securer.secureHtmlResponse(Response
        .ok(decorator.getFullPage("Login", js + "<h1>" + title + "</h1>" + "<p>" + help + "</p>"
            + (null == msg ? "" : "<p class=\"error\">" + error + "</p>")
            + "<form id=\"login\" method=\"POST\">"
            + "<input type=\"hidden\" name=\"csid\" id=\"sign\" />" + "<label>" + username
            + " <input type=\"text\" id=\"username\" name=\"username\" value=\"" + "\" /></label>"
            + "<label>" + password + " <input type=\"password\" id=\"type_password\" value=\""
            + "\" /></label>" + "<input type=\"hidden\" id=\"password\" name=\"password\" value=\""
            + "\" />" + "<input class=\"primary-button action-button\" type=\"submit\" value=\""
            + enter + "\" />" + "</form>" + delegatedLogins + execAuto
            + (recoverController.allowRecover(request)
                ? "<form method=\"POST\">"
                    + "<input type=\"hidden\" name=\"step\" value=\"show-recover\" />" + "<p>"
                    + recoverText + "</p></form>"
                : ""),
            locale))
        .type(TEXT_HTML)
        .cookie(new NewCookie.Builder(AUTH_SESSION_ID).value(null).sameSite(SameSite.NONE)
            .path(OAUTH_OPENID + request.getTenant()).secure(true).httpOnly(true).build())
        .cookie(new NewCookie.Builder(PRE_SESSION_ID).value(null).sameSite(SameSite.NONE)
            .path(OAUTH_OPENID + request.getTenant()).secure(true).httpOnly(true).build()));
  }

  private Optional<Response> fillIfEmpty(Optional<Response> check,
      Supplier<Optional<Response>> supplier) {
    return check.isPresent() ? check : supplier.get();
  }

  private Response doExecStep(ClientDetails clientDetails, AuthRequest request,
      MultivaluedMap<String, String> paramMap, @CookieParam(PRE_SESSION_ID) String cookie) {
    Response response;
    formParams = paramMap;
    String step = first(paramMap, "step");
    Optional<Challenge> oCh = preSessionUsername(cookie, request.getTenant());
    Optional<String> oUser = oCh.map(Challenge::getUsername);
    Optional<Response> process = Optional.empty();

    process = fillIfEmpty(process, () -> delegatedController.process(step, oUser, clientDetails,
        request, paramMap, this::revolve));
    process = fillIfEmpty(process, () -> recoverController.process(step, oUser, clientDetails,
        request, paramMap, this::revolve));
    process = fillIfEmpty(process,
        () -> mfaController.process(step, oUser, clientDetails, request, paramMap, this::revolve,
            null == this.currentChallenge ? List.of() : this.currentChallenge.challenges));
    process = fillIfEmpty(process, () -> consentController.process(step, oUser, clientDetails,
        request, paramMap, this::revolve));
    process = fillIfEmpty(process, () -> newPassController.process(step, oUser, clientDetails,
        request, paramMap, this::revolve));
    process = fillIfEmpty(process, () -> newMfaController.process(step, oUser, clientDetails,
        request, paramMap, this::revolve));

    if (process.isPresent()) {
      response = process.get();
    } else if ("delegated-login".equals(step)) {
      response = delegatedController.doPaintLoginForm(request.getTenant(),
          first(paramMap, "delegated-provider"), request.getLocale(), null);
    } else if ("show-recover".equals(step)) {
      response = recoverController.doPaintRecoverForm(request.getLocale(), null);
    } else if ("start".equals(step) && oUser.isPresent()) {
      response = doPaintLoginForm(request, null, null);
    } else {
      List<AuthenticationChallege> chagenlles = new ArrayList<>();
      if (null != currentChallenge) {
        chagenlles.addAll(currentChallenge.getChallenges());
      }
      response = doExecLogin(clientDetails, request, paramMap, chagenlles);
    }
    return response;
  }

  private Response doExecLogin(ClientDetails clientDetails, AuthRequest request,
      MultivaluedMap<String, String> paramMap, List<AuthenticationChallege> challenges) {
    String grant = "form";
    String password = securer.decrypt(first(paramMap, "password"));
    AuthenticationResult authenticate = loginUsecase.validatedUserData(request,
        first(paramMap, USERNAME), password, clientDetails, challenges);
    if (authenticate.isRight()) {
      return redirect(Optional.empty(), clientDetails, grant, request, authenticate.getData());
    } else {
      FlowInfo info = map().get(authenticate.getFail().getClass());
      if (null == info) {
        return doPaintLoginForm(request, "Credenciales incorrectas", null);
      } else {
        String username = first(paramMap, USERNAME);
        String tenant = request.getTenant();
        List<AuthenticationChallege> chagenlles = new ArrayList<>();
        chagenlles.add(info.getChageller());
        return info.getFunction()
            .apply(StartFormFlow.builder().locale(request.getLocale()).username(username)
                .request(request).challenges(chagenlles)
                .session(sessionCookie(username, chagenlles, tenant)).build());
      }
    }
  }

  private Response redirectError(AuthRequest request, String message) {
    String to = request.getRedirect().orElse("") + "#error="
        + URLEncoder.encode(message, StandardCharsets.UTF_8);
    return securer.secureRedirectResponse(Response.status(302).location(buildUrl(to))
        .cookie(new NewCookie.Builder(AUTH_SESSION_ID).value(null).sameSite(SameSite.NONE)
            .path(OAUTH_OPENID + request.getTenant()).secure(true).httpOnly(true).build()));
  }

  private Response redirect(Optional<String> cookie, ClientDetails clientDetails, String grant,
      AuthRequest request, AuthenticationData validationData) {
    String uid = UUID.randomUUID().toString();
    if (cookie.isPresent()) {
      sessionStore.updateSession(uid, cookie.get());
    } else {
      String csid = securer.verifyToken(first(formParams, "csid")).orElseThrow();
      sessionStore.saveSession(uid, clientDetails, grant, validationData, csid);
    }
    validationData.setAudiences(request.getAudiences());
    String type = request.getResponseType().orElse("code");
    String to;
    if ("code".equals(type)) {
      String redirect = request.getRedirect().orElseThrow();
      String separator = "?";
      if (redirect.endsWith("?")) {
        separator = "";
      } else if (redirect.contains("?")) {
        separator = "&";
      }
      String code = temporalStore.registerTemporalAuthCode(
          TemporalAuthCode.builder().client(clientDetails).request(request)
              .nonce(request.getNonce().orElse(null)).data(validationData).build());
      to = redirect + separator + "code=" + code + "&state=" + request.getState().orElseThrow();
    } else {
      IdToken buildIdToken =
          tokenBuilder.buildIdToken(request.getTenant(), request.getState().orElseThrow(),
              request.getNonce().orElse(null), clientDetails, grant, validationData);
      to = request.getRedirect().orElseThrow() + "#state=" + request.getState().orElseThrow()
          + "&session_state=" + buildIdToken.getSessionState() + "" + "&iss="
          + URLEncoder.encode(buildIdToken.getIss(), StandardCharsets.UTF_8) + "&id_token="
          + buildIdToken.getIdToken() + "&access_token=" + buildIdToken.getAccessToken()
          + "&token_type=" + buildIdToken.getTokenType() + "&expires_in="
          + buildIdToken.getExpiresIn();
    }
    return securer.secureRedirectResponse(Response.status(302).location(buildUrl(to))
        .cookie(new NewCookie.Builder(AUTH_SESSION_ID).value(uid).sameSite(SameSite.NONE)
            .path(OAUTH_OPENID + request.getTenant()).secure(true).httpOnly(true).build()));
  }

  private NewCookie sessionCookie(String username, List<AuthenticationChallege> chagenlles,
      String tenant) {
    Challenge ch = new Challenge();
    ch.setUsername(username);
    ch.setChallenges(chagenlles);
    String token = tokenBuilder.buildChallengerToken(tenant, ch, Duration.ofHours(1));
    return new NewCookie.Builder(PRE_SESSION_ID).value(token).sameSite(SameSite.NONE)
        .path(OAUTH_OPENID + tenant).secure(true).httpOnly(true).build();
  }

  private Optional<Challenge> preSessionUsername(String cookie, String tenant) {
    Optional<Challenge> verifyChalleger;
    if (StringUtils.isEmpty(cookie)) {
      verifyChalleger = Optional.empty();
    } else {
      verifyChalleger = tokenBuilder.verifyChalleger(Challenge.class, cookie, tenant);
      verifyChalleger.ifPresent(ch -> currentChallenge = ch);
    }
    return verifyChalleger;
  }

  private Optional<ClientDetails> loadClient(final AuthRequest request) {
    return clientRetrieve.loadPublic(request.getTenant(), request.getClientId().orElseThrow(),
        request.getRedirect().orElseThrow());
  }

  public static String i18n(Locale locale, String key, Object... arguments) {
    synchronized (TRANSLATIONS) {
      TRANSLATIONS.computeIfAbsent(locale, k -> YamlLocaleMessages.load("/messages/oauth", k));
    }
    return TRANSLATIONS.get(locale).get(key, arguments);
  }

  public static String first(Map<String, List<String>> paramMap, String key) {
    List<String> list = paramMap.get(key);
    return null == list || list.isEmpty() ? "" : list.get(0);
  }

  public static URI buildUrl(String url) {
    try {
      return new URI(url);
    } catch (URISyntaxException ex) {
      throw new IllegalArgumentException("Source url " + url + " is illegal", ex);
    }
  }

  private Response revolve(StepResult result) {
    List<AuthenticationChallege> chagenlles = new ArrayList<>();
    if (null != currentChallenge) {
      chagenlles.addAll(currentChallenge.getChallenges());
    }
    AuthenticationResult fillPreAuthenticated = loginUsecase.fillPreAuthenticated(
        result.getRequest(), result.getUsername(), result.getClientDetails(), chagenlles);
    if (fillPreAuthenticated.isRight()) {
      String grant = "form";
      return redirect(Optional.empty(), result.getClientDetails(), grant, result.getRequest(),
          fillPreAuthenticated.getData());
    } else {
      FlowInfo info = map().get(fillPreAuthenticated.getFail().getClass());
      if (null == info) {
        return doPaintLoginForm(result.getRequest(), "Credenciales incorrectas", null);
      } else {
        chagenlles.add(info.getChageller());
        return info.getFunction().apply(StartFormFlow.builder().username(result.getUsername())
            .request(result.getRequest()).challenges(chagenlles)
            .locale(result.getRequest().getLocale())
            .session(
                sessionCookie(result.getUsername(), chagenlles, result.getRequest().getTenant()))
            .build());
      }
    }
  }

  @Synchronized
  private Map<Class<? extends AuthenticationException>, FlowInfo> map() {
    if (loginErrorMappers.isEmpty()) {
      loginErrorMappers.put(MfaRequiredException.class,
          FlowInfo.builder().chageller(mfaController.getChallenge())
              .function(mfa -> mfaController.doPaintMfaForm(mfa.getLocale(), mfa.getSession()))
              .build());
      loginErrorMappers.put(ConsentRequiredException.class,
          FlowInfo.builder().chageller(consentController.getChallenge())
              .function(mfa -> consentController.doPaintConsent(mfa.getLocale(), mfa.getRequest(),
                  mfa.getUsername(), mfa.getSession()))
              .build());
      loginErrorMappers.put(NewPasswordRequiredException.class,
          FlowInfo.builder().chageller(newPassController.getChallenge())
              .function(
                  mfa -> newPassController.doPaintNewPassForm(mfa.getLocale(), mfa.getSession()))
              .build());
      loginErrorMappers.put(NewMfaRequiredException.class,
          FlowInfo.builder().chageller(newMfaController.getChallenge())
              .function(mfa -> newMfaController.doPaintNewMfaForm(mfa.getRequest(),
                  mfa.getUsername(), mfa.getLocale(), mfa.getSession()))
              .build());
    }
    return loginErrorMappers;
  }
}
