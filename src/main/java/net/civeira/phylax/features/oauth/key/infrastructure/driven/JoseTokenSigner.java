/* @autogenerated */
package net.civeira.phylax.features.oauth.key.infrastructure.driven;

import java.io.IOException;
import java.math.BigInteger;
import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.EncodedKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.RSAPrivateKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.text.StringEscapeUtils;
import org.eclipse.microprofile.config.inject.ConfigProperty;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTCreator.Builder;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTDecodeException;
import com.auth0.jwt.exceptions.SignatureVerificationException;
import com.auth0.jwt.exceptions.TokenExpiredException;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.auth0.jwt.interfaces.RSAKeyProvider;

import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.exception.NotAllowedException;
import net.civeira.phylax.common.infrastructure.CurrentRequest;
import net.civeira.phylax.features.oauth.key.domain.Jks;
import net.civeira.phylax.features.oauth.key.domain.JwkSet;
import net.civeira.phylax.features.oauth.key.domain.KeyConfig;
import net.civeira.phylax.features.oauth.key.domain.KeyInformation;
import net.civeira.phylax.features.oauth.key.domain.PublicKeyInformation;
import net.civeira.phylax.features.oauth.key.domain.gateway.TokenSigner;
import net.civeira.phylax.features.oauth.key.domain.gateway.TokenStoreGateway;

@Slf4j
@ApplicationScoped
@RequiredArgsConstructor
public class JoseTokenSigner implements TokenSigner {
  private final CurrentRequest current;
  @ConfigProperty(name = "oauth.jwt.authorization.key-duration", defaultValue = "7d")
  private final Duration keyDuration;
  @ConfigProperty(name = "oauth.jwt.authorization.key-futures", defaultValue = "3")
  private final int futureKeysNumber;
  private final TokenStoreGateway repository;
  @ConfigProperty(name = "oauth.jwt.authorization.store-pass")
  private final String storePass;
  @ConfigProperty(name = "oauth.jwt.authorization.store-pair")
  private final String storePair;

  @Override
  public String sign(String tenant, Builder data, Instant expiration) {
    KeyInformation currentKey = currentKey(tenant);
    return data.withExpiresAt(expiration).withKeyId(currentKey.getKeyId())
        .sign(signAlgoritm(currentKey));
  }

  @Override
  public JwkSet keysAsJwks(String tenant) {
    List<Jks> syncCopy = new ArrayList<>();
    List<PublicKeyInformation> publicKeys = repository.listPublicKeys(tenant);
    for (PublicKeyInformation stream : publicKeys) {
      try {
        syncCopy.add(generateJWK(stream.getKeyId(), readKey(stream.getPublicKey())));
      } catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException ex) {
        logError("Unable to read public key", ex);
      }
    }
    return JwkSet.builder().keys(syncCopy).build();
  }

  @Override
  public String signKeypass(String tenant, Builder data, Instant expiration) {
    KeyInformation currentKey = currentKey(tenant);
    return data.withExpiresAt(expiration).withKeyId(currentKey.getPrivateKey())
        .sign(signAlgoritm(currentKey));
  }

  @Override
  public Map<String, Object> verifyTokenPayload(String tenant, String token) {
    Optional<DecodedJWT> decoded = verifyToken(tenant, token, true);
    if (decoded.isEmpty()) {
      return Map.of();
    }
    Map<String, Object> payload = new HashMap<>();
    decoded.get().getClaims().forEach((key, claim) -> payload.put(key, claim.as(Object.class)));
    return payload;
  }

  @Override
  public String verifiedKeypass(String tenant, String token) {
    Optional<DecodedJWT> decoded = verifyToken(tenant, token, false);
    return decoded.map(DecodedJWT::getKeyId).orElse("");
  }

  private Optional<DecodedJWT> verifyToken(String tenant, String token, boolean issuerValidation) {
    String keyId = extractSignerId(token).orElse(null);
    List<PublicKeyInformation> publicKeys = repository.listPublicKeys(tenant);
    List<PublicKeyInformation> candidates = new ArrayList<>();
    if (null != keyId) {
      publicKeys.stream().filter(key -> keyId.equals(key.getKeyId())).forEach(candidates::add);
    }
    if (candidates.isEmpty()) {
      candidates.addAll(publicKeys);
    }
    for (PublicKeyInformation key : candidates) {
      Optional<DecodedJWT> decode = decode(key, tenant, token, issuerValidation);
      if (decode.isPresent()) {
        return decode;
      }
    }
    return Optional.empty();
  }

  private Optional<String> extractSignerId(String token) {
    try {
      DecodedJWT jwt = JWT.decode(token);
      return Optional.ofNullable(jwt.getKeyId());
    } catch (JWTDecodeException ex) {
      return Optional.empty();
    }
  }

  private KeyInformation currentKey(String tenant) {
    checkNewNeeded(tenant);
    return repository.currentKey(tenant)
        .orElseThrow(() -> new IllegalStateException("There is no active key"));
  }

  private Optional<DecodedJWT> decode(PublicKeyInformation key, String tenant, String token,
      boolean issuerValidation) {
    try {
      Algorithm algorithm = Algorithm.RSA256(readKey(key.getPublicKey()));
      if (issuerValidation) {
        return Optional
            .of(JWT.require(algorithm).withIssuer(getIssuer(tenant)).build().verify(token));
      }
      return Optional.of(JWT.require(algorithm).build().verify(token));
    } catch (TokenExpiredException ex) {
      logError("Expired token", ex);
      throw new NotAllowedException("");
    } catch (JWTDecodeException de) {
      logError("Unable to decode token", de);
      return Optional.empty();
    } catch (SignatureVerificationException se) {
      logError("Wrong signature", se);
      return Optional.empty();
    } catch (IOException | GeneralSecurityException e) {
      logError("General auth error", e);
      return Optional.empty();
    }
  }

  private String getIssuer(String tenant) {
    return current.getPublicHost() + "/oauth/openid/" + tenant;
  }

  private Algorithm signAlgoritm(KeyInformation key) {
    try {
      byte[] privateKeyBytes = java.util.Base64.getDecoder().decode(key.getPrivateKey());
      String publicKeyPEM = key.getPublicKey().replace("-----BEGIN PUBLIC KEY-----", "")
          .replace("-----END PUBLIC KEY-----", "").replaceAll("\\s", "");
      byte[] keyBytes = java.util.Base64.getDecoder().decode(publicKeyPEM);

      KeyFactory keyFactory = KeyFactory.getInstance("RSA");
      PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);
      RSAPrivateKeySpec rsaSpec =
          keyFactory.getKeySpec(keyFactory.generatePrivate(keySpec), RSAPrivateKeySpec.class);

      PrivateKey privateKey = keyFactory.generatePrivate(
          new RSAPrivateKeySpec(rsaSpec.getModulus(), rsaSpec.getPrivateExponent()));

      X509EncodedKeySpec pkeySpec = new X509EncodedKeySpec(keyBytes);
      PublicKey publicKey = keyFactory.generatePublic(pkeySpec);
      if (!(publicKey instanceof RSAPublicKey)) {
        throw new IllegalArgumentException("La clave publica no es de tipo RSA");
      }

      RSAKeyProvider provider = new RSAKeyProvider() {
        @Override
        public RSAPublicKey getPublicKeyById(String keyId) {
          return (RSAPublicKey) publicKey;
        }

        @Override
        public RSAPrivateKey getPrivateKey() {
          return (RSAPrivateKey) privateKey;
        }

        @Override
        public String getPrivateKeyId() {
          return key.getKeyId();
        }
      };
      return Algorithm.RSA256(provider);
    } catch (GeneralSecurityException e) {
      throw new NotAllowedException(
          "Imposible generar el token, por un error [" + e.getClass() + "]: " + e.getMessage());
    }
  }

  private RSAPublicKey readKey(String publicKeyContent)
      throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
    String base64 = publicKeyContent.replace("\\n", "").replace("-----BEGIN PUBLIC KEY-----", "")
        .replace("-----END PUBLIC KEY-----", "").trim();

    java.util.Base64.Decoder decoder = java.util.Base64.getDecoder();
    byte[] decode = decoder.decode(base64);
    KeyFactory keyFactory = KeyFactory.getInstance("RSA");
    EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(decode);
    return (RSAPublicKey) keyFactory.generatePublic(publicKeySpec);
  }

  private void checkNewNeeded(String tenant) {
    KeyConfig config = KeyConfig.builder().ttl(keyDuration).futures(futureKeysNumber).build();
    Instant expected = Instant.now();
    for (int i = 0; i < config.getFutures(); i++) {
      expected = expected.plus(config.getTtl());
    }
    Instant end = repository.nextKeysExpiration(tenant);

    if (expected.isAfter(end)) {
      Instant since = Instant.now().minusSeconds(3600);
      long differenceInSeconds = Duration.between(since, expected).getSeconds();
      long intervalInSeconds = config.getTtl().getSeconds();
      long numberOfIntervals = (differenceInSeconds / intervalInSeconds) + 1;

      for (int i = 0; i < numberOfIntervals; i++) {
        KeyInformation pair = createKeys();
        repository.saveKey(tenant, pair, since, config.getTtl());
        since = since.plus(config.getTtl());
      }
    }
  }

  private KeyInformation createKeys() {
    try {
      KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
      keyGen.initialize(4096, new SecureRandom());
      KeyPair pair = keyGen.generateKeyPair();
      PublicKey pub = pair.getPublic();
      java.util.Base64.Encoder encoder = java.util.Base64.getEncoder();
      String publicString = "-----BEGIN PUBLIC KEY-----\r\n"
          + encoder.encodeToString(pub.getEncoded()) + "\r\n" + "-----END PUBLIC KEY-----";

      String privateString = encoder.encodeToString(pair.getPrivate().getEncoded());

      return KeyInformation.builder().keyId(UUID.randomUUID().toString()).keyUse("sig").alg("RS256")
          .publicKey(publicString).privateKey(privateString).build();
    } catch (NoSuchAlgorithmException ex) {
      throw new IllegalStateException("There is no RSA algorim to sign", ex);
    }
  }

  private Jks generateJWK(String key, RSAPublicKey rsa) {
    return Jks.builder().kty(rsa.getAlgorithm()).kid(key)
        .n(Base64.encodeBase64URLSafeString(toByteArray(rsa.getModulus())))
        .e(Base64.encodeBase64URLSafeString(rsa.getPublicExponent().toByteArray())).alg("RS256")
        .use("sig").build();
  }

  private static byte[] toByteArray(BigInteger bigInteger) {
    byte[] bytes = bigInteger.toByteArray();
    byte[] result;
    if (bytes.length > 1 && bytes[0] == 0) {
      result = new byte[bytes.length - 1];
      System.arraycopy(bytes, 1, result, 0, result.length);
    } else {
      result = bytes;
    }
    return result;
  }

  private void logError(String message, Exception ex) {
    if (log.isErrorEnabled()) {
      log.error(message + ": {0}", StringEscapeUtils.escapeJson(ex.getMessage()));
    }
  }
}
