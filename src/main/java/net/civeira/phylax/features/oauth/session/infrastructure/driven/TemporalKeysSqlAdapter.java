/* @autogenerated */
package net.civeira.phylax.features.oauth.session.infrastructure.driven;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Optional;
import java.util.UUID;

import javax.sql.DataSource;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.exceptions.SignatureVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.auth0.jwt.interfaces.JWTVerifier;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.enterprise.context.RequestScoped;
import lombok.Builder;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.crypto.AesCipherService;
import net.civeira.phylax.features.oauth.session.domain.gateway.TemporalKeysGateway;
import net.civeira.phylax.features.oauth.session.domain.model.TemporalAuthCode;

@Slf4j
@RequestScoped
@RequiredArgsConstructor
/**
 * Tables: _oauth_temporal_keys, _oauth_temporal_codes
 */
public class TemporalKeysSqlAdapter implements TemporalKeysGateway {
  @Builder
  @Getter
  private static class KeyWrapper {
    final String oldSecret;
    final String secret;
  }

  private final DataSource datasource;
  private final AesCipherService cipher;
  private final ObjectMapper mapper;

  private final Duration keyDuration = Duration.of(1, ChronoUnit.HOURS);
  private final Duration codeDuration = Duration.of(3, ChronoUnit.MINUTES);

  @Override
  public String currentKey() {
    return getCurrent().orElseGet(this::rotateKeys).secret;
  }

  @Override
  public String encrypt(String value) {
    return cipher.encrypt(value, currentKey());
  }

  @Override
  public Optional<String> verifyCypher(String value) {
    KeyWrapper wrapper = getCurrent().orElseThrow();
    Optional<String> current = cipher.decrypt(value, wrapper.secret);
    return current.isPresent() ? current : cipher.decrypt(value, wrapper.oldSecret);
  }

  @Override
  public String registerTemporalAuthCode(TemporalAuthCode code) {
    String sql = "INSERT INTO _oauth_temporal_codes(code, code_data, expiration) VALUES(?,?,?)";
    try (Connection connection = datasource.getConnection()) {
      clearCodes(connection);
      try (PreparedStatement prepareStatement = connection.prepareStatement(sql)) {
        Instant expiration = Instant.now().plus(codeDuration);
        String json = mapper.writeValueAsString(code);
        String uid = UUID.randomUUID().toString();
        prepareStatement.setString(1, uid);
        prepareStatement.setString(2, json);
        prepareStatement.setTimestamp(3, new Timestamp(expiration.toEpochMilli()));
        if (prepareStatement.executeUpdate() != 1) {
          throw new SQLException("Imposible insertar valores");
        }
        return uid;
      }
    } catch (SQLException | JsonProcessingException error) {
      throw new IllegalStateException(error);
    }
  }

  @Override
  public Optional<TemporalAuthCode> retrieveTemporalAuthCode(String code) {
    Optional<TemporalAuthCode> response;
    String sql = "SELECT code_data FROM _oauth_temporal_codes WHERE code = ? and expiration > ?";
    try (Connection connection = datasource.getConnection()) {
      clearCodes(connection);
      try (PreparedStatement prepareStatement = connection.prepareStatement(sql)) {
        prepareStatement.setString(1, code);
        prepareStatement.setTimestamp(2, new Timestamp(Instant.now().toEpochMilli()));
        try (ResultSet executeQuery = prepareStatement.executeQuery()) {
          response = executeQuery.next()
              ? Optional.of(mapper.readValue(executeQuery.getString(1), TemporalAuthCode.class))
              : Optional.empty();
        }
      }
      removeCode(connection, code);
      return response;
    } catch (SQLException | JsonProcessingException error) {
      throw new IllegalStateException(error);
    }
  }

  @Override
  public Optional<String> verifyToken(String token) {
    KeyWrapper wrapper = getCurrent().orElseThrow();
    return verifyToken(token, wrapper.secret, wrapper.oldSecret);
  }

  private void removeCode(Connection connection, String code) throws SQLException {
    String sql = "DELETE FROM _oauth_temporal_codes where code = ? ";
    try (PreparedStatement prepareStatement = connection.prepareStatement(sql)) {
      prepareStatement.setString(1, code);
      prepareStatement.executeUpdate();
    }
  }

  private void clearCodes(Connection connection) throws SQLException {
    String sql = "DELETE FROM _oauth_temporal_codes where expiration < ?";
    try (PreparedStatement prepareStatement = connection.prepareStatement(sql)) {
      prepareStatement.setTimestamp(1, new Timestamp(Instant.now().toEpochMilli()));
      prepareStatement.executeUpdate();
    }
  }

  private KeyWrapper rotateKeys() {
    // FIX: rotar cada hora.... sin schedurle: poniendo un expires en la tabla.
    Optional<KeyWrapper> current = getCurrent();
    String sql =
        current.map(val -> "UPDATE _oauth_temporal_keys set current = ?, old = ?, expiration = ?")
            .orElse("INSERT INTO _oauth_temporal_keys (current, old, expiration) VALUES(?,?,?)");
    String oldSecret = current.map(KeyWrapper::getSecret).orElse("");
    String secret = cipher.generateSecureRandomApiSecret().replace('\'', '"');
    try (Connection connection = datasource.getConnection();
        PreparedStatement prepareStatement = connection.prepareStatement(sql)) {
      prepareStatement.setString(1, secret);
      prepareStatement.setString(2, oldSecret);
      prepareStatement.setTimestamp(3,
          new Timestamp(Instant.now().plus(keyDuration).toEpochMilli()));
      if (prepareStatement.executeUpdate() != 1) {
        throw new SQLException("Imposible insertar valores");
      }
      return KeyWrapper.builder().secret(secret).oldSecret(oldSecret).build();
    } catch (SQLException ex) {
      throw new IllegalStateException(ex);
    }
  }

  private Optional<KeyWrapper> getCurrent() {
    try (Connection connection = datasource.getConnection()) {
      try (PreparedStatement prepareStatement = connection
          .prepareStatement("select current, old from _oauth_temporal_keys where expiration > ?")) {
        prepareStatement.setTimestamp(1, new Timestamp(System.currentTimeMillis()));
        try (ResultSet executeQuery = prepareStatement.executeQuery()) {
          if (executeQuery.next()) {
            return Optional.of(KeyWrapper.builder().secret(executeQuery.getString(1))
                .oldSecret(executeQuery.getString(2)).build());
          } else {
            return Optional.empty();
          }
        }
      }
    } catch (SQLException ex) {
      throw new IllegalStateException(ex);
    }
  }

  private Optional<String> verifyToken(String token, String key, String fallback) {
    try {
      Algorithm algorithm = Algorithm.HMAC256(key);
      JWTVerifier verifier = JWT.require(algorithm).build();
      DecodedJWT jwt = verifier.verify(token);
      return Optional.ofNullable(String.valueOf(jwt.getClaim("identity")));
    } catch (SignatureVerificationException exception) {
      if (null == fallback) {
        log.warn("Unable to verify token", exception);
        return Optional.empty();
      } else {
        return verifyToken(token, fallback, null);
      }
    } catch (JWTVerificationException exception) {
      log.warn("Unable to verify token", exception);
      return Optional.empty();
    }
  }

}
