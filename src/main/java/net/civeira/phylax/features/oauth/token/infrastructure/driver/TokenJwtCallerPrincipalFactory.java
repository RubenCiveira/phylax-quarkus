/* @autogenerated */
package net.civeira.phylax.features.oauth.token.infrastructure.driver;

import java.io.IOException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Base64;
import java.util.List;
import java.util.Optional;

import org.jose4j.jwt.JwtClaims;
import org.jose4j.jwt.consumer.InvalidJwtException;

import com.auth0.jwt.interfaces.DecodedJWT;

import io.smallrye.jwt.auth.principal.DefaultJWTCallerPrincipal;
import io.smallrye.jwt.auth.principal.JWTAuthContextInfo;
import io.smallrye.jwt.auth.principal.JWTCallerPrincipal;
import io.smallrye.jwt.auth.principal.JWTCallerPrincipalFactory;
import io.smallrye.jwt.auth.principal.ParseException;
import jakarta.annotation.Priority;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Alternative;
import jakarta.json.Json;
import jakarta.json.JsonObject;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.features.oauth.token.domain.JwtTokenManager;
import net.civeira.phylax.features.oauth.token.domain.model.PublicKeyInformation;

@Slf4j
@ApplicationScoped
@Alternative
@Priority(1)
@RequiredArgsConstructor
public class TokenJwtCallerPrincipalFactory extends JWTCallerPrincipalFactory {
  @Data
  @RequiredArgsConstructor
  private static class ParsedToken {
    private final JsonObject header;
    private final JwtClaims claims;
    private final JWTCallerPrincipal principal;
  }

  private final JwtTokenManager tokenManager;

  private final Duration valid = Duration.ofHours(1);

  private List<PublicKeyInformation> cached;
  private LocalDateTime until = LocalDateTime.now();

  @Override
  public JWTCallerPrincipal parse(String token, JWTAuthContextInfo authContextInfo)
      throws ParseException {
    // No token => NUNCA hagas nada raro
    if (token == null || token.isBlank()) {
      throw new ParseException("Empty token", null);
    }
    try {
      ParsedToken parsed = parseHeaderAndClaims(token);
      String kid = parsed.getHeader().getString("kid", null);
      Optional<PublicKeyInformation> jk = findKey(kid);
      if (jk.isPresent()) {
        Optional<DecodedJWT> decodeWithoutTenant =
            tokenManager.decodeWithoutTenant(jk.get(), token);
        if (decodeWithoutTenant.isPresent()) {
          return parsed.getPrincipal();
        } else {
          throw new ParseException("Invalid JWT sign", null);
        }
      }
    } catch (NoSuchAlgorithmException | InvalidKeySpecException | IOException e) {
      log.error("Unable to get keys", e);
      System.out.println("UNABLE TO PARSE");
      e.printStackTrace();
    } catch (RuntimeException ex) {
      ex.printStackTrace();
      throw ex;
    }
    throw new ParseException("Invalid JWT token", null);
  }

  private Optional<PublicKeyInformation> findKey(String kid)
      throws NoSuchAlgorithmException, InvalidKeySpecException, IOException {
    LocalDateTime now = LocalDateTime.now();
    if (now.isAfter(until)) {
      cached = tokenManager.getPublicKeys();
      until = now.plus(valid);
    }
    return cached.stream().filter(jk -> kid.equals(jk.getKeyId())).findFirst();
  }

  private static ParsedToken parseHeaderAndClaims(String token) throws ParseException {
    try {
      String[] parts = token.split("\\.");
      if (parts.length != 3) {
        throw new ParseException("Invalid JWT format, expected 3 parts but got " + parts.length);
      }

      // 1) HEADER
      String headerJson =
          new String(Base64.getUrlDecoder().decode(parts[0]), StandardCharsets.UTF_8);
      JsonObject header = Json.createReader(new StringReader(headerJson)).readObject();

      // 2) PAYLOAD / CLAIMS
      String claimsJson =
          new String(Base64.getUrlDecoder().decode(parts[1]), StandardCharsets.UTF_8);
      JwtClaims claims = JwtClaims.parse(claimsJson);
      System.out.println("====");
      System.out.println(" > CLAIMS " + claims);

      // 3) PRINCIPAL (SmallRye)
      JWTCallerPrincipal principal = new DefaultJWTCallerPrincipal(claims);

      return new ParsedToken(header, claims, principal);
    } catch (InvalidJwtException e) {
      throw new ParseException(e.getMessage(), e);
    } catch (IllegalArgumentException e) {
      // errores de Base64, etc.
      throw new ParseException("Error decoding JWT: " + e.getMessage(), e);
    }
  }
}
