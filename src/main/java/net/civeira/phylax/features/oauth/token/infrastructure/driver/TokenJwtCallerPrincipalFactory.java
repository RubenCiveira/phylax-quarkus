/* @autogenerated */
package net.civeira.phylax.features.oauth.token.infrastructure.driver;

import java.io.IOException;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDateTime;
import java.util.Base64;
import java.util.List;
import java.util.Optional;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.jose4j.jwt.JwtClaims;
import org.jose4j.jwt.consumer.InvalidJwtException;

import com.auth0.jwt.interfaces.DecodedJWT;
import io.smallrye.jwt.auth.principal.DefaultJWTCallerPrincipal;
import io.smallrye.jwt.auth.principal.JWTAuthContextInfo;
import io.smallrye.jwt.auth.principal.JWTCallerPrincipal;
import io.smallrye.jwt.auth.principal.JWTCallerPrincipalFactory;
import io.smallrye.jwt.auth.principal.ParseException;
import jakarta.annotation.Priority;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Alternative;
import jakarta.json.Json;
import jakarta.json.JsonObject;
import lombok.Builder;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.features.oauth.token.domain.JwtTokenManager;
import net.civeira.phylax.features.oauth.token.domain.model.PublicKeyInformation;

@ApplicationScoped
@Alternative
@Priority(1)
public class TokenJwtCallerPrincipalFactory extends JWTCallerPrincipalFactory {
  @Data
  @RequiredArgsConstructor
  private static class ParsedToken {
    private final JsonObject header;
    private final JwtClaims claims;
    private final JWTCallerPrincipal principal;
  }
  
  /**
   * Hold non final fields to allow caching
   * @author ruben.civeiraiglesia
   *
   */
  @Data
  @Builder
  private static class Cacheable {
    private final String error;
    private final Throwable exception;
    private final JWTCallerPrincipal principal;
    private final long until;
    
    public static Cacheable ok(JWTCallerPrincipal principal, Instant instant) {
      return Cacheable.builder()
          .principal(principal).until( instant.toEpochMilli() )
          .build();
    }
    
    public static Cacheable fail(String error) {
      return Cacheable.builder()
          .error(error)
          .build();
    }
    
    public static Cacheable fail(String error, Throwable th) {
      return Cacheable.builder()
          .error(error)
          .exception(th)
          .build();
    }
    
    JWTCallerPrincipal principalLoaded() throws ParseException {
      if( null != principal && until > Instant.now().toEpochMilli() ) {
        return principal;
      } else if( null != principal ) {
        throw new ParseException("Expired token");
      } else {
        System.err.println("> WRONG TOKEN");
        throw new ParseException(error, getException());
      }
    }
  }

  /**
   * @autogenerated CacheAdaterGatewayGenerator
   */
  private final JwtTokenManager tokenManager;

  private final Duration valid;
  
  private List<PublicKeyInformation> cached;
  
  private LocalDateTime until = LocalDateTime.now();

  public TokenJwtCallerPrincipalFactory(
      @ConfigProperty(name = "mp.jwt.verify.memory.jks-ttl", defaultValue = "1h")
      Duration duration,
      JwtTokenManager tokenManager) {
    super();
    this.valid = duration;
    this.tokenManager = tokenManager;
  }

  @Override
  public JWTCallerPrincipal parse(String token, JWTAuthContextInfo authContextInfo)
      throws ParseException {
    if (token == null || token.isBlank()) {
      throw new ParseException("Empty token", null);
    }
    return this.caller(token).principalLoaded();
  }
  
  private Cacheable caller(String token) {
    ParsedToken parsed;
    try {
      parsed = parseHeaderAndClaims(token);
    } catch (ParseException e) {
      return Cacheable.fail("Unable to parse token",e );
    }
    try {
      String kid = parsed.getHeader().getString("kid", null);
      Optional<PublicKeyInformation> jk = findKey(kid);
      if (jk.isPresent()) {
        Optional<DecodedJWT> decodeWithoutTenant =
            tokenManager.decodeWithoutTenant(jk.get(), token);
        if (decodeWithoutTenant.isPresent()) {
          DecodedJWT decodedJWT = decodeWithoutTenant.get();
          return Cacheable.ok( parsed.getPrincipal(), decodedJWT.getExpiresAtAsInstant() );
        } else {
          return Cacheable.fail("Invalid JWT sign");
        }
      } else {
        return Cacheable.fail("No key for kid " + kid );
      }
    } catch (NoSuchAlgorithmException | InvalidKeySpecException | IOException e) {
      return Cacheable.fail("Unable to load the keys", e);
    }
  }

  private Optional<PublicKeyInformation> findKey(String kid)
      throws NoSuchAlgorithmException, InvalidKeySpecException, IOException {
    LocalDateTime now = LocalDateTime.now();
    if (now.isAfter(until)) {
      cached = tokenManager.getPublicKeys();
      until = now.plus(valid);
    }
    return cached.stream().filter(jk -> kid.equals(jk.getKeyId())).findFirst();
  }

  private static ParsedToken parseHeaderAndClaims(String token) throws ParseException {
    try {
      String[] parts = token.split("\\.");
      if (parts.length != 3) {
        throw new ParseException("Invalid JWT format, expected 3 parts but got " + parts.length);
      }

      // 1) HEADER
      String headerJson =
          new String(Base64.getUrlDecoder().decode(parts[0]), StandardCharsets.UTF_8);
      JsonObject header = Json.createReader(new StringReader(headerJson)).readObject();

      // 2) PAYLOAD / CLAIMS
      String claimsJson =
          new String(Base64.getUrlDecoder().decode(parts[1]), StandardCharsets.UTF_8);
      JwtClaims claims = JwtClaims.parse(claimsJson);

      // 3) PRINCIPAL (SmallRye)
      JWTCallerPrincipal principal = new DefaultJWTCallerPrincipal(claims);

      return new ParsedToken(header, claims, principal);
    } catch (InvalidJwtException e) {
      throw new ParseException(e.getMessage(), e);
    } catch (IllegalArgumentException e) {
      // errores de Base64, etc.
      throw new ParseException("Error decoding JWT: " + e.getMessage(), e);
    }
  }
}
