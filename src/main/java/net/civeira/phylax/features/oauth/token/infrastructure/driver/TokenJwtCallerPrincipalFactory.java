/* @autogenerated */
package net.civeira.phylax.features.oauth.token.infrastructure.driver;

import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Base64;

import org.jose4j.jwt.JwtClaims;
import org.jose4j.jwt.MalformedClaimException;
import org.jose4j.jwt.NumericDate;
import org.jose4j.jwt.consumer.InvalidJwtException;

import io.smallrye.jwt.auth.principal.DefaultJWTCallerPrincipal;
import io.smallrye.jwt.auth.principal.JWTAuthContextInfo;
import io.smallrye.jwt.auth.principal.JWTCallerPrincipal;
import io.smallrye.jwt.auth.principal.JWTCallerPrincipalFactory;
import io.smallrye.jwt.auth.principal.ParseException;
import jakarta.annotation.Priority;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Alternative;
import jakarta.json.Json;
import jakarta.json.JsonObject;
import lombok.Builder;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.features.oauth.key.domain.gateway.TokenSigner;

@ApplicationScoped
@Alternative
@Priority(1)
public class TokenJwtCallerPrincipalFactory extends JWTCallerPrincipalFactory {
  @Data
  @RequiredArgsConstructor
  private static class ParsedToken {
    private final JsonObject header;
    private final JwtClaims claims;
    private final JWTCallerPrincipal principal;
  }

  /**
   * Hold non final fields to allow caching
   * 
   * @author ruben.civeiraiglesia
   *
   */
  @Data
  @Builder
  private static class Cacheable {
    private final String error;
    private final Throwable exception;
    private final JWTCallerPrincipal principal;
    private final long until;

    public static Cacheable ok(JWTCallerPrincipal principal, Instant instant) {
      return Cacheable.builder().principal(principal).until(instant.toEpochMilli()).build();
    }

    public static Cacheable fail(String error) {
      return Cacheable.builder().error(error).build();
    }

    public static Cacheable fail(String error, Throwable th) {
      return Cacheable.builder().error(error).exception(th).build();
    }

    JWTCallerPrincipal principalLoaded() throws ParseException {
      if (null != principal && until > Instant.now().toEpochMilli()) {
        return principal;
      } else if (null != principal) {
        throw new ParseException("Expired token");
      } else {
        System.err.println("> WRONG TOKEN");
        throw new ParseException(error, getException());
      }
    }
  }

  /**
   * @autogenerated CacheAdaterGatewayGenerator
   */
  private final TokenSigner tokenSigner;

  public TokenJwtCallerPrincipalFactory(TokenSigner tokenSigner) {
    super();
    this.tokenSigner = tokenSigner;
  }

  @Override
  public JWTCallerPrincipal parse(String token, JWTAuthContextInfo authContextInfo)
      throws ParseException {
    if (token == null || token.isBlank()) {
      throw new ParseException("Empty token", null);
    }
    return this.caller(token).principalLoaded();
  }

  private Cacheable caller(String token) {
    ParsedToken parsed;
    try {
      parsed = parseHeaderAndClaims(token);
    } catch (ParseException e) {
      return Cacheable.fail("Unable to parse token", e);
    }
    try {
      String keypass = tokenSigner.verifiedKeypass("", token);
      if (null == keypass || keypass.isBlank()) {
        return Cacheable.fail("Invalid JWT sign");
      }
      Instant expiresAt = expirationFromClaims(parsed.getClaims());
      return Cacheable.ok(parsed.getPrincipal(), expiresAt);
    } catch (RuntimeException e) {
      return Cacheable.fail("Unable to load the keys", e);
    }
  }

  private Instant expirationFromClaims(JwtClaims claims) {
    try {
      NumericDate expiration = claims.getExpirationTime();
      if (null != expiration) {
        return Instant.ofEpochSecond((long) expiration.getValue());
      }
    } catch (RuntimeException | MalformedClaimException ex) {
      return Instant.now();
    }
    return Instant.now();
  }

  private static ParsedToken parseHeaderAndClaims(String token) throws ParseException {
    try {
      String[] parts = token.split("\\.");
      if (parts.length != 3) {
        throw new ParseException("Invalid JWT format, expected 3 parts but got " + parts.length);
      }

      // 1) HEADER
      String headerJson =
          new String(Base64.getUrlDecoder().decode(parts[0]), StandardCharsets.UTF_8);
      JsonObject header = Json.createReader(new StringReader(headerJson)).readObject();

      // 2) PAYLOAD / CLAIMS
      String claimsJson =
          new String(Base64.getUrlDecoder().decode(parts[1]), StandardCharsets.UTF_8);
      JwtClaims claims = JwtClaims.parse(claimsJson);

      // 3) PRINCIPAL (SmallRye)
      JWTCallerPrincipal principal = new DefaultJWTCallerPrincipal(claims);

      return new ParsedToken(header, claims, principal);
    } catch (InvalidJwtException e) {
      throw new ParseException(e.getMessage(), e);
    } catch (IllegalArgumentException e) {
      // errores de Base64, etc.
      throw new ParseException("Error decoding JWT: " + e.getMessage(), e);
    }
  }
}
