/* @autogenerated */
/* @autogenerated */
package net.civeira.phylax.features.oauth.authentication.infrastructure.driver.html;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.UUID;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.enterprise.context.RequestScoped;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.HttpHeaders;
import jakarta.ws.rs.core.MultivaluedMap;
import jakarta.ws.rs.core.UriInfo;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthRequest;
import net.civeira.phylax.features.oauth.delegated.domain.gateway.DelegatedStoreGateway;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedAccessExternalProvider;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedAccessExternalProvider.RequestInfo;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedAccessExternalProvider.ResponseInfo;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedAccessExternalProvider.TokenInfo;
import net.civeira.phylax.features.oauth.delegated.domain.model.DelegatedRequestDetails;
import net.civeira.phylax.features.oauth.delegated.domain.spi.DelegatedAccessAuthValidatorSpi;

@Path("")
@RequestScoped
@RequiredArgsConstructor
public class DelegatedAccessController {
  private static final Logger LOGGER = LoggerFactory.getLogger(DelegatedAccessController.class);
  private static final String TEXT_HTML = "text/html";

  private boolean fallbackHtmlForSubmit = false;
  private final DelegatedStoreGateway repository;
  private final DelegatedAccessAuthValidatorSpi ssoManager;

  @GET
  @Path("oauth/openid/{tenant}/delegated/redirect/{provider}")
  @Produces(TEXT_HTML)
  public String loginGet(final @PathParam("tenant") String tenant,
      @PathParam("provider") final String provider, final @Context UriInfo req,
      final @Context HttpHeaders headers) throws IOException {
    // El parametro back indica ha donde volver tras hacer el login.
    DelegatedRequestDetails request = DelegatedRequestDetails.builder().provider(provider)
        .externalUrl(getHost(req) + "/oauth/openid/-/delegated/authorization/" + provider).build();
    String back = req.getQueryParameters().getFirst("back");

    return buildRequest(new AuthRequest(tenant, req, headers), request)
        .map(msg -> writeLogin(tenant, null == back ? "*" : back, msg))
        .orElse("<!doctype html><html><h1>No provider for " + provider + "</h1></html>");
  }

  @POST
  @Path("oauth/openid/{tenant}/delegated/token/{provider}")
  @Produces(TEXT_HTML)
  public String entryProyectPost(final @PathParam("tenant") String tenant,
      final @PathParam("provider") String provider, final @Context UriInfo req,
      final @Context HttpHeaders headers, final MultivaluedMap<String, String> paramMap)
      throws IOException {
    DelegatedRequestDetails detail = DelegatedRequestDetails.builder().provider(provider)
        .externalUrl(getHost(req) + "/oauth/openid/-/delegated/authorization/" + provider).build();
    Map<String, String[]> params = new HashMap<>();
    paramMap.entrySet()
        .forEach(entry -> params.put(entry.getKey(), entry.getValue().toArray(new String[0])));
    AuthRequest request = new AuthRequest(tenant, req, headers);
    return buildResponse(request, detail, params)
        .map(response -> writeProyectEntry(request, detail, response))
        .orElse("<!doctype html><html><h1>No provider for " + provider + "</h1></html>");
  }

  @GET
  @Path("oauth/openid/-/delegated/authorization/{provider}")
  @Produces(TEXT_HTML)
  public String entryGet(@PathParam("provider") final String provider, final @Context UriInfo info)
      throws IOException {
    return writeEntry(provider, info, info.getQueryParameters());
  }

  @POST
  @Path("oauth/openid/-/delegated/authorization/{provider}")
  @Produces(TEXT_HTML)
  public String entryPost(@PathParam("provider") final String provider, final @Context UriInfo info,
      final MultivaluedMap<String, String> paramMap) throws IOException {
    return writeEntry(provider, info, paramMap);
  }

  private String writeLogin(String tenant, String back, RequestInfo request) {
    String formMethod = (request.isWithPost() ? "POST" : "GET");
    StringBuilder formHiddens = new StringBuilder();
    for (Entry<String, String> entry : request.getParams().entrySet()) {
      formHiddens.append("<input type=\"hidden\" name=\"" + entry.getKey() + "\" value=\""
          + entry.getValue() + "\" />");
    }


    return "<!doctype html><html><head></head><body>" + "<form action=\"" + request.getTargetUrl()
        + "\" id=\"form\" method=\"" + formMethod + "\">" + formHiddens
        + (fallbackHtmlForSubmit ? "<input type=\"submit\">" : "") + "</form>"
        + (fallbackHtmlForSubmit
            ? "<h1>" + request.getTitle() + "</h1>" + "<p>" + request.getMessage() + "</p>"
            : "")
        + "</body>" + "<script>" + "function setCookie(cname, cvalue, exhours) {"
        + "const d = new Date();" + "d.setTime(d.getTime() + (exhours*60*60*1000));"
        + "let expires = \"expires=\"+ d.toUTCString();"
        + "document.cookie = cname + \"=\" + cvalue + \";\" + expires + \";path=/\";" + "}"
        + "setCookie(\"back\", \"" + encode(back) + "\", 1);" + "setCookie(\"from\", \""
        + encode(tenant + "/") + "\", 1);" + "document.getElementById('form').submit();"
        + "</script>" + "</html>";
  }

  private String encode(String param) {
    return URLEncoder.encode(param, StandardCharsets.UTF_8);
  }

  private String writeEntry(String provider, UriInfo req,
      MultivaluedMap<String, String> parameterNames) {
    StringBuilder fromHiddens = new StringBuilder();
    // MultivaluedMap<String, String> parameterNames = req.getQueryParameters();
    parameterNames.forEach((key, value) -> {
      fromHiddens
          .append("<input type=\"hidden\" name=\"" + key + "\" value=\"" + value.get(0) + "\" />");
    });
    return "<!doctype html><html><head></head><body>" + "<form id=\"form\" method=\"POST\">"
        + fromHiddens + (fallbackHtmlForSubmit ? "<input type=\"submit\">" : "") + "</form>"
        + "</body>" + "<script>" + "function getCookie(cname) {" + "let name = cname + \"=\";"
        + "let decodedCookie = decodeURIComponent(document.cookie);"
        + "let ca = decodedCookie.split(';');" + "for(let i = 0; i <ca.length; i++) {"
        + "let c = ca[i];" + "while (c.charAt(0) == ' ') {"
        + "c = c.substring(1); } if (c.indexOf(name) == 0) {"
        + "return c.substring(name.length, c.length);}}return \"\";" + "}"
        + "var from = getCookie(\"from\");" + "var form = document.getElementById('form');"
        + "form.action = \"/oauth/openid/\" + (from ? from : \"-\") + \"/delegated/token/"
        + provider + "\";" + "form.submit();" + "</script></html>";
  }

  private String writeProyectEntry(final AuthRequest request, DelegatedRequestDetails detail,
      ResponseInfo response) {
    try {
      String code = UUID.randomUUID().toString();
      repository.save(null, code, buildToken(request, detail, response));
      // Tenemos que saber a donde enviarlo, y darle el token de familia.
      return "<!doctype html><html><head></head><body>"
          + (fallbackHtmlForSubmit
              ? "<h1>" + response.getTitle() + "</h1>" + "<p>" + response.getMessage() + "</p>"
              : "")
          + "</body><script>function getCookie(cname) {" + "let name = cname + \"=\";"
          + "let decodedCookie = decodeURIComponent(document.cookie);"
          + "let ca = decodedCookie.split(';');" + "  for(let i = 0; i <ca.length; i++) {"
          + "let c = ca[i]; while (c.charAt(0) == ' ') {"
          + "c = c.substring(1);}if (c.indexOf(name) == 0) {"
          + "return c.substring(name.length, c.length);" + "}" + "}" + "return \"\";" + "}"
          + "var back = decodeURIComponent( getCookie(\"back\") );" + "document.location = back + '"
          + code + "';" + "</script>" + "</html>";
    } catch (IllegalStateException ex) {
      LOGGER.error("Unable to store token on his db", ex);
      return "<!doctype html><html><body><h1>Error interno</h1></body></html>";
    }
  }

  private static String getHost(UriInfo request) {
    String fullURL = request.getRequestUri().toString();
    return fullURL.substring(0, StringUtils.ordinalIndexOf(fullURL, "/", 3));
  }

  private Optional<RequestInfo> buildRequest(final AuthRequest request,
      DelegatedRequestDetails detail) {
    RequestInfo result = null;
    for (DelegatedAccessExternalProvider provider : ssoManager.providers(request)) {
      if (provider.getId(request).equals(detail.getProvider())) {
        result = provider.request(request, detail);
        break;
      }
    }
    return Optional.ofNullable(result);
  }

  private Optional<ResponseInfo> buildResponse(final AuthRequest request,
      DelegatedRequestDetails detail, Map<String, String[]> properties) {
    ResponseInfo response = null;
    for (DelegatedAccessExternalProvider ssoProvider : ssoManager.providers(request)) {
      if (ssoProvider.getId(request).equals(detail.getProvider())) {
        response = ssoProvider.response(request, detail, properties);
        break;
      }
    }
    return Optional.ofNullable(response);
  }

  private TokenInfo buildToken(final AuthRequest request, final DelegatedRequestDetails detail,
      ResponseInfo response) {
    String innerToken = response.getInnerToken();
    TokenInfo json = new TokenInfo();
    json.setRequest(request);
    json.setProvider(detail.getProvider());
    json.setExternUrl(detail.getExternalUrl());
    json.setInnerToken(innerToken);
    return json;
  }
}
