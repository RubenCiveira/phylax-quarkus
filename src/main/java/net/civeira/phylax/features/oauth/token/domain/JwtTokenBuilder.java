/* @autogenerated */
package net.civeira.phylax.features.oauth.token.domain;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.UUID;

import org.eclipse.microprofile.config.ConfigProvider;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTCreator.Builder;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.enterprise.context.RequestScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.exception.NotAllowedException;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthRequest;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationData;
import net.civeira.phylax.features.oauth.client.domain.model.ClientDetails;
import net.civeira.phylax.features.oauth.token.domain.model.AutorizationToken;
import net.civeira.phylax.features.oauth.token.domain.model.IdToken;
import net.civeira.phylax.features.oauth.token.domain.model.KeyInformation;
import net.civeira.phylax.features.oauth.token.domain.model.MfaToken;
import net.civeira.phylax.features.oauth.token.domain.model.PublicKeyInformation;

@Slf4j
@RequestScoped
@RequiredArgsConstructor
public class JwtTokenBuilder {
  private static final String CHALLENGE = "challenge";
  private static final String BEARER = "Bearer";
  private static final String EXPIRATION_CONF = "oauth.jwt.expiration.access-token";
  private static final String CLAIM_USER_NAME = "sub";
  private static final String CLAIM_GRANT_TYPE = "grant_type";
  private static final String CLAIM_CLIENT_ID = "azp";
  private static final String CLAIM_AUDIENCE_ID = "aud";
  private static final String CLAIM_AUTHORITIES = "groups";
  private static final String CLAIM_SCOPE = "scope";
  private static final String REFRESH_SCOPE = "refresh";
  private static final String MFA_SCOPE = "mfa";

  private final ObjectMapper mapper;
  private final JwtTokenManager manager;

  public IdToken buildIdToken(String tenant, String state, String nonce, ClientDetails details,
      String grantType, AuthenticationData validationData) {
    KeyInformation currentKey = manager.currentKey();
    Algorithm algorithm = manager.signAlgoritm(currentKey);

    Duration expiration = propiedadEntera(EXPIRATION_CONF);
    Instant authExpires = Instant.now().plus(expiration);
    Instant refreshExpires = Instant.now().plus(propiedadEntera(EXPIRATION_CONF));

    String sessionState = UUID.randomUUID().toString();

    String accessToken = accessToken(tenant, details, grantType, validationData)
        .withKeyId(currentKey.getKeyId()).withExpiresAt(authExpires).sign(algorithm);

    Builder identityToken = identityToken(tenant, accessToken, details, grantType, validationData)
        .withExpiresAt(refreshExpires);
    withChallenge(identityToken, state, sessionState, nonce);

    String idtToken = identityToken.sign(algorithm);

    IdToken idToken = new IdToken();
    idToken.setIss(manager.getIssuer(tenant));
    idToken.setTokenType(BEARER);
    idToken.setExpiresIn(expiration.getSeconds());
    idToken.setAccessToken(accessToken);
    idToken.setIdToken(idtToken);
    idToken.setSessionState(sessionState);
    return idToken;
  }

  public <T> String buildChallengerToken(String tenant, T bean, Duration expiration) {
    KeyInformation currentKey = manager.currentKey();
    Algorithm algorithm = manager.signAlgoritm(currentKey);

    String jti = UUID.randomUUID().toString();

    @SuppressWarnings("unchecked")
    Map<String, Object> map = mapper.convertValue(bean, Map.class);

    Builder accessTokenInfo =
        JWT.create().withIssuer(manager.getIssuer(tenant)).withIssuedAt(new Date()).withJWTId(jti)
            .withClaim(CHALLENGE, map).withArrayClaim(CLAIM_SCOPE, new String[] {CHALLENGE});

    return accessTokenInfo.withExpiresAt(Instant.now().plus(expiration))
        .withKeyId(currentKey.getPrivateKey()).sign(algorithm);
  }

  public <T> Optional<T> verifyChalleger(Class<T> type, String token, String tenant) {
    Optional<T> response = Optional.empty();
    List<PublicKeyInformation> publicKeys = manager.getPublicKeys();
    for (PublicKeyInformation inputStream : publicKeys) {
      try {
        String key = manager.extractSignerId(token).orElse("-");
        if (key.equals(inputStream.getKeyId())) {
          Optional<DecodedJWT> decode = manager.decode(inputStream, tenant, token);
          if (decode.isPresent()) {
            DecodedJWT jwt = decode.get();
            List<String> asList = jwt.getClaim(CLAIM_SCOPE).asList(String.class);
            if (asList.size() == 1 && asList.contains(CHALLENGE)) {
              Map<String, Object> asMap = jwt.getClaim(CHALLENGE).asMap();
              response = Optional.of(mapper.convertValue(asMap, type));
            }
            return response;
          }
        }
      } catch (NotAllowedException nae) {
        log.warn("Wrong challenger", nae);
        return Optional.empty();
      }
    }
    return response;
  }

  public MfaToken buildMfaToken(String username, String tenant) {
    KeyInformation currentKey = manager.currentKey();
    Algorithm algorithm = manager.signAlgoritm(currentKey);

    String jti = UUID.randomUUID().toString();

    Duration expiration = propiedadEntera("oauth.jwt.expiration.mfa-token");
    Instant authExpires = Instant.now().plus(expiration);
    MfaToken authorization = new MfaToken();
    authorization.setExpiresIn(expiration.getSeconds());
    Builder accessTokenInfo = JWT.create().withIssuer(manager.getIssuer(tenant))
        .withIssuedAt(new Date()).withJWTId(jti).withClaim(CLAIM_USER_NAME, username)
        .withArrayClaim(CLAIM_SCOPE, new String[] {MFA_SCOPE});
    authorization.setError("mfa_required");
    authorization.setToken(accessTokenInfo.withExpiresAt(authExpires)
        .withKeyId(currentKey.getKeyId()).sign(algorithm));
    return authorization;
  }

  public AutorizationToken buildToken(String tenant, ClientDetails details, String grantType,
      AuthenticationData validationData) {
    return buildToken(tenant, details, grantType, validationData, null);
  }

  public AutorizationToken buildToken(String tenant, ClientDetails details, String grantType,
      AuthenticationData validationData, AuthRequest request) {
    KeyInformation currentKey = manager.currentKey();
    Algorithm algorithm = manager.signAlgoritm(currentKey);

    Builder accessToken = accessToken(tenant, details, grantType, validationData);
    Builder refreshToken = refreshToken(tenant, details, validationData);

    Duration expiration = propiedadEntera(EXPIRATION_CONF);
    Instant authExpires = Instant.now().plus(expiration);
    Instant refreshExpires = Instant.now().plus(propiedadEntera(EXPIRATION_CONF));

    AutorizationToken authorization = new AutorizationToken();
    authorization.setGrantType(grantType);
    authorization.setTokenType(BEARER);
    authorization.setUsername(validationData.getUsername());
    authorization.setExpiresIn(expiration.getSeconds());

    authorization.setAccessToken(
        accessToken.withExpiresAt(authExpires).withKeyId(currentKey.getKeyId()).sign(algorithm));
    authorization.setRefreshToken(refreshToken.withExpiresAt(refreshExpires)
        .withKeyId(currentKey.getKeyId()).sign(algorithm));

    if (null != request) {
      String sessionState = UUID.randomUUID().toString();
      Builder identityToken =
          identityToken(tenant, authorization.getAccessToken(), details, grantType, validationData)
              .withExpiresAt(refreshExpires);
      withChallenge(identityToken, request.getState().orElse(""), sessionState,
          request.getNonce().orElse(""));
      authorization.setIdToken(identityToken.sign(algorithm));
    }

    return authorization;
  }

  public Optional<String> verifyMfa(String token, String tenant) {
    return verifyToken(token, MFA_SCOPE, tenant);
  }

  public Optional<String> verifyRefresh(String token, String tenant) {
    return verifyToken(token, REFRESH_SCOPE, tenant);
  }

  public Optional<String> verifyToken(String token, String scope, String tenant) {
    Optional<String> response = Optional.empty();
    List<PublicKeyInformation> publicKeys = manager.getPublicKeys();
    for (PublicKeyInformation inputStream : publicKeys) {
      try {
        String key = manager.extractSignerId(token).orElse("-");
        if (key.equals(inputStream.getKeyId())) {
          Optional<DecodedJWT> decode = manager.decode(inputStream, tenant, token);
          if (decode.isPresent()) {
            DecodedJWT jwt = decode.get();
            List<String> asList = jwt.getClaim(CLAIM_SCOPE).asList(String.class);
            if (asList.size() == 1 && asList.contains(scope)) {
              response = Optional.of(jwt.getClaim(CLAIM_USER_NAME).asString());
            }
            return response;
          }
        }
      } catch (NotAllowedException nae) {
        log.warn("Wrong {0} token", scope);
        return Optional.empty();
      }
    }
    return response;
  }

  private Builder identityToken(String tenant, String accessToken, ClientDetails client,
      String grantType, AuthenticationData validationData) {
    String jti = UUID.randomUUID().toString();
    String authLevel = null == validationData.getMode() ? "0" : validationData.getMode().getAcr();
    Instant authTime = validationData.getTime();

    Builder builder = JWT.create().withIssuer(manager.getIssuer(tenant)).withJWTId(jti)
        .withClaim("acr", authLevel).withIssuedAt(new Date())
        .withSubject(validationData.getUsername()).withClaim("at_hash", generateHash(accessToken));
    if (null != authTime) {
      builder = builder.withClaim("auth_time", authTime.getEpochSecond());
    }
    return builder.withClaim("typ", "ID").withClaim("aud", validationData.getAudiences())
        .withClaim(CLAIM_GRANT_TYPE, grantType).withClaim(CLAIM_AUDIENCE_ID, client.getClientId())
        .withClaim(CLAIM_USER_NAME, validationData.getUsername())
        .withClaim(CLAIM_CLIENT_ID, client.getClientId())
        .withArrayClaim(CLAIM_AUTHORITIES, validationData.getRoles().toArray(new String[0]));
  }

  private Builder withChallenge(Builder builder, String state, String session, String nonce) {
    if (null != state) {
      builder = builder.withClaim("s_hash", generateHash(state));
    }
    if (null != session) {
      builder = builder.withClaim("session_state", session);
    }
    if (null != nonce) {
      builder = builder.withClaim("nonce", nonce);
    }
    return builder;
  }

  private Builder accessToken(String tenant, ClientDetails client, String grantType,
      AuthenticationData validationData) {
    String jti = UUID.randomUUID().toString();

    final Map<String, Object> tokenMap = new HashMap<>(validationData.getDetails());
    List<String> scopes = new ArrayList<>();

    if (tokenMap.containsKey(CLAIM_SCOPE)) {
      @SuppressWarnings("unchecked")
      List<String> tokenScopes = (List<String>) tokenMap.get(CLAIM_SCOPE);
      for (String scope : tokenScopes) {
        if (client.allowedScope(scope)) {
          scopes.add(scope);
        }
      }
      tokenMap.remove(CLAIM_SCOPE);
    }

    Builder accessTokenInfo = JWT.create();
    if (!tokenMap.isEmpty()) {
      for (Entry<String, Object> entry : tokenMap.entrySet()) {
        accessTokenInfo.withClaim(entry.getKey(), entry.getValue().toString());
      }
    }

    accessTokenInfo = accessTokenInfo.withIssuer(manager.getIssuer(tenant)).withJWTId(jti)
        .withIssuedAt(new Date()).withSubject(validationData.getUsername())
        .withClaim("aud", validationData.getAudiences()).withClaim(CLAIM_GRANT_TYPE, grantType)
        .withClaim("typ", BEARER).withClaim(CLAIM_USER_NAME, validationData.getUsername());

    if (null != validationData.getTenant()) {
      accessTokenInfo = accessTokenInfo.withClaim("tid", validationData.getTenant());
    }

    accessTokenInfo = accessTokenInfo.withClaim(CLAIM_CLIENT_ID, client.getClientId())
        .withClaim("aud", validationData.getAudiences())
        .withArrayClaim(CLAIM_AUTHORITIES, validationData.getRoles().toArray(new String[0]))
        .withArrayClaim(CLAIM_SCOPE, scopes.toArray(new String[0]));
    return accessTokenInfo;
  }

  private Builder refreshToken(String tenant, ClientDetails client,
      AuthenticationData validationData) {
    String jti = UUID.randomUUID().toString();
    return JWT.create().withIssuer(manager.getIssuer(tenant)).withJWTId(jti)
        .withIssuedAt(new Date()).withClaim("aud", validationData.getAudiences())
        .withClaim(CLAIM_USER_NAME, validationData.getUsername())
        .withClaim(CLAIM_CLIENT_ID, client.getClientId())
        .withArrayClaim(CLAIM_SCOPE, new String[] {REFRESH_SCOPE});
  }

  private static String generateHash(String value) {
    try {
      // Obtener instancia de SHA-256
      MessageDigest digest = MessageDigest.getInstance("SHA-256");

      // Aplicar SHA-256 al valor dado
      byte[] hashedValue = digest.digest(value.getBytes());

      // Tomar la primera mitad de los bytes resultantes
      byte[] halfHashedValue = new byte[hashedValue.length / 2];
      System.arraycopy(hashedValue, 0, halfHashedValue, 0, halfHashedValue.length);

      // Codificar la mitad del hash en base64url sin relleno
      return Base64.getUrlEncoder().withoutPadding().encodeToString(halfHashedValue);
    } catch (NoSuchAlgorithmException e) {
      throw new NotAllowedException(
          "Imposible generar el token, por un error [" + e.getClass() + "]: " + e.getMessage());
    }
  }

  private Duration propiedadEntera(String clave) {
    return ConfigProvider.getConfig().getValue(clave, Duration.class);
  }
}
