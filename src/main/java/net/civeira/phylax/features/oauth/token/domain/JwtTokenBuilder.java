/* @autogenerated */
package net.civeira.phylax.features.oauth.token.domain;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

import org.eclipse.microprofile.config.ConfigProvider;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTCreator.Builder;
import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.enterprise.context.RequestScoped;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.exception.NotAllowedException;
import net.civeira.phylax.common.infrastructure.CurrentRequest;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthRequest;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationData;
import net.civeira.phylax.features.oauth.client.domain.model.ClientDetails;
import net.civeira.phylax.features.oauth.key.domain.gateway.TokenSigner;
import net.civeira.phylax.features.oauth.token.domain.model.AutorizationToken;
import net.civeira.phylax.features.oauth.token.domain.model.IdToken;
import net.civeira.phylax.features.oauth.token.domain.model.MfaToken;

@Slf4j
@RequestScoped
@RequiredArgsConstructor
public class JwtTokenBuilder {
  private static final String CHALLENGE = "challenge";
  private static final String BEARER = "Bearer";
  private static final String EXPIRATION_CONF = "oauth.jwt.expiration.access-token";
  private static final String CLAIM_USER_NAME = "sub";
  private static final String CLAIM_GRANT_TYPE = "grant_type";
  private static final String CLAIM_CLIENT_ID = "azp";
  private static final String CLAIM_AUDIENCE_ID = "aud";
  private static final String CLAIM_AUTHORITIES = "groups";
  private static final String CLAIM_SCOPE = "scope";
  private static final String REFRESH_SCOPE = "refresh";
  private static final String MFA_SCOPE = "mfa";

  @Data
  @lombok.Builder
  public static class RefreshTokenInfo {
    private final String username;
    private final List<String> audiences;
    private final String client;
  }

  private final ObjectMapper mapper;
  private final TokenSigner tokenSigner;
  private final CurrentRequest current;

  public IdToken buildIdToken(String tenant, String state, String nonce, ClientDetails details,
      String grantType, AuthenticationData validationData) {
    Duration expiration = propiedadEntera(EXPIRATION_CONF);
    Instant authExpires = Instant.now().plus(expiration);
    Instant refreshExpires = Instant.now().plus(propiedadEntera(EXPIRATION_CONF));

    String sessionState = UUID.randomUUID().toString();

    String accessToken = tokenSigner.sign(tenant,
        accessToken(tenant, details, grantType, validationData), authExpires);

    Builder identityToken = identityToken(tenant, accessToken, details, grantType, validationData);
    withChallenge(identityToken, state, sessionState, nonce);

    String idtToken = tokenSigner.sign(tenant, identityToken, refreshExpires);

    IdToken idToken = new IdToken();
    idToken.setIss(issuer(tenant));
    idToken.setTokenType(BEARER);
    idToken.setExpiresIn(expiration.getSeconds());
    idToken.setAccessToken(accessToken);
    idToken.setIdToken(idtToken);
    idToken.setSessionState(sessionState);
    return idToken;
  }

  public <T> String buildChallengerToken(String tenant, T bean, Duration expiration) {
    String jti = UUID.randomUUID().toString();

    @SuppressWarnings("unchecked")
    Map<String, Object> map = mapper.convertValue(bean, Map.class);

    Builder accessTokenInfo =
        JWT.create().withIssuer(issuer(tenant)).withIssuedAt(new Date()).withJWTId(jti)
            .withClaim(CHALLENGE, map).withArrayClaim(CLAIM_SCOPE, new String[] {CHALLENGE});

    return tokenSigner.signKeypass(tenant, accessTokenInfo, Instant.now().plus(expiration));
  }

  public <T> Optional<T> verifyChalleger(Class<T> type, String token, String tenant) {
    try {
      Map<String, Object> payload = tokenSigner.verifyTokenPayload(tenant, token);
      if (payload.isEmpty()) {
        return Optional.empty();
      }
      List<String> scopes = claimAsList(payload.get(CLAIM_SCOPE));
      if (scopes.size() == 1 && scopes.contains(CHALLENGE)) {
        @SuppressWarnings("unchecked")
        Map<String, Object> asMap = (Map<String, Object>) payload.get(CHALLENGE);
        return Optional.of(mapper.convertValue(asMap, type));
      }
      return Optional.empty();
    } catch (NotAllowedException nae) {
      log.warn("Wrong challenger", nae);
      return Optional.empty();
    }
  }

  public MfaToken buildMfaToken(String username, String tenant) {
    String jti = UUID.randomUUID().toString();

    Duration expiration = propiedadEntera("oauth.jwt.expiration.mfa-token");
    Instant authExpires = Instant.now().plus(expiration);
    MfaToken authorization = new MfaToken();
    authorization.setExpiresIn(expiration.getSeconds());
    Builder accessTokenInfo = JWT.create().withIssuer(issuer(tenant)).withIssuedAt(new Date())
        .withJWTId(jti).withClaim(CLAIM_USER_NAME, username)
        .withArrayClaim(CLAIM_SCOPE, new String[] {MFA_SCOPE});
    authorization.setError("mfa_required");
    authorization.setToken(tokenSigner.sign(tenant, accessTokenInfo, authExpires));
    return authorization;
  }

  /**
   * If no request is provided, no info about audiences.
   * 
   * @param tenant
   * @param details
   * @param grantType
   * @param validationData
   * @return
   */
  @Deprecated
  public AutorizationToken buildToken(String tenant, ClientDetails details, String grantType,
      AuthenticationData validationData) {
    return buildToken(tenant, details, grantType, validationData, null);
  }

  public AutorizationToken buildToken(String tenant, ClientDetails details, String grantType,
      AuthenticationData validationData, AuthRequest request) {
    if (request != null && validationData.getScopes().isEmpty()) {
      List<String> requested = request.getScope().map(s -> Arrays.stream(s.split("\\s+"))
          .filter(sc -> !sc.isBlank()).collect(Collectors.toList())).orElse(List.of());
      boolean wildcard = details.getAllowedScopes().contains("*");
      List<String> granted = wildcard ? requested
          : requested.stream().filter(details.getAllowedScopes()::contains)
              .collect(Collectors.toList());
      validationData.setScopes(granted);
    }
    Builder accessToken = accessToken(tenant, details, grantType, validationData);
    Builder refreshToken = refreshToken(tenant, details, validationData);

    Duration expiration = propiedadEntera(EXPIRATION_CONF);
    Instant authExpires = Instant.now().plus(expiration);
    Instant refreshExpires = Instant.now().plus(propiedadEntera(EXPIRATION_CONF));

    AutorizationToken authorization = new AutorizationToken();
    authorization.setGrantType(grantType);
    authorization.setTokenType(BEARER);
    authorization.setUsername(validationData.getUsername());
    authorization.setExpiresIn(expiration.getSeconds());

    authorization.setAccessToken(tokenSigner.sign(tenant, accessToken, authExpires));
    authorization.setRefreshToken(tokenSigner.sign(tenant, refreshToken, refreshExpires));

    if (null != request) {
      String sessionState = UUID.randomUUID().toString();
      Builder identityToken =
          identityToken(tenant, authorization.getAccessToken(), details, grantType, validationData);
      withChallenge(identityToken, request.getState().orElse(""), sessionState,
          request.getNonce().orElse(""));
      authorization.setIdToken(tokenSigner.sign(tenant, identityToken, refreshExpires));
    }

    return authorization;
  }

  public Optional<String> verifyMfa(String token, String tenant) {
    return verifyToken(token, MFA_SCOPE, tenant);
  }

  public Optional<String> verifyRefresh(String token, String tenant) {
    return verifyToken(token, REFRESH_SCOPE, tenant);
  }

  public Optional<RefreshTokenInfo> verifyRefreshInfo(String token, String tenant) {
    String scope = REFRESH_SCOPE;
    Optional<RefreshTokenInfo> response = Optional.empty();
    try {
      Map<String, Object> payload = tokenSigner.verifyTokenPayload(tenant, token);
      if (payload.isEmpty()) {
        return Optional.empty();
      }
      List<String> scopes = claimAsList(payload.get(CLAIM_SCOPE));
      if (scopes.size() == 1 && scopes.contains(scope)) {
        List<String> aud = claimAsList(payload.get(CLAIM_AUDIENCE_ID));
        response = Optional
            .of(RefreshTokenInfo.builder().username(claimAsString(payload.get(CLAIM_USER_NAME)))
                .client(claimAsString(payload.get(CLAIM_CLIENT_ID)))
                .audiences(null == aud ? List.of() : aud).build());
      }
      return response;
    } catch (NotAllowedException nae) {
      return Optional.empty();
    }
  }



  public Optional<String> verifyToken(String token, String scope, String tenant) {
    Optional<String> response = Optional.empty();
    try {
      Map<String, Object> payload = tokenSigner.verifyTokenPayload(tenant, token);
      if (payload.isEmpty()) {
        return Optional.empty();
      }
      List<String> scopes = claimAsList(payload.get(CLAIM_SCOPE));
      if (scopes.size() == 1 && scopes.contains(scope)) {
        response = Optional.ofNullable(claimAsString(payload.get(CLAIM_USER_NAME)));
      }
      return response;
    } catch (NotAllowedException nae) {
      log.warn("Wrong {0} token", scope);
      return Optional.empty();
    }
  }

  private Builder identityToken(String tenant, String accessToken, ClientDetails client,
      String grantType, AuthenticationData validationData) {
    String jti = UUID.randomUUID().toString();
    String authLevel = null == validationData.getMode() ? "0" : validationData.getMode().getAcr();
    Instant authTime = validationData.getTime();

    Builder builder = JWT.create().withIssuer(issuer(tenant)).withJWTId(jti)
        .withClaim("acr", authLevel).withIssuedAt(new Date())
        .withSubject(validationData.getUsername()).withClaim("at_hash", generateHash(accessToken));
    if (null != authTime) {
      builder = builder.withClaim("auth_time", authTime.getEpochSecond());
    }
    return builder.withClaim("typ", "ID")
        .withClaim(CLAIM_AUDIENCE_ID, validationData.getAudiences())
        .withClaim(CLAIM_GRANT_TYPE, grantType)
        .withClaim(CLAIM_USER_NAME, validationData.getUsername())
        .withClaim(CLAIM_CLIENT_ID, client.getClientId())
        .withArrayClaim(CLAIM_AUTHORITIES, validationData.getRoles().toArray(new String[0]));
  }

  private Builder withChallenge(Builder builder, String state, String session, String nonce) {
    if (null != state) {
      builder = builder.withClaim("s_hash", generateHash(state));
    }
    if (null != session) {
      builder = builder.withClaim("session_state", session);
    }
    if (null != nonce) {
      builder = builder.withClaim("nonce", nonce);
    }
    return builder;
  }

  private Builder accessToken(String tenant, ClientDetails client, String grantType,
      AuthenticationData validationData) {
    String jti = UUID.randomUUID().toString();

    Builder accessTokenInfo = JWT.create();
    List<String> scopes = validationData.getScopes().isEmpty() ? new ArrayList<>()
        : new ArrayList<>(validationData.getScopes());

    accessTokenInfo = accessTokenInfo.withIssuer(issuer(tenant)).withJWTId(jti)
        .withIssuedAt(new Date()).withSubject(validationData.getUsername())
        .withClaim("aud", validationData.getAudiences()).withClaim(CLAIM_GRANT_TYPE, grantType)
        .withClaim("typ", BEARER).withClaim(CLAIM_USER_NAME, validationData.getUsername());

    if (null != validationData.getTenant()) {
      accessTokenInfo = accessTokenInfo.withClaim("tid", validationData.getTenant());
    }

    accessTokenInfo = accessTokenInfo.withClaim(CLAIM_AUDIENCE_ID, validationData.getAudiences())
        .withClaim("aud", validationData.getAudiences())
        .withArrayClaim(CLAIM_AUTHORITIES, validationData.getRoles().toArray(new String[0]))
        .withArrayClaim(CLAIM_SCOPE, scopes.toArray(new String[0]));
    return accessTokenInfo;
  }

  private Builder refreshToken(String tenant, ClientDetails client,
      AuthenticationData validationData) {
    String jti = UUID.randomUUID().toString();
    return JWT.create().withIssuer(issuer(tenant)).withJWTId(jti).withIssuedAt(new Date())
        .withClaim("aud", validationData.getAudiences())
        .withClaim(CLAIM_USER_NAME, validationData.getUsername())
        .withClaim(CLAIM_CLIENT_ID, client.getClientId())
        .withArrayClaim(CLAIM_SCOPE, new String[] {REFRESH_SCOPE});
  }

  private String issuer(String tenant) {
    return current.getPublicHost() + "/oauth/openid/" + tenant;
  }

  private String claimAsString(Object value) {
    return null == value ? null : mapper.convertValue(value, String.class);
  }

  @SuppressWarnings("unchecked")
  private List<String> claimAsList(Object value) {
    if (null == value) {
      return List.of();
    }
    if (value instanceof List) {
      return (List<String>) value;
    }
    if (value instanceof String[]) {
      return Arrays.asList((String[]) value);
    }
    return List.of(mapper.convertValue(value, String.class));
  }

  private static String generateHash(String value) {
    try {
      // Obtener instancia de SHA-256
      MessageDigest digest = MessageDigest.getInstance("SHA-256");

      // Aplicar SHA-256 al valor dado
      byte[] hashedValue = digest.digest(value.getBytes());

      // Tomar la primera mitad de los bytes resultantes
      byte[] halfHashedValue = new byte[hashedValue.length / 2];
      System.arraycopy(hashedValue, 0, halfHashedValue, 0, halfHashedValue.length);

      // Codificar la mitad del hash en base64url sin relleno
      return Base64.getUrlEncoder().withoutPadding().encodeToString(halfHashedValue);
    } catch (NoSuchAlgorithmException e) {
      throw new NotAllowedException(
          "Imposible generar el token, por un error [" + e.getClass() + "]: " + e.getMessage());
    }
  }

  private Duration propiedadEntera(String clave) {
    return ConfigProvider.getConfig().getValue(clave, Duration.class);
  }
}
