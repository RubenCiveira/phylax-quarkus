/* @autogenerated */
package net.civeira.phylax.features.oauth.authentication.infrastructure.driver.rest;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.Base64;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import jakarta.enterprise.context.RequestScoped;
import jakarta.enterprise.inject.Instance;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.HttpHeaders;
import jakarta.ws.rs.core.MultivaluedMap;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.UriInfo;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.features.oauth.authentication.application.granter.TokenGranter;
import net.civeira.phylax.features.oauth.authentication.domain.AuthRequest;
import net.civeira.phylax.features.oauth.authentication.domain.AuthenticationResult;
import net.civeira.phylax.features.oauth.client.domain.ClientDetails;
import net.civeira.phylax.features.oauth.client.domain.gateway.ClientStoreGateway;
import net.civeira.phylax.features.oauth.session.domain.TemporalAuthCode;
import net.civeira.phylax.features.oauth.session.domain.gateway.TemporalKeysGateway;
import net.civeira.phylax.features.oauth.token.application.JwtTokenBuilder;
import net.civeira.phylax.features.oauth.user.application.LoginUsecase;

@Path("")
@RequestScoped
@RequiredArgsConstructor
public class AuthenticationController {
  @Data
  public static class ChPassRequestDto {
    private String username;
    private String authCode;
    private String newPassword;
  }

  @Data
  public static class RecoverPassRequestDto {
    private String username;
  }

  @Data
  public static class RegisterUserRequestDto {
    private String username;
    private String newPassword;
  }

  private final Instance<TokenGranter> granters;
  private final JwtTokenBuilder tokenBuilder;
  private final ClientStoreGateway clientRetriever;
  private final TemporalKeysGateway temporalStore;
  private final LoginUsecase loginUsecase;

  @POST
  @Path("oauth/openid/{tenant}/token")
  public Response tenantLogin(final @PathParam("tenant") String tenant, final @Context UriInfo req,
      final @Context HttpHeaders headers, final MultivaluedMap<String, String> paramMap) {
    String autho = headers.getHeaderString("Authorization");
    String clientId = null;
    String clientSecret = null;
    // refresh token.
    if ("authorization_code".equals(paramMap.getFirst("grant_type"))) {
      Optional<TemporalAuthCode> retrieve =
          temporalStore.retrieveTemporalAuthCode(paramMap.getFirst("code"));
      return retrieve.map(code -> {
        String expected;
        if ("S256".equals(code.request.getCodeChallengeMethod().orElse(""))) {
          expected = generateCodeChallenge(paramMap.getFirst("code_verifier"));
        } else {
          expected = paramMap.getFirst("code_verifier");
        }
        if (!expected.equals(code.request.getCodeChallenge().orElse(""))) {
          return Response.status(401).build();
        }
        AuthRequest request = code.request;
        AuthenticationResult auth = loginUsecase.fillPreAuthenticated(request,
            code.data.getUsername(), code.client, Arrays.asList());
        return auth.isRight()
            ? Response.status(200)
                .entity(tokenBuilder.buildToken(tenant, code.client,
                    paramMap.getFirst("grant_type"), auth.getData(), request))
                .build()
            : Response.status(401).build();
      }).orElseGet(() -> Response.status(401).build());
    } else if ("refresh_token".equals(paramMap.getFirst("grant_type"))) {
      String refreshToken = paramMap.getFirst("refresh_token");
      return tokenBuilder.verifyRefreshInfo(refreshToken, tenant)
          .flatMap(info -> loadPreautorizedClient(tenant, info.getClient()).map(client -> {
            List<String> audiences = info.getAudiences();
            AuthRequest request = AuthRequest.builder().audiences(audiences).tenant(tenant)
                .clientId(Optional.of(client.getClientId()))
                .scope(Optional.ofNullable(paramMap.getFirst("scope"))).build();
            AuthenticationResult auth = loginUsecase.fillPreAuthenticated(request,
                info.getUsername(), client, Arrays.asList());
            return auth.isRight()
                ? Response.status(200).entity(tokenBuilder.buildToken(tenant, client,
                    paramMap.getFirst("grant_type"), auth.getData(), request)).build()
                : Response.status(401).build();
          })).orElseGet(() -> Response.status(401).build());
    }
    if (null != autho && autho.startsWith("Basic ")) {
      String encodeToString = new String(Base64.getDecoder().decode(autho.substring(6).getBytes()),
          StandardCharsets.UTF_8);
      String[] parts = encodeToString.split(":");
      if (parts.length == 2) {
        clientId = parts[0];
        clientSecret = parts[1];
      } else {
        return Response.status(401).build();
      }
    } else if (paramMap.containsKey("client_id")) {
      clientId = paramMap.getFirst("client_id");
    }
    if (null == clientId) {
      return Response.status(401).build();
    }

    Response response = Response.status(401).build();
    Optional<ClientDetails> loadClient = loadClient(tenant, clientId, clientSecret);
    if (loadClient.isPresent()) {
      ClientDetails clientDetails = loadClient.get();
      String grant = paramMap.getFirst("grant_type");
      if (clientDetails.allowdedGrant(grant)) {
        for (TokenGranter granter : granters) {
          if (granter.canHandle(grant)) {
            response =
                processGranterHandler(tenant, req, headers, paramMap, granter, clientDetails);
            break;
          }
        }
      }
    }
    return response;
  }

  @POST
  @Path("oauth/openid/{tenant}/introspect")
  public Response introspect(final @PathParam("tenant") String tenant,
      final MultivaluedMap<String, String> paramMap) {
    return Response.status(403, "Client not allowed.").build();
  }

  private Response processGranterHandler(final String tenant, UriInfo req, HttpHeaders headers,
      final MultivaluedMap<String, String> paramMap, final TokenGranter granter,
      final ClientDetails clientDetails) {

    AuthRequest request = new AuthRequest(tenant, req, headers);

    AuthenticationResult authenticate = granter.autenticate(request, clientDetails, paramMap);
    if (authenticate.isRight()) {
      // For POST token requests the scope comes in the body, not in query params.
      // Apply intersection here so buildToken has the correct scopes available.
      String scopeParam = paramMap.getFirst("scope");
      if (scopeParam != null && !scopeParam.isBlank()
          && authenticate.getData().getScopes().isEmpty()) {
        boolean wildcard = clientDetails.getAllowedScopes().contains("*");
        List<String> granted = wildcard
            ? Arrays.stream(scopeParam.split("\\s+")).filter(s -> !s.isBlank())
                .collect(Collectors.toList())
            : Arrays.stream(scopeParam.split("\\s+")).filter(s -> !s.isBlank())
                .filter(clientDetails.getAllowedScopes()::contains).collect(Collectors.toList());
        authenticate.getData().setScopes(granted);
      }
    }
    return authenticate.isRight()
        ? Response.status(200)
            .entity(tokenBuilder.buildToken(tenant, clientDetails, paramMap.getFirst("grant_type"),
                authenticate.getData(), request))
            .build()
        : Response.status(401).entity(authenticate.getFail().entity(tokenBuilder)).build();
  }

  private Optional<ClientDetails> loadClient(final String tenant, final String clientId,
      final String secretId) {
    return clientRetriever.loadPrivate(tenant, clientId, secretId);
  }

  private Optional<ClientDetails> loadPreautorizedClient(final String tenant,
      final String clientId) {
    return clientRetriever.loadPreautorized(tenant, clientId);
  }

  private String generateCodeChallenge(String codeVerifier) {
    try {
      MessageDigest digest = MessageDigest.getInstance("SHA-256");
      byte[] hash = digest.digest(codeVerifier.getBytes(StandardCharsets.UTF_8));
      return Base64.getUrlEncoder().withoutPadding().encodeToString(hash);
    } catch (Exception e) {
      throw new RuntimeException("Error generating code challenge", e);
    }
  }
}
