/* @autogenerated */
package net.civeira.phylax.features.oauth.authentication.infrastructure.driver.rest;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.time.OffsetDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import io.quarkus.cache.Cache;
import io.quarkus.cache.CacheName;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.RequestScoped;
import jakarta.enterprise.inject.Instance;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.HttpHeaders;
import jakarta.ws.rs.core.MultivaluedMap;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.UriInfo;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.features.oauth.authentication.domain.gateway.TemporalKeysGateway;
import net.civeira.phylax.features.oauth.authentication.domain.gateway.TemporalKeysGateway.TemporalAuthCode;
import net.civeira.phylax.features.oauth.authentication.domain.granter.TokenGranter;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthRequest;
import net.civeira.phylax.features.oauth.authentication.domain.model.AuthenticationResult;
import net.civeira.phylax.features.oauth.client.application.spi.ClientRetrieveSpi;
import net.civeira.phylax.features.oauth.client.domain.model.ClientDetails;
import net.civeira.phylax.features.oauth.token.domain.JwtTokenBuilder;
import net.civeira.phylax.features.oauth.token.domain.JwtTokenManager;

@Path("")
@RequestScoped
@RequiredArgsConstructor
public class AuthenticationController {
  @Data
  public static class ChPassRequestDto {
    private String username;
    private String authCode;
    private String newPassword;
  }

  @Data
  public static class RecoverPassRequestDto {
    private String username;
  }

  @Data
  public static class RegisterUserRequestDto {
    private String username;
    private String newPassword;
  }

  private final Instance<TokenGranter> granters;
  private final JwtTokenManager tokenManager;
  private final JwtTokenBuilder tokenBuilder;
  private final ClientRetrieveSpi clientRetriever;
  private final TemporalKeysGateway temporalStore;
  @CacheName("jwk")
  private final Cache cache;

  @POST
  @Path("oauth/openid/{tenant}/token")
  public Response tenantLogin(final @PathParam("tenant") String tenant, final @Context UriInfo req,
      final @Context HttpHeaders headers, final MultivaluedMap<String, String> paramMap) {
    String autho = headers.getHeaderString("Authorization");
    String clientId = null;
    String clientSecret = null;
    if ("authorization_code".equals(paramMap.getFirst("grant_type"))) {
      Optional<TemporalAuthCode> retrieve =
          temporalStore.retrieveTemporalAuthCode(paramMap.getFirst("code"));
      return retrieve.map(code -> {
        String expected;
        if ("S256".equals(code.request.getCodeChallengeMethod().orElse(""))) {
          expected = generateCodeChallenge(paramMap.getFirst("code_verifier"));
        } else {
          expected = paramMap.getFirst("code_verifier");
        }
        if (!expected.equals(code.request.getCodeChallenge().orElse(""))) {
          return Response.status(401).build();
        }
        return Response.status(200).entity(tokenBuilder.buildToken(tenant, code.clientDetails,
            paramMap.getFirst("grant_type"), code.data, code.request)).build();
      }).orElseGet(() -> Response.status(401).build());
    }
    if (null != autho && autho.startsWith("Basic ")) {
      String encodeToString = new String(Base64.getDecoder().decode(autho.substring(6).getBytes()),
          StandardCharsets.UTF_8);
      String[] parts = encodeToString.split(":");
      if (parts.length == 2) {
        clientId = parts[0];
        clientSecret = parts[1];
      } else {
        return Response.status(401).build();
      }
    } else if (paramMap.containsKey("client_id")) {
      clientId = paramMap.getFirst("client_id");
    }
    if (null == clientId) {
      return Response.status(401).build();
    }

    Response response = Response.status(401).build();
    Optional<ClientDetails> loadClient = loadClient(tenant, clientId, clientSecret);
    if (loadClient.isPresent()) {
      ClientDetails clientDetails = loadClient.get();
      String grant = paramMap.getFirst("grant_type");
      if (clientDetails.allowdedGrant(grant)) {
        for (TokenGranter granter : granters) {
          if (granter.canHandle(grant)) {
            response =
                processGranterHandler(tenant, req, headers, paramMap, granter, clientDetails);
            break;
          }
        }
      }
    }
    return response;
  }

  @POST
  @Path("oauth/openid/{tenant}/introspect")
  public Response introspect(final @PathParam("tenant") String tenant,
      final MultivaluedMap<String, String> paramMap) {
    return Response.status(403, "Client not allowed.").build();
  }

  @GET
  @Path("oauth/openid/{tenant}/certs")
  public Response certs(final @PathParam("tenant") String tenant)
      throws NoSuchAlgorithmException, InvalidKeySpecException, IOException {
    String key = "self-cert";

    Uni<Map<String, Object>> uni = cache.get(key, cacheKey -> {
      try {
        OffsetDateTime scopesExpiration = OffsetDateTime.now().plus(2, ChronoUnit.HOURS);
        Map<String, Object> map = new HashMap<>();
        map.put("keys", tokenManager.getJks());
        return Map.of("data", map, "ttl", scopesExpiration);
      } catch (NoSuchAlgorithmException | InvalidKeySpecException | IOException e) {
        e.printStackTrace();
        throw new RuntimeException(e);
      }
    });
    Map<String, Object> map = uni.await().indefinitely();
    OffsetDateTime ttl = (OffsetDateTime) map.get("ttl");
    if (ttl.isBefore(OffsetDateTime.now())) {
      cache.invalidate(key);
      return certs(tenant);
    } else {
      return Response.status(200).entity(map.get("data")).build();
    }
  }

  private Response processGranterHandler(final String tenant, UriInfo req, HttpHeaders headers,
      final MultivaluedMap<String, String> paramMap, final TokenGranter granter,
      final ClientDetails clientDetails) {

    AuthRequest request = new AuthRequest(tenant, req, headers);
    // AuthRequest.builder().tenant(tenant).scope("").audiences(List.of()).build();

    AuthenticationResult authenticate = granter.autenticate(request, clientDetails, paramMap);
    return authenticate.isRight()
        ? Response.status(200)
            .entity(tokenBuilder.buildToken(tenant, clientDetails, paramMap.getFirst("grant_type"),
                authenticate.getData()))
            .build()
        : Response.status(401).entity(authenticate.getFail().entity(tokenBuilder)).build();
  }

  private Optional<ClientDetails> loadClient(final String tenant, final String clientId,
      final String secretId) {
    return clientRetriever.loadPrivate(tenant, clientId, secretId);
  }

  private String generateCodeChallenge(String codeVerifier) {
    try {
      MessageDigest digest = MessageDigest.getInstance("SHA-256");
      byte[] hash = digest.digest(codeVerifier.getBytes(StandardCharsets.UTF_8));
      return Base64.getUrlEncoder().withoutPadding().encodeToString(hash);
    } catch (Exception e) {
      throw new RuntimeException("Error generating code challenge", e);
    }
  }
}
