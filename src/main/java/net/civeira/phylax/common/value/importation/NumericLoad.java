/* @autogenerated */
package net.civeira.phylax.common.value.importation;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;

import net.civeira.phylax.common.value.validation.AbstractFailList;
import net.civeira.phylax.common.value.validation.ConstraintFail;
import net.civeira.phylax.common.value.validation.ConstraintFailList;

public final class NumericLoad {

  public static <T extends AbstractFailList> Optional<Integer> toInt(String field, String value,
      T fails) {
    Optional<BigDecimal> base = parseBigDecimal(field, value, fails, "INVALID_INTEGER");
    if (base.isEmpty()) {
      return Optional.empty();
    }

    try {
      // obligamos a que sea entero exacto (sin decimales y dentro de rango int)
      return Optional.of(base.get().intValueExact());
    } catch (ArithmeticException e) {
      fails.add(new ConstraintFail("OUT_OF_RANGE_INTEGER", field, value));
      return Optional.empty();
    }
  }

  public static <T extends AbstractFailList> Optional<Double> toDouble(String field, String value,
      T fails) {
    Optional<BigDecimal> base = parseBigDecimal(field, value, fails, "INVALID_DOUBLE");
    if (base.isEmpty()) {
      return Optional.empty();
    }

    double d = base.get().doubleValue();
    if (Double.isInfinite(d) || Double.isNaN(d)) {
      fails.add(new ConstraintFail("OUT_OF_RANGE_DOUBLE", field, value));
      return Optional.empty();
    }

    return Optional.of(d);
  }

  public static <T extends AbstractFailList> Optional<Long> toLong(String field, String value,
      T fails) {
    Optional<BigDecimal> base = parseBigDecimal(field, value, fails, "INVALID_LONG");
    if (base.isEmpty()) {
      return Optional.empty();
    }

    try {
      return Optional.of(base.get().longValueExact());
    } catch (ArithmeticException e) {
      fails.add(new ConstraintFail("OUT_OF_RANGE_LONG", field, value));
      return Optional.empty();
    }
  }

  public static <T extends AbstractFailList> Optional<Float> toFloat(String field, String value,
      T fails) {
    Optional<BigDecimal> base = parseBigDecimal(field, value, fails, "INVALID_FLOAT");
    if (base.isEmpty()) {
      return Optional.empty();
    }

    float f = base.get().floatValue();
    if (Float.isInfinite(f) || Float.isNaN(f)) {
      fails.add(new ConstraintFail("OUT_OF_RANGE_FLOAT", field, value));
      return Optional.empty();
    }

    return Optional.of(f);
  }

  public static Optional<BigDecimal> toBigDecimal(String field, String value,
      ConstraintFailList fails) {
    return parseBigDecimal(field, value, fails, "INVALID_NUMERIC");
  }

  public static Optional<BigInteger> toBigInteger(String field, String value,
      ConstraintFailList fails) {
    Optional<BigDecimal> base = parseBigDecimal(field, value, fails, "INVALID_INTEGER");
    if (base.isEmpty()) {
      return Optional.empty();
    }

    try {
      return Optional.of(base.get().toBigIntegerExact());
    } catch (ArithmeticException e) {
      fails.add("OUT_OF_RANGE_INTEGER", field, value);
      return Optional.empty();
    }
  }

  // ===================== helpers =====================

  private static <T extends AbstractFailList> Optional<BigDecimal> parseBigDecimal(String field,
      String value, T fails, String invalidCode) {
    if (value == null || value.isBlank()) {
      fails.add(new ConstraintFail("NOT_NULL", field, null));
      return Optional.empty();
    }

    String raw = value.trim();

    try {
      BigDecimal result = parseLocalizedDecimal(raw);
      return Optional.of(result);
    } catch (NumberFormatException ex) {
      fails.add(new ConstraintFail(invalidCode, field, value));
      return Optional.empty();
    }
  }

  /**
   * Admite: - "1234" - "1,234.56" (formato US: , miles, . decimal) - "1.234,56" (formato EU: .
   * miles, , decimal) - "1234,56" (solo separador decimal coma) - "1234.56" (solo separador decimal
   * punto) - con espacios: " 1 234,56 " - notación científica tipo "1.23E3"
   */
  private static BigDecimal parseLocalizedDecimal(String raw) {
    // quitamos espacios (incluyendo no-break spaces)
    String s = raw.replaceAll("\\s+", "");
    // soportar notación científica “limpia”
    if (s.matches("[+-]?\\d+(\\.\\d+)?([eE][+-]?\\d+)?")) {
      return new BigDecimal(s);
    }

    // Eliminar separador de miles tipo ' (ej: suizo 1'234.56)
    s = s.replace("'", "");

    int lastDot = s.lastIndexOf('.');
    int lastComma = s.lastIndexOf(',');

    if (lastDot >= 0 && lastComma >= 0) {
      // Hay ambos: el último que aparece se considera decimal,
      // el otro será separador de miles.
      boolean commaIsDecimal = lastComma > lastDot;
      char decimalSep = commaIsDecimal ? ',' : '.';
      char thousandSep = commaIsDecimal ? '.' : ',';
      return new BigDecimal(s.replace(String.valueOf(thousandSep), "").replace(decimalSep, '.'));
    }

    // Solo uno de los dos o ninguno
    if (lastDot >= 0 || lastComma >= 0) {
      char sep = (lastDot >= 0) ? '.' : ',';
      int lastSep = (lastDot >= 0) ? lastDot : lastComma;

      // Si el separador aparece varias veces, asumimos que el último es decimal
      // y los anteriores son de miles.
      StringBuilder normalized = new StringBuilder();
      for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == sep) {
          if (i == lastSep) {
            normalized.append('.'); // decimal
          } else {
            // separador de miles -> lo omitimos
          }
        } else {
          normalized.append(c);
        }
      }
      return new BigDecimal(normalized.toString());
    }

    // Ni punto ni coma: debería ser un entero "limpio"
    return new BigDecimal(s);
  }

  private NumericLoad() {
    /* do nothing */
  }
}
