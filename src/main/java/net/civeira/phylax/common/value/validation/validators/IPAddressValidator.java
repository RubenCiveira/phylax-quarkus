/* @autogenerated */
package net.civeira.phylax.common.value.validation.validators;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.civeira.phylax.common.value.validation.ValidationResult;
import net.civeira.phylax.common.value.validation.Validator;

/**
 * Validates IP addresses based on the specified IP version (IPv4, IPv6, or both). Optionally, it
 * can validate if an IP address belongs to a specified subnet.
 */
public class IPAddressValidator implements Validator<String> {

  /** Enum representing the supported IP versions. */
  public enum IPVersion {
    IPV4, IPV6, BOTH
  }

  private final IPVersion ipVersion;
  private final byte[] networkAddress;
  private final byte[] subnetMask;
  private final String errorMessage;

  /**
   * Constructs an IPAddressValidator that validates only the IP format without subnet
   * value.validation.
   *
   * @param ipVersion The IP version to validate (IPv4, IPv6, or both).
   * @param errorMessage The error message returned if validation fails.
   */
  public IPAddressValidator(IPVersion ipVersion, String errorMessage) {
    this(ipVersion, null, null, errorMessage);
  }

  /**
   * Constructs an IPAddressValidator that validates both the IP format and whether the IP belongs
   * to a given subnet.
   *
   * @param ipVersion The IP version to validate (IPv4, IPv6, or both).
   * @param networkAddress The network address of the subnet (must be provided with subnetMask).
   * @param subnetMask The subnet mask defining the subnet range (must be provided with
   *        networkAddress).
   * @param errorMessage The error message returned if validation fails.
   * @throws IllegalArgumentException if only one of networkAddress or subnetMask is provided.
   */
  public IPAddressValidator(IPVersion ipVersion, String networkAddress, String subnetMask,
      String errorMessage) {
    this.ipVersion = ipVersion;
    this.errorMessage = errorMessage;
    if (networkAddress != null && subnetMask != null) {
      this.networkAddress = toBytes(networkAddress);
      this.subnetMask = toBytes(subnetMask);
    } else if (networkAddress != null || subnetMask != null) {
      throw new IllegalArgumentException("If a network is indicated, a subnet is required.");
    } else {
      this.networkAddress = null;
      this.subnetMask = null;
    }
  }

  /**
   * Validates whether the given IP address is correctly formatted and belongs to the specified
   * subnet (if applicable).
   *
   * @param ipAddress The IP address to validate.
   * @return A ValidationResult indicating whether the IP address is valid.
   */
  @Override
  public ValidationResult validate(String ipAddress) {
    if (ipAddress == null || ipAddress.isEmpty()) {
      return new ValidationResult(errorMessage);
    }

    final Pattern ipv4Pattern =
        Pattern.compile("^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$");

    final Pattern ipv6Pattern = Pattern.compile("^[0-9a-fA-F]{1,4}(:[0-9a-fA-F]{1,4}){7}$");

    boolean isValidFormat = false;
    if (ipVersion == IPVersion.IPV4 || ipVersion == IPVersion.BOTH) {
      isValidFormat = isIpV4Valid(ipv4Pattern.matcher(ipAddress));
    }
    if (!isValidFormat && (ipVersion == IPVersion.IPV6 || ipVersion == IPVersion.BOTH)) {
      isValidFormat = ipv6Pattern.matcher(ipAddress).matches();
    }

    if (!isValidFormat) {
      return new ValidationResult(errorMessage);
    }

    if (networkAddress != null && !isInSubnet(ipAddress)) {
      return new ValidationResult(errorMessage);
    }
    return new ValidationResult();
  }

  /**
   * Checks whether an IP address belongs to the specified subnet.
   *
   * @param ipAddress The IP address to check.
   * @return true if the IP belongs to the subnet, false otherwise.
   */
  private boolean isInSubnet(String ipAddress) {
    byte[] ip = toBytes(ipAddress);
    for (int i = 0; i < ip.length; i++) {
      if ((ip[i] & subnetMask[i]) != (networkAddress[i] & subnetMask[i])) {
        return false;
      }
    }
    return true;
  }

  /**
   * Converts an IPv4 address from string format to a byte array. Assumes the input format has been
   * validated in the public method.
   *
   * @param ipAddress The IP address to convert.
   * @return A byte array representing the IP address.
   */
  private byte[] toBytes(String ipAddress) {
    String[] parts = ipAddress.split("\\.");
    byte[] bytes = new byte[4];
    for (int i = 0; i < 4; i++) {
      int num = Integer.parseInt(parts[i]);
      bytes[i] = (byte) num;
    }
    return bytes;
  }

  /**
   * Validates if the given IPv4 address has all its octets within the valid range (0-255).
   *
   * @param matcher The regex matcher containing the extracted IPv4 octets.
   * @return true if all octets are within the valid range, false otherwise.
   */
  private boolean isIpV4Valid(Matcher matcher) {
    if (matcher.matches()) {
      for (int i = 1; i <= 4; i++) {
        int octet = Integer.parseInt(matcher.group(i));
        if (octet > 255) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
}
