/* @autogenerated */
package net.civeira.phylax.common.value.importation;

import java.util.List;
import java.util.Locale;
import java.util.Optional;

import net.civeira.phylax.common.value.validation.AbstractFailList;
import net.civeira.phylax.common.value.validation.ConstraintFail;

public final class EnumeratedLoad {

  public static <E extends Enum<E>, T extends AbstractFailList> Optional<E> toEnumerated(
      Class<E> type, String field, String value, T fails) {
    if (value == null || value.isBlank()) {
      // Aquí pon el método real para registrar el fallo
      fails.add(new ConstraintFail("NOT_NULL", field, null));
      return Optional.empty();
    }
    if (!type.isEnum()) {
      fails.add(new ConstraintFail("WRONG_TYPE", field, type.getClass().getName()));
      return Optional.empty();
    }
    // Generamos posibles variantes del texto
    String trimmed = value.trim();
    List<String> candidates =
        List.of(trimmed, trimmed.toUpperCase(Locale.ROOT), trimmed.toLowerCase(Locale.ROOT),
            trimmed.replace(' ', '_'), trimmed.trim().replace(' ', '_').toUpperCase(Locale.ROOT),
            trimmed.trim().replace(' ', '_').toLowerCase(Locale.ROOT));
    for (String candidate : candidates) {
      try {
        E result = Enum.valueOf(type, candidate);
        return Optional.of(result);
      } catch (IllegalArgumentException ignore) {
        // seguimos probando con el siguiente candidato
      }
    }
    // Si llegamos aquí, no se ha encontrado ningún valor válido
    fails.add(new ConstraintFail("WRONG_VALUE", field, value));
    return Optional.empty();
  }

  private EnumeratedLoad() {
    /* do nothing */
  }
}
