/* @autogenerated */
package net.civeira.phylax.common.value;

import java.time.Duration;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

public class InMemoryCache<K, V> {

  public static class Entry<V> {
    private final V value;
    private final long expireAtMillis;

    public Entry(V value, Duration ttl) {
      this.value = value;
      this.expireAtMillis = ttl.toMillis();
    }

    public V getValue() {
      return value;
    }

    private boolean isExpired(long now) {
      return expireAtMillis < now;
    }
  }

  private final ConcurrentHashMap<K, Entry<V>> map = new ConcurrentHashMap<>();
  private final int maxSize;

  public InMemoryCache(int maxSize) {
    this.maxSize = maxSize;
  }

  public synchronized V get(K key, Function<K, Entry<V>> callbakc) {
    Objects.requireNonNull(key);
    V cached = get(key);
    if (null == cached) {
      Entry<V> entry = callbakc.apply(key);
      put(key, entry);
      cached = entry.value;
    }
    return cached;
  }

  public void remove(K key) {
    map.remove(key);
  }

  public int size() {
    return map.size();
  }

  /**
   * Limpieza manual (por si quieres llamarla de vez en cuando desde un scheduler).
   */
  public void cleanUp() {
    long now = System.currentTimeMillis();
    Iterator<Map.Entry<K, Entry<V>>> it = map.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry<K, Entry<V>> e = it.next();
      if (e.getValue().isExpired(now)) {
        it.remove();
      }
    }
  }

  private V get(K key) {
    long now = System.currentTimeMillis();
    Entry<V> entry = map.get(key);
    if (entry == null) {
      return null;
    }
    if (entry.isExpired(now)) {
      // TTL pasado â†’ lo quitamos y devolvemos null
      map.remove(key, entry);
      return null;
    }
    return entry.value;
  }

  private V put(K key, Entry<V> newEntry) {
    long now = System.currentTimeMillis();
    Entry<V> old = map.put(key, newEntry);
    enforceMaxSize();
    return old != null && !old.isExpired(now) ? old.value : null;
  }

  private void enforceMaxSize() {
    if (map.size() <= maxSize) {
      return;
    }
    // Estrategia simple: intentamos quitar expirados, y si no hay, quitamos algunos al azar
    cleanUp();

    if (map.size() <= maxSize) {
      return;
    }

    // Best effort: quitamos los primeros que encontremos
    int toRemove = map.size() - maxSize;
    Iterator<K> it = map.keySet().iterator();
    while (it.hasNext() && toRemove > 0) {
      it.next();
      it.remove();
      toRemove--;
    }
  }
}
