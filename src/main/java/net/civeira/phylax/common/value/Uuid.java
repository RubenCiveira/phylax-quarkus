/* @autogenerated */
package net.civeira.phylax.common.value;

import java.security.SecureRandom;
import java.util.UUID;

/**
 * Utility class for generating UUIDs with a Nano COMB (Combined Ordered Monotonic Binary).
 * <p>
 * This class provides a method to generate UUIDs that are ordered based on a high-resolution
 * timestamp combined with a random component. It also includes utilities for UUID value.validation.
 * </p>
 */
public class Uuid {
  private static final long ONE_MILLION_NANOSECONDS = 1_000_000L;
  private static final String UUID_REGEX =
      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$";

  /**
   * Shared {@link SecureRandom} instance reused across all UUID generations. Initializing
   * {@code SecureRandom} seeds from OS entropy and is expensive; a single instance is thread-safe
   * and avoids that overhead on every call.
   */
  private static final SecureRandom SECURE_RANDOM = new SecureRandom();

  private static long prevTime = System.currentTimeMillis();
  private static long prevNano = System.nanoTime();

  /**
   * Provides system time and high-resolution time.
   * <p>
   * This class acts as a wrapper around {@code System.currentTimeMillis()} and
   * {@code System.nanoTime()} to facilitate testing and overriding time-based operations when
   * needed.
   * </p>
   */
  public static class ClockProvider {

    private ClockProvider() {
      /* Utility class, no instance required */
    }

    /**
     * Returns the current system time in milliseconds.
     *
     * @return The current time in milliseconds.
     */
    public static long currentTime() {
      return System.currentTimeMillis();
    }

    /**
     * Returns the current time with nanosecond precision.
     *
     * @return The current system time in nanoseconds.
     */
    public static long nanoTime() {
      return System.nanoTime();
    }
  }

  private Uuid() {
    /* Utility class, no instance required */
  }

  /**
   * Generates a Nano COMB UUID.
   * <p>
   * A Nano COMB UUID is inspired by ULID and COMB generators, consisting of:
   * <ul>
   * <li>64 bits representing the timestamp component (ordered).</li>
   * <li>64 bits representing a secure random component.</li>
   * </ul>
   * This approach ensures UUIDs are lexically sortable and retain randomness for uniqueness.
   * </p>
   *
   * @return A UUID with a time-ordered component.
   */
  public static UUID comb() {
    final long timeBits = getTimeComponent();
    final long randomBits = getRandomComponent();
    return new UUID(timeBits, randomBits);
  }

  /**
   * Checks whether a given string is a valid UUID format.
   *
   * @param str The string to validate.
   * @return {@code true} if the string follows the UUID format
   *         (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx), {@code false} otherwise.
   */
  public static boolean isValidGUID(String str) {
    return str != null && str.matches(UUID_REGEX);
  }

  /**
   * Retrieves a time-based component with nanosecond precision.
   * <p>
   * This method combines {@code System.currentTimeMillis()} for millisecond accuracy with
   * {@code System.nanoTime()} to estimate nanosecond precision. The approximation ensures some
   * level of monotonicity when multiple calls occur within the same millisecond.
   * </p>
   *
   * @return A timestamp in nanoseconds.
   */
  private static synchronized long getTimeComponent() {
    long time = ClockProvider.currentTime();
    long nano = ClockProvider.nanoTime();
    long elapsed = 0; // Nanoseconds elapsed since the last call

    if (time == prevTime) {
      elapsed = (nano - prevNano);
    } else {
      prevNano = nano;
    }

    prevTime = time;
    return (time * ONE_MILLION_NANOSECONDS) + elapsed;
  }

  /**
   * Generates a random component using a secure random generator.
   * <p>
   * The random component ensures UUID uniqueness even when multiple UUIDs are generated within the
   * same timestamp period.
   * </p>
   *
   * @return A randomly generated long value.
   */
  private static long getRandomComponent() {
    return SECURE_RANDOM.nextLong();
  }
}
