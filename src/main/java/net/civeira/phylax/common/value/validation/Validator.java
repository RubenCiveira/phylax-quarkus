/* @autogenerated */
package net.civeira.phylax.common.value.validation;

import java.util.ArrayList;
import java.util.List;

/**
 * Functional interface for validating objects of type {@code T}.
 * <p>
 * This interface defines a method for performing validation checks and provides default methods to
 * combine validators with logical operations.
 * </p>
 *
 * @param <T> The type of object to validate.
 */
@FunctionalInterface
public interface Validator<T> {

  /**
   * Validates an object of type {@code T}.
   *
   * @param t The object to validate.
   * @return A {@link ValidationResult} indicating whether the validation was successful.
   */
  ValidationResult validate(T t);

  /**
   * Combines this validator with another validator using logical AND.
   * <p>
   * The combined validator returns valid only if both validators pass. If any validator fails, the
   * combined result includes all error messages.
   * </p>
   *
   * @param other The other validator to combine with.
   * @return A new validator that applies both validations.
   */
  default Validator<T> and(Validator<? super T> other) {
    return obj -> {
      ValidationResult oneResult = this.validate(obj);
      ValidationResult otherResult = other.validate(obj);
      boolean valid = oneResult.isValid() && otherResult.isValid();
      List<String> msgs = new ArrayList<>();
      if (!valid) {
        msgs.addAll(oneResult.getErrors());
        msgs.addAll(otherResult.getErrors());
      }
      return new ValidationResult(valid, msgs);
    };
  }

  /**
   * Combines this validator with another validator using logical OR.
   * <p>
   * The combined validator returns valid if at least one of the validators passes. If both fail,
   * the result includes all error messages.
   * </p>
   *
   * @param other The other validator to combine with.
   * @return A new validator that applies at least one of the validations.
   */
  default Validator<T> or(Validator<? super T> other) {
    return obj -> {
      ValidationResult oneResult = this.validate(obj);
      ValidationResult otherResult = other.validate(obj);
      boolean valid = oneResult.isValid() || otherResult.isValid();
      List<String> msgs = new ArrayList<>();
      if (!valid) {
        msgs.addAll(oneResult.getErrors());
        msgs.addAll(otherResult.getErrors());
      }
      return new ValidationResult(valid, msgs);
    };
  }

  /**
   * Creates a new validator that negates the result of this validator.
   * <p>
   * If this validator passes, the new validator fails with the given message. If this validator
   * fails, the new validator passes without errors.
   * </p>
   *
   * @param message The error message to include when the original validator passes.
   * @return A new validator that negates this validator's result.
   */
  default Validator<T> negate(String message) {
    return obj -> {
      ValidationResult oneResult = this.validate(obj);
      return new ValidationResult(!oneResult.isValid(),
          oneResult.isValid() ? List.of(message) : List.of());
    };
  }
}
