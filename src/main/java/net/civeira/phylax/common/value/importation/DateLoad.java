/* @autogenerated */
package net.civeira.phylax.common.value.importation;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.List;
import java.util.Locale;
import java.util.Optional;

import net.civeira.phylax.common.value.validation.AbstractFailList;
import net.civeira.phylax.common.value.validation.ConstraintFail;

public final class DateLoad {
  // Formatos aceptados para fechas "solo día"
  private static final List<DateTimeFormatter> LOCAL_DATE_FORMATTERS =
      List.of(DateTimeFormatter.ISO_LOCAL_DATE, // 2025-12-16
          DateTimeFormatter.ofPattern("dd/MM/yyyy"), // 16/12/2025
          DateTimeFormatter.ofPattern("dd-MM-yyyy"), // 16-12-2025
          DateTimeFormatter.ofPattern("yyyyMMdd") // 20251216
      );

  // Formatos aceptados para fecha + hora con zona/offset
  private static final List<DateTimeFormatter> OFFSET_DATETIME_FORMATTERS =
      List.of(DateTimeFormatter.ISO_OFFSET_DATE_TIME, // 2025-12-16T10:15:30+01:00
          DateTimeFormatter.ISO_ZONED_DATE_TIME, // 2025-12-16T10:15:30+01:00[Europe/Madrid]
          DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssXXX"), // 2025-12-16T10:15:30+01:00
          DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ssXXX"), // 2025-12-16 10:15:30+01:00
          DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ssXXX") // 16/12/2025 10:15:30+01:00
      );

  /**
   * Convierte un valor en LocalDate, aceptando: - varios formatos de texto - timestamps numéricos
   * (epoch seconds/millis) - timestamps tipo Excel (días desde 1899-12-30)
   */
  public static <T extends AbstractFailList> Optional<LocalDate> toLocalDate(ZoneId zone,
      String field, String value, T fails) {

    if (value == null || value.isBlank()) {
      fails.add(new ConstraintFail("NOT_NULL", field, null));
      return Optional.empty();
    }

    String trimmed = value.trim();

    // 1) Intentar formatos de texto
    for (DateTimeFormatter fmt : LOCAL_DATE_FORMATTERS) {
      try {
        LocalDate date = LocalDate.parse(trimmed, fmt.withLocale(Locale.ROOT));
        return Optional.of(date);
      } catch (DateTimeParseException ignore) {
        // probamos siguiente formato
      }
    }

    // 2) Intentar numéricos (epoch / excel)
    Optional<LocalDate> numericResult = parseNumericToLocalDate(zone, trimmed);
    if (numericResult.isPresent()) {
      return numericResult;
    }

    // 3) Si nada funciona, registrar error
    fails.add(new ConstraintFail("INVALID_DATE", field, value));
    return Optional.empty();
  }

  /**
   * Convierte un valor en OffsetDateTime, aceptando: - ISO y otros formatos de texto con offset -
   * timestamps numéricos (epoch seconds/millis) - timestamps tipo Excel (días desde 1899-12-30,
   * incluyendo parte decimal como hora)
   */
  public static <T extends AbstractFailList> Optional<OffsetDateTime> toOffsetDateTime(ZoneId zone,
      String field, String value, T fails) {
    if (value == null || value.isBlank()) {
      fails.add(new ConstraintFail("NOT_NULL", field, null));
      return Optional.empty();
    }

    String trimmed = value.trim();

    // 1) Intentar formatos de texto con offset/zona
    for (DateTimeFormatter fmt : OFFSET_DATETIME_FORMATTERS) {
      try {
        OffsetDateTime odt = OffsetDateTime.parse(trimmed, fmt.withLocale(Locale.ROOT));
        return Optional.of(odt);
      } catch (DateTimeParseException ignore) {
        // probamos con siguiente formato
      }
    }

    // 2) Intentar ISO_LOCAL_DATE + hora "00:00" en zona por defecto
    try {
      LocalDate ld = LocalDate.parse(trimmed, DateTimeFormatter.ISO_LOCAL_DATE);
      return Optional.of(ld.atStartOfDay(zone).toOffsetDateTime());
    } catch (DateTimeParseException ignore) {
      // seguimos
    }

    // 3) Intentar numéricos (epoch / excel)
    Optional<OffsetDateTime> numericResult = parseNumericToOffsetDateTime(zone, trimmed);
    if (numericResult.isPresent()) {
      return numericResult;
    }

    // 4) Nada ha funcionado → error
    fails.add(new ConstraintFail("INVALID_DATETIME", field, value));
    return Optional.empty();
  }

  // ===================== helpers numéricos =====================

  /**
   * Intenta interpretar el string como: - epoch seconds (long "corto") → LocalDate en zona por
   * defecto - epoch millis (long "largo") → LocalDate en zona por defecto - serial Excel (decimal)
   * → base 1899-12-30 + días (ignorando la parte decimal)
   */
  private static Optional<LocalDate> parseNumericToLocalDate(ZoneId zone, String value) {
    if (!value.matches("^-?\\d+(\\.\\d+)?$")) {
      return Optional.empty();
    }

    // ¿Tiene decimales? → Excel
    if (value.contains(".")) {
      try {
        BigDecimal bd = new BigDecimal(value);
        return Optional.of(excelSerialToLocalDate(bd));
      } catch (NumberFormatException e) {
        return Optional.empty();
      }
    }

    // Sin decimales → epoch seconds/millis
    try {
      long numeric = Long.parseLong(value);
      Instant instant = toInstantFromEpochGuess(numeric);
      LocalDate date = instant.atZone(zone).toLocalDate();
      return Optional.of(date);
    } catch (NumberFormatException e) {
      return Optional.empty();
    }
  }

  /**
   * Igual que arriba, pero devolviendo OffsetDateTime.
   */
  private static Optional<OffsetDateTime> parseNumericToOffsetDateTime(ZoneId zone, String value) {
    if (!value.matches("^-?\\d+(\\.\\d+)?$")) {
      return Optional.empty();
    }

    // Excel con parte decimal = hora del día
    if (value.contains(".")) {
      try {
        BigDecimal bd = new BigDecimal(value);
        return Optional.of(excelSerialToOffsetDateTime(zone, bd));
      } catch (NumberFormatException e) {
        return Optional.empty();
      }
    }

    // epoch seconds/millis
    try {
      long numeric = Long.parseLong(value);
      Instant instant = toInstantFromEpochGuess(numeric);
      return Optional.of(instant.atZone(zone).toOffsetDateTime());
    } catch (NumberFormatException e) {
      return Optional.empty();
    }
  }

  /**
   * Heurística sencilla: - si el número es "corto" (<= 10 dígitos) → segundos - si es "largo" (> 10
   * dígitos) → milisegundos Ajusta esta heurística si lo necesitas.
   */
  private static Instant toInstantFromEpochGuess(long numeric) {
    int length = Long.toString(Math.abs(numeric)).length();
    if (length <= 10) {
      // epoch seconds
      return Instant.ofEpochSecond(numeric);
    } else {
      // epoch millis
      return Instant.ofEpochMilli(numeric);
    }
  }

  /**
   * Excel serial → LocalDate. La mayoría de implementaciones usan 1899-12-30 como día 0 (ignorando
   * el bug del 1900). Aquí ignoramos la parte decimal (hora).
   */
  private static LocalDate excelSerialToLocalDate(BigDecimal serial) {
    LocalDate base = LocalDate.of(1899, 12, 30);
    long days = serial.longValue(); // truncado
    return base.plusDays(days);
  }

  /**
   * Excel serial → OffsetDateTime (incluyendo parte decimal).
   */
  private static OffsetDateTime excelSerialToOffsetDateTime(ZoneId zone, BigDecimal serial) {
    LocalDate base = LocalDate.of(1899, 12, 30);
    int days = serial.intValue();
    BigDecimal fractional = serial.subtract(BigDecimal.valueOf(days));

    // segundos en el día
    int secondsOfDay = fractional.multiply(BigDecimal.valueOf(24 * 60 * 60)).intValue(); // truncamos

    LocalTime time = LocalTime.ofSecondOfDay(secondsOfDay);
    return OffsetDateTime.of(base.plusDays(days), time, zone.getRules().getOffset(Instant.now()));
  }

  private DateLoad() {
    /* do noting */
  }
}
