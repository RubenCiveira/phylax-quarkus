/* @autogenerated */
package net.civeira.phylax.common.value;

import java.io.IOException;
import java.io.InputStream;
import java.text.MessageFormat;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.function.Function;

import org.apache.commons.lang3.StringUtils;
import org.yaml.snakeyaml.Yaml;

import lombok.extern.slf4j.Slf4j;

/**
 * Utility class for loading and retrieving localized messages from YAML files.
 * 
 * <p>
 * This class loads locale-specific messages from YAML files, allowing access to translation keys
 * and formatted messages based on a given locale.
 * </p>
 * 
 * <p>
 * It supports hierarchical YAML structures and flattens them into key-value pairs for easy
 * retrieval.
 * </p>
 */
@Slf4j
public class YamlLocaleMessages {
  private static final Yaml yaml = new Yaml();

  /**
   * Loads localized messages from a YAML file based on the given name and locale.
   * 
   * @param name The base name of the YAML file (without locale extension).
   * @param locale The locale for which messages should be loaded.
   * @return An instance of {@code YamlLocaleMessages} containing the localized messages.
   */
  public static YamlLocaleMessages load(String name, Locale locale) {
    return new YamlLocaleMessages(name, locale,
        path -> YamlLocaleMessages.class.getResourceAsStream(path));
  }

  private final Map<String, String> loaded;

  /**
   * Constructs an instance of {@code YamlLocaleMessages} and loads messages for the specified
   * locale.
   *
   * @param name The base name of the YAML file.
   * @param locale The locale for which messages should be loaded.
   * @param provider A function that provides an input stream to read YAML files.
   */
  /* default */ YamlLocaleMessages(String name, Locale locale,
      Function<String, InputStream> provider) {
    loaded = new HashMap<>();
    String language = locale.getLanguage();
    String country = locale.getCountry();
    load(name, loaded, provider);
    load(name + "." + language, loaded, provider);
    if (StringUtils.isNotEmpty(country)) {
      load(name + "." + language + "-" + country, loaded, provider);
    }
  }

  /**
   * Checks if the specified message pattern exists in the loaded messages.
   *
   * @param pattern The key of the message.
   * @return {@code true} if the pattern exists, {@code false} otherwise.
   */
  public boolean contains(String pattern) {
    return loaded.containsKey(pattern);
  }

  /**
   * Retrieves all keys that start with the given prefix.
   *
   * @param prefix The prefix to filter message keys.
   * @return A list of message keys that match the prefix.
   */
  public List<String> keys(String prefix) {
    return loaded.keySet().stream().filter(key -> key.startsWith(prefix + "."))
        .map(key -> key.substring(prefix.length() + 1)).toList();
  }

  /**
   * Retrieves the localized message for the given key, optionally formatting it with arguments.
   *
   * @param pattern The message key.
   * @param arguments Optional arguments to format the message.
   * @return The formatted message if the key exists, otherwise returns the key itself.
   */
  public String get(String pattern, Object... arguments) {
    return loaded.containsKey(pattern) ? MessageFormat.format(loaded.get(pattern), arguments)
        : pattern;
  }

  /**
   * Loads messages from a YAML file into a flattened key-value map.
   *
   * @param name The YAML file name.
   * @param flattenedTranslations The map where translations will be stored.
   * @param provider A function that provides an input stream for reading the YAML file.
   */
  private void load(String name, Map<String, String> flattenedTranslations,
      Function<String, InputStream> provider) {
    try (InputStream inputStream = provider.apply(name + ".yaml")) {
      if (inputStream != null) {
        Map<Object, Object> translations = yaml.load(inputStream);
        if (translations != null) {
          flattenMap("", translations, flattenedTranslations);
        }
      }
    } catch (IOException e) {
      log.error("Failed to load messages from file {}", name, e);
    }
  }

  /**
   * Recursively flattens a nested YAML map structure into a simple key-value map.
   *
   * @param prefix The current key prefix for nested keys.
   * @param map The nested YAML map to flatten.
   * @param result The resulting flattened map.
   */
  @SuppressWarnings("unchecked")
  private void flattenMap(String prefix, Map<Object, Object> map, Map<String, String> result) {
    for (Map.Entry<Object, Object> entry : map.entrySet()) {
      String key =
          prefix.isEmpty() ? String.valueOf(entry.getKey()) : prefix + "." + entry.getKey();
      Object value = entry.getValue();
      if (value instanceof Map) {
        // Recursive call for nested maps
        flattenMap(key, (Map<Object, Object>) value, result);
      } else {
        // Base case: add the flattened key-value pair
        result.put(key, value.toString());
      }
    }
  }
}
