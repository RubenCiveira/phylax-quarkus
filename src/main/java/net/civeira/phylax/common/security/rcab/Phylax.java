/* @autogenerated */
package net.civeira.phylax.common.security.rcab;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.OffsetDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Stream;

import org.eclipse.microprofile.config.inject.ConfigProperty;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import io.quarkus.arc.properties.IfBuildProperty;
import io.quarkus.runtime.StartupEvent;
import jakarta.annotation.Priority;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.security.Actor;
import net.civeira.phylax.common.security.RbacStore;
import net.civeira.phylax.common.security.scope.FieldDescription;
import net.civeira.phylax.common.security.scope.FieldGrant;
import net.civeira.phylax.common.security.scope.FieldGrantList;
import net.civeira.phylax.common.security.scope.ResourceDescription;
import net.civeira.phylax.common.security.scope.ScopeAllow;
import net.civeira.phylax.common.security.scope.ScopeAllowList;
import net.civeira.phylax.common.security.scope.ScopeDescription;

@Slf4j
@ApplicationScoped
@IfBuildProperty(name = "mp.rcab.model", stringValue = "phylax")
@RequiredArgsConstructor
public class Phylax implements RbacStore {
  private static final String API_KEY_HEADER = "api-key";
  private static final String CONTENT_TYPE = "Content-Type";
  private static final String APPLICATION_JSON = "application/json";
  private static final String INTERRUPTION_ERROR_MESSAGE = "Interruption while trying to register";
  private static final String RESOURCE_LITERAL = "resource";
  private static final String NAME_LITERAL = "name";
  private static final String DESCRIPTION_LITERAL = "description";
  private static final String KIND = "phylax";
  private final ObjectMapper mapper;
  private final @ConfigProperty(name = "mp.rcab.model") String model;
  private final @ConfigProperty(name = "mp.rcab.phylax.api-key") String apiKey;
  private final @ConfigProperty(name = "mp.rcab.phylax.audience") String audience;
  private final @ConfigProperty(name = "mp.rcab.phylax.register.scope") String registerScopeUrl;
  private final @ConfigProperty(
      name = "mp.rcab.phylax.register.schema") String registerPropertiesUrl;
  private final @ConfigProperty(name = "mp.rcab.phylax.check.grant") String checkGrantsUrl;

  private final HttpClient client = HttpClient.newHttpClient();
  private final ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);

  private List<PhylaxGrants> readScopes = null;
  private OffsetDateTime scopesExpiration = OffsetDateTime.now();
  private Map<String, Map<String, Object>> scopesToRegister = new HashMap<>();
  private Map<String, Map<String, Object>> propertiesToRegister = new HashMap<>();

  @Override
  public boolean isActive() {
    return KIND.equals(model);
  }

  @Override
  @SuppressWarnings("unchecked")
  public void registerResourceAction(ResourceDescription resource, ScopeDescription action) {
    if (!scopesToRegister.containsKey(resource.getName())) {
      scopesToRegister.put(resource.getName(), Map.of(RESOURCE_LITERAL,
          Map.of(NAME_LITERAL, resource.getName(), DESCRIPTION_LITERAL, resource.getDescription()),
          "scopes", new ArrayList<>()));
    }
    ((List<Object>) (scopesToRegister.get(resource.getName()).get("scopes")))
        .add(Map.of(NAME_LITERAL, action.getName(), "kind", action.getKind().toString(),
            DESCRIPTION_LITERAL, action.getDescription()));
  }

  @Override
  @SuppressWarnings("unchecked")
  public void registerResourceField(ResourceDescription resource, FieldDescription field) {
    if (!propertiesToRegister.containsKey(resource.getName())) {
      propertiesToRegister.put(resource.getName(), Map.of(RESOURCE_LITERAL,
          Map.of(NAME_LITERAL, resource.getName(), DESCRIPTION_LITERAL, resource.getDescription()),
          "properties", new ArrayList<>()));
    }
    ((List<Object>) (propertiesToRegister.get(resource.getName()).get("properties")))
        .add(Map.of(NAME_LITERAL, field.getName(), DESCRIPTION_LITERAL, field.getDescription()));
  }

  @Override
  public ScopeAllowList checkRoleScopes(Actor actor) {
    List<PhylaxGrants> grants = cachedCallCheckScopes();
    List<String> roles = Stream.concat(actor.getRoles().stream(), Stream.of("-")).toList();
    ScopeAllowList descriptions = new ScopeAllowList();
    grants.stream().filter(grant -> roles.contains(grant.getRolename()))
        .forEach(grant -> grant.getAllowedScopes().forEach(scope -> {
          String[] parts = scope.split("\\:");
          descriptions.add(ScopeAllow.builder().name(parts[1]).resource(parts[0]).build());
        }));
    return descriptions;
  }

  @Override
  public FieldGrantList checkRoleProperties(Actor actor) {
    List<PhylaxGrants> grants = cachedCallCheckScopes();
    List<String> roles = Stream.concat(actor.getRoles().stream(), Stream.of("-")).toList();

    FieldGrantList descriptions = new FieldGrantList();
    grants.stream().filter(grant -> roles.contains(grant.getRolename())).forEach(grant -> grant
        .getRestrictedFields().entrySet().forEach(entry -> entry.getValue().forEach(field -> {
          String[] parts = field.split("\\:");
          descriptions.add(
              FieldGrant.builder().view(entry.getKey()).name(parts[1]).resource(parts[0]).build());
        })));
    return descriptions;
  }

  void complete(@Observes @Priority(100) StartupEvent ev) {
    registerResources();
    registerProperties();

  }

  private void registerResources() {
    try {
      callRegisterScopes();
    } catch (IOException | URISyntaxException e) {
      executorService.schedule(() -> {
        try {
          callRegisterScopes();
        } catch (IOException | URISyntaxException er) {
          log.error("Error sending properties to register", er);
        } catch (InterruptedException er) {
          log.error(INTERRUPTION_ERROR_MESSAGE, er);
          Thread.currentThread().interrupt();
        }
      }, 10, TimeUnit.SECONDS);
    } catch (InterruptedException er) {
      log.error(INTERRUPTION_ERROR_MESSAGE, er);
      Thread.currentThread().interrupt();
    }
  }

  private void registerProperties() {
    try {
      callRegisterProperties();
    } catch (IOException | URISyntaxException e) {
      executorService.schedule(() -> {
        try {
          callRegisterProperties();
        } catch (IOException | URISyntaxException er) {
          log.error("Error sending properties to register", er);
        } catch (InterruptedException er) {
          log.error(INTERRUPTION_ERROR_MESSAGE, er);
          Thread.currentThread().interrupt();
        }
      }, 10, TimeUnit.SECONDS);
    } catch (InterruptedException er) {
      log.error(INTERRUPTION_ERROR_MESSAGE, er);
      Thread.currentThread().interrupt();
    }
  }

  private void callRegisterScopes() throws IOException, InterruptedException, URISyntaxException {
    String json = mapper.writeValueAsString(scopesToRegister.values());

    HttpRequest request = HttpRequest.newBuilder().uri(new URI(registerScopeUrl))
        .header(API_KEY_HEADER, apiKey).header(CONTENT_TYPE, APPLICATION_JSON)
        .POST(HttpRequest.BodyPublishers.ofString(json)).build();
    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
    if (response.statusCode() >= 400) {
      throw new IOException("Error " + response.statusCode() + ": " + response.body());
    }
    scopesToRegister.clear();
  }

  private void callRegisterProperties()
      throws IOException, InterruptedException, URISyntaxException {
    String json = mapper.writeValueAsString(propertiesToRegister.values());

    HttpRequest request = HttpRequest.newBuilder().uri(new URI(registerPropertiesUrl))
        .header(API_KEY_HEADER, apiKey).header(CONTENT_TYPE, APPLICATION_JSON)
        .POST(HttpRequest.BodyPublishers.ofString(json)).build();
    HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
    if (response.statusCode() >= 400) {
      throw new IOException("Error " + response.statusCode() + ": " + response.body());
    }
    propertiesToRegister.clear();
  }

  private synchronized List<PhylaxGrants> cachedCallCheckScopes() {
    if (scopesExpiration.isBefore(OffsetDateTime.now())) {
      scopesExpiration = OffsetDateTime.now().plus(15, ChronoUnit.MINUTES);
      readScopes = callCheckScopes();
    }
    return readScopes;
  }

  private List<PhylaxGrants> callCheckScopes() {
    try {
      HttpRequest request = HttpRequest.newBuilder().uri(new URI(checkGrantsUrl))
          .header(API_KEY_HEADER, apiKey).header(CONTENT_TYPE, APPLICATION_JSON).GET().build();

      HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
      if (response.statusCode() >= 400) {
        throw new IllegalArgumentException(
            "Error " + response.statusCode() + ": " + response.body());
      } else {
        return readFromResponse(response);
      }
    } catch (URISyntaxException | IOException e) {
      throw new IllegalArgumentException("Unable to determinate phylax url", e);
    } catch (InterruptedException er) {
      log.error(INTERRUPTION_ERROR_MESSAGE, er);
      Thread.currentThread().interrupt();
      throw new IllegalArgumentException("Unable to determinate phylax url", er);
    }
  }

  private List<PhylaxGrants> readFromResponse(HttpResponse<String> response) {
    try {
      return mapper.readValue(response.body(), new TypeReference<List<PhylaxGrants>>() {});
    } catch (JsonProcessingException e) {
      throw new IllegalArgumentException(
          "Unable to parse as a phylax grants response" + response.body(), e);
    }
  }
}
