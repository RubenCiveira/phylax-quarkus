/* @autogenerated */
package net.civeira.phylax.common.exception;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Stream;

import net.civeira.phylax.common.value.validation.AbstractFail;
import net.civeira.phylax.common.value.validation.AbstractFail.LocalizedFail;
import net.civeira.phylax.common.value.validation.AbstractFail.LocalizedWrongValue;
import net.civeira.phylax.common.value.validation.AbstractFailList;

/**
 * Base class for exceptions that encapsulate one or more validation failures.
 *
 * <p>
 * This abstract exception provides a unified mechanism for handling and propagating structured
 * validation errors through the application. It wraps an {@link AbstractFailList}, which may
 * contain multiple {@link AbstractFail} instances, allowing clients to inspect, localize, and
 * filter specific failure types.
 * </p>
 *
 * <p>
 * Intended for use in domain validation, request preconditions, or other constraint-based
 * validation logic where rich error reporting is needed.
 * </p>
 *
 * <p>
 * Localization support is provided via the {@link #localize(Locale, boolean)} method, enabling
 * translation of validation failures for display or API responses.
 * </p>
 *
 * @see AbstractFail
 * @see AbstractFailList
 * @see ConstraintFail
 * @see LocalizedFail
 */
public abstract class AbstractFailsException extends RuntimeException {
  private static final long serialVersionUID = 261476585734235759L;

  /** The list of validation failures associated with this exception. */
  private final AbstractFailList fails;

  /**
   * Constructs the exception with a full list of validation failures.
   *
   * @param message the message
   * @param fails the list of validation failures to include
   */
  public AbstractFailsException(String message, AbstractFailList fails) {
    super(message(message, fails));
    this.fails = fails;
  }

  /**
   * Constructs the exception with a single validation failure.
   *
   * @param message the message
   * @param fail a single validation failure to include
   */
  public AbstractFailsException(String message, AbstractFail fail) {
    this(message, new AbstractFailList(fail));
  }

  /**
   * Returns {@code true} if the exception contains at least one validation error.
   *
   * @return {@code true} if there are any validation errors
   */
  public boolean hasErrors() {
    return fails.hasErrors();
  }

  /**
   * Returns {@code true} if the exception does not contain any validation failures.
   *
   * @return {@code true} if the error list is empty
   */
  public boolean isEmpty() {
    return fails.isEmpty();
  }

  /**
   * Checks if the list of validation failures includes a violation of a specific type.
   *
   * @param type the type of violation to check for
   * @param <T> a subtype of {@link ConstraintFail}
   * @return {@code true} if a violation of the given type exists
   */
  public <T extends AbstractFail> boolean includeViolation(Class<T> type) {
    return fails.includeViolation(type);
  }

  /**
   * Checks if any of the validation failures match the given error code.
   *
   * @param code the error code to look for
   * @return {@code true} if any failure has the given code
   */
  public boolean includeCode(String code) {
    return fails.includeCode(code);
  }

  /**
   * Returns a stream of all validation failures associated with this exception.
   *
   * @return a {@link Stream} of {@link AbstractFail} objects
   */
  public Stream<? extends AbstractFail> getFails() {
    return fails.getFails();
  }

  /**
   * Returns a localized version of the validation failures for the given locale.
   *
   * <p>
   * If multiple failures share the same code, their {@link LocalizedWrongValue} values will be
   * combined under a single {@link LocalizedFail} entry.
   * </p>
   *
   * @param locale the target {@link Locale} for localization
   * @param withSource if {@code true}, includes additional context such as field names or source
   *        information
   * @return a collection of {@link LocalizedFail} instances grouped by error code
   */
  public Collection<LocalizedFail> localize(Locale locale, boolean withSource) {
    Map<String, LocalizedFail> values = new LinkedHashMap<>();
    fails.getFails().map(fail -> fail.localize(locale, withSource)).forEach(lf -> {
      if (values.containsKey(lf.getCode())) {
        LocalizedFail localizedFail = values.get(lf.getCode());
        List<LocalizedWrongValue> wrongValues = new ArrayList<>(localizedFail.getWrongValues());
        wrongValues.addAll(lf.getWrongValues());
        values.put(lf.getCode(), localizedFail.toBuilder().wrongValues(wrongValues).build());
      } else {
        values.put(lf.getCode(), lf);
      }
    });
    return values.values();
  }

  private static String message(String on, AbstractFailList list) {
    Map<String, StringBuilder> parts = new HashMap<>();
    list.getFails().forEach(fail -> {
      String key = fail.getCode();
      if (!parts.containsKey(key)) {
        parts.put(key, new StringBuilder());
      }
      parts.get(key).append(", " + fail.getViolation());
    });
    StringBuilder rest = new StringBuilder();
    parts.entrySet().forEach(entry -> {
      rest.append("; " + entry.getKey() + ": " + entry.getValue().substring(2));
    });
    StringBuilder label = new StringBuilder(on);
    if (!rest.isEmpty()) {
      label.append(rest.substring(2));
    }
    return label.toString();
  }
}
