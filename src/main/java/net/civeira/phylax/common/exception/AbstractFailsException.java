/* @autogenerated */
package net.civeira.phylax.common.exception;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Stream;

import net.civeira.phylax.common.value.validation.AbstractFail;
import net.civeira.phylax.common.value.validation.AbstractFail.LocalizedFail;
import net.civeira.phylax.common.value.validation.AbstractFail.LocalizedWrongValue;
import net.civeira.phylax.common.value.validation.AbstractFailList;

/**
 * Base class for exceptions that encapsulate one or more validation failures.
 *
 * It provides a structured mechanism to propagate rich validation errors. Each instance wraps an
 * {@link AbstractFailList} with one or more failures. Consumers can inspect, filter, and localize
 * failures for API responses. This is intended for domain validation and request precondition
 * violations.
 *
 * @see AbstractFail
 * @see AbstractFailList
 * @see ConstraintFail
 * @see LocalizedFail
 */
public abstract class AbstractFailsException extends RuntimeException {
  private static final long serialVersionUID = 261476585734235759L;

  /** The list of validation failures associated with this exception. */
  private final AbstractFailList fails;

  /**
   * Constructs the exception with a full list of validation failures.
   *
   * The message is combined with failure details for a readable default message. The list is stored
   * for later inspection and localization. Use this constructor when multiple failures must be
   * reported together.
   *
   * @param message the message
   * @param fails the list of validation failures to include
   */
  public AbstractFailsException(String message, AbstractFailList fails) {
    super(message(message, fails));
    this.fails = fails;
  }

  /**
   * Constructs the exception with a single validation failure.
   *
   * This wraps the failure into a list to keep behavior consistent. Use this when only one error is
   * present and you want a concise API. The failure can still be localized via
   * {@link #localize(Locale, boolean)}.
   *
   * @param message the message
   * @param fail a single validation failure to include
   */
  public AbstractFailsException(String message, AbstractFail fail) {
    this(message, new AbstractFailList(fail));
  }

  /**
   * Returns {@code true} if the exception contains at least one validation error.
   *
   * This delegates to the underlying failure list. Use it to short-circuit when no errors were
   * recorded. It does not distinguish between warning and error severity.
   *
   * @return {@code true} if there are any validation errors
   */
  public boolean hasErrors() {
    return fails.hasErrors();
  }

  /**
   * Returns {@code true} if the exception does not contain any validation failures.
   *
   * This is the inverse of {@link #hasErrors()} for convenience. It is useful when failures are
   * collected conditionally. An empty list usually means the exception should not be thrown.
   *
   * @return {@code true} if the error list is empty
   */
  public boolean isEmpty() {
    return fails.isEmpty();
  }

  /**
   * Checks if the list of validation failures includes a violation of a specific type.
   *
   * This allows callers to detect a particular validation rule quickly. It scans the failure list
   * using the provided type class. Use it to branch error handling or map to specific responses.
   *
   * @param type the type of violation to check for
   * @param <T> a subtype of {@link ConstraintFail}
   * @return {@code true} if a violation of the given type exists
   */
  public <T extends AbstractFail> boolean includeViolation(Class<T> type) {
    return fails.includeViolation(type);
  }

  /**
   * Checks if any of the validation failures match the given error code.
   *
   * Codes are typically stable identifiers for validation rules. Use this to map errors to specific
   * HTTP responses or UI messages. The comparison is exact and case-sensitive.
   *
   * @param code the error code to look for
   * @return {@code true} if any failure has the given code
   */
  public boolean includeCode(String code) {
    return fails.includeCode(code);
  }

  /**
   * Returns a stream of all validation failures associated with this exception.
   *
   * The stream provides direct access to each failure instance. Consumers can filter by type, code,
   * or field. The returned stream reflects the underlying failure list.
   *
   * @return a {@link Stream} of {@link AbstractFail} objects
   */
  public Stream<? extends AbstractFail> getFails() {
    return fails.getFails();
  }

  /**
   * Returns a localized version of the validation failures for the given locale.
   *
   * Failures sharing the same code are grouped and their wrong values merged. Localization uses the
   * underlying fail definitions to build messages. The withSource flag controls whether field names
   * and sources are included.
   *
   * @param locale the target {@link Locale} for localization
   * @param withSource if {@code true}, includes field and source context
   * @return a collection of {@link LocalizedFail} instances grouped by error code
   */
  public Collection<LocalizedFail> localize(Locale locale, boolean withSource) {
    Map<String, LocalizedFail> values = new LinkedHashMap<>();
    fails.getFails().map(fail -> fail.localize(locale, withSource)).forEach(lf -> {
      if (values.containsKey(lf.getCode())) {
        LocalizedFail localizedFail = values.get(lf.getCode());
        List<LocalizedWrongValue> wrongValues = new ArrayList<>(localizedFail.getWrongValues());
        wrongValues.addAll(lf.getWrongValues());
        values.put(lf.getCode(), localizedFail.toBuilder().wrongValues(wrongValues).build());
      } else {
        values.put(lf.getCode(), lf);
      }
    });
    return values.values();
  }

  private static String message(String on, AbstractFailList list) {
    Map<String, StringBuilder> parts = new HashMap<>();
    list.getFails().forEach(fail -> {
      String key = fail.getCode();
      if (!parts.containsKey(key)) {
        parts.put(key, new StringBuilder());
      }
      parts.get(key).append(", " + fail.getViolation());
    });
    StringBuilder rest = new StringBuilder();
    parts.entrySet().forEach(entry -> {
      rest.append("; " + entry.getKey() + ": " + entry.getValue().substring(2));
    });
    StringBuilder label = new StringBuilder(on);
    if (!rest.isEmpty()) {
      label.append(rest.substring(2));
    }
    return label.toString();
  }

}
