/* @autogenerated */
package net.civeira.phylax.common.crypto;

import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.NoSuchAlgorithmException;
import java.security.ProviderException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.util.Base64;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.text.StringEscapeUtils;
import org.eclipse.microprofile.config.inject.ConfigProperty;

import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * A utility service for encrypting and decrypting data using AES encryption in GCM mode.
 *
 * <p>
 * This class provides methods for secure encryption and decryption of text using either a
 * user-provided password or an application-wide configured key. The AES algorithm is used with
 * Galois/Counter Mode (GCM), offering both confidentiality and integrity via authenticated
 * encryption.
 * </p>
 *
 * <p>
 * The encryption process includes the generation of a random salt and IV (Initialization Vector),
 * and uses the PBKDF2 key derivation function (with HMAC-SHA256) to derive a strong encryption key
 * from passwords.
 * </p>
 *
 * <p>
 * The service also offers secure random password and API secret generation utilities, combining
 * alphanumeric characters, digits, and symbols for enhanced entropy.
 * </p>
 *
 * <p>
 * This class is designed to be application-scoped and injectable via CDI in MicroProfile
 * environments.
 * </p>
 *
 * <h3>Configuration</h3>
 * <ul>
 * <li><strong>app.security.encryption.key</strong>: The default encryption key used for
 * application-wide encryption/decryption operations.</li>
 * </ul>
 *
 * @see javax.crypto.Cipher
 * @see javax.crypto.spec.GCMParameterSpec
 * @see javax.crypto.spec.PBEKeySpec
 * @see java.security.SecureRandom
 */
@Slf4j
@ApplicationScoped
@RequiredArgsConstructor
public class AesCipherService {
  /** Encryption algorithm used: AES-GCM with no padding. */
  private static final String ENCRYPT_ALGO = "AES/GCM/NoPadding";

  /**
   * Shared {@link SecureRandom} instance. Initializing {@code SecureRandom} is expensive because it
   * seeds from the OS entropy pool; reusing a single instance avoids that cost on every call.
   * {@code SecureRandom} is thread-safe so sharing it across calls is safe.
   */
  private static final SecureRandom SECURE_RANDOM = new SecureRandom();

  /** Length of the initialization vector (IV) in bytes. */
  private static final int IV_LENGTH_BYTE = 12;

  /** Length of the salt in bytes. */
  private static final int SALT_LENGTH_BYTE = 16;

  /** Length of the authentication tag (must be one of {128, 120, 112, 104, 96}). */
  private static final int TAG_LENGTH_BIT = 128;

  /** Encryption key configured for application-wide encryption. */
  @ConfigProperty(name = "app.security.encryption.key")
  private final String cipherKey;

  /**
   * Decrypts a Base64-encoded AES-encrypted string using a password.
   *
   * <p>
   * The input must be in the format generated by the {@link #encrypt(String, String)} method,
   * including IV and salt prepended to the ciphertext.
   * </p>
   *
   * The method returns an empty optional when the payload cannot be decrypted. This can happen due
   * to invalid input, wrong password, or corrupted data. Callers should treat empty results as a
   * decryption failure.
   *
   * @param cipherText the Base64-encoded encrypted string
   * @param password the password used to derive the decryption key
   * @return an {@link Optional} containing the decrypted string, or {@code Optional.empty()} if
   *         decryption fails
   */
  public Optional<String> decrypt(String cipherText, String password) {
    try {
      byte[] decode = Base64.getDecoder().decode(cipherText);

      // get back the iv and salt from the cipher text
      ByteBuffer bb = ByteBuffer.wrap(decode);

      byte[] iv = new byte[IV_LENGTH_BYTE];
      bb.get(iv);

      byte[] salt = new byte[SALT_LENGTH_BYTE];
      bb.get(salt);

      byte[] cipherBytes = new byte[bb.remaining()];
      bb.get(cipherBytes);

      // get back the aes key from the same password and salt
      SecretKey aesKeyFromPassword = getAESKeyFromPassword(password.toCharArray(), salt);

      Cipher cipher = Cipher.getInstance(ENCRYPT_ALGO);

      cipher.init(Cipher.DECRYPT_MODE, aesKeyFromPassword,
          new GCMParameterSpec(TAG_LENGTH_BIT, iv));

      byte[] plainText = cipher.doFinal(cipherBytes);

      return Optional.of(new String(plainText, StandardCharsets.UTF_8));
    } catch (BufferUnderflowException | IllegalArgumentException | GeneralSecurityException
        | ProviderException ex) {
      if (log.isErrorEnabled()) {
        log.error("Unable to decript text for {}", StringEscapeUtils.escapeJson(ex.getMessage()));
      }
      return Optional.empty();
    }
  }

  /**
   * Decrypts a Base64-encoded AES-encrypted string using the configured application key.
   *
   * This is a convenience wrapper around {@link #decrypt(String, String)}. It uses the configured
   * encryption key from application configuration. Returns empty when decryption fails for any
   * reason.
   *
   * @param cText the Base64-encoded encrypted string
   * @return an {@link Optional} containing the decrypted string, or empty if decryption fails
   */
  public Optional<String> decryptForAll(String cText) {
    return decrypt(cText, cipherKey);
  }


  /**
   * Encrypts a string using AES-GCM with a user-provided password.
   *
   * The output includes a randomly generated salt and IV prepended to the ciphertext. The payload
   * is Base64-encoded to allow storage and transport as text. Use {@link #decrypt(String, String)}
   * to reverse the operation.
   *
   * @param value the plaintext string to encrypt
   * @param password the password used to derive the encryption key
   * @return the Base64-encoded ciphertext including IV and salt
   * @throws IllegalStateException if encryption fails due to a security error
   */
  public String encrypt(String value, String password) {
    try {
      byte[] pText = value.getBytes(StandardCharsets.UTF_8);

      // Generate random salt and IV
      byte[] salt = getRandomNonce(SALT_LENGTH_BYTE);
      byte[] iv = getRandomNonce(IV_LENGTH_BYTE);

      // Derive the key from the password using PBKDF2
      SecretKey aesKeyFromPassword = getAESKeyFromPassword(password.toCharArray(), salt);

      Cipher cipher = Cipher.getInstance(ENCRYPT_ALGO);
      cipher.init(Cipher.ENCRYPT_MODE, aesKeyFromPassword,
          new GCMParameterSpec(TAG_LENGTH_BIT, iv));

      byte[] cipherText = cipher.doFinal(pText);

      // Combine IV, salt, and ciphertext
      byte[] cipherTextWithIvSalt = ByteBuffer.allocate(iv.length + salt.length + cipherText.length)
          .put(iv).put(salt).put(cipherText).array();

      // Convert to Base64
      return Base64.getEncoder().encodeToString(cipherTextWithIvSalt);
    } catch (GeneralSecurityException e) {
      throw new IllegalStateException(e);
    }
  }


  /**
   * Encrypts a string using the application-wide encryption key.
   *
   * This is a convenience wrapper that avoids passing the key explicitly. It uses the configured
   * key from application properties. The output is Base64-encoded and includes salt and IV.
   *
   * @param value the plaintext string to encrypt
   * @return the Base64-encoded ciphertext including IV and salt
   */
  public String encryptForAll(String value) {
    return encrypt(value, cipherKey);
  }

  /**
   * Generates a secure, random API secret string.
   *
   * The result includes digits, letters, and special characters for entropy. It is suitable for API
   * keys, client secrets, or one-time tokens. The exact composition is randomized for each
   * invocation.
   *
   * @return a secure, randomly generated secret string
   */
  public String generateSecureRandomApiSecret() {
    Stream<Character> pwdStream = Stream.concat(getRandomNumbers(2),
        Stream.concat(getRandomSpecialChars(2),
            Stream.concat(getRandomAlphabets(2, true),
                Stream.concat(getRandomSpecialChars(3), Stream.concat(getRandomAlphabets(10, false),
                    Stream.concat(getRandomNumbers(4), getRandomAlphabets(10, false)))))));
    List<Character> charList = pwdStream.collect(Collectors.toList());
    Collections.shuffle(charList, SECURE_RANDOM);
    return charList.stream()
        .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
  }


  /**
   * Generates a secure, random password string.
   *
   * The output combines letters, digits, and special characters. It is intended for
   * system-generated passwords with strong entropy. The composition is randomized for each call.
   *
   * @return a secure, randomly generated password
   */
  public String generateSecureRandomPassword() {
    Stream<Character> pwdStream =
        Stream.concat(getRandomNumbers(2), Stream.concat(getRandomSpecialChars(2),
            Stream.concat(getRandomAlphabets(2, true), getRandomAlphabets(4, false))));
    List<Character> charList = pwdStream.collect(Collectors.toList());
    Collections.shuffle(charList, SECURE_RANDOM);
    return charList.stream()
        .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
  }


  /**
   * Generates a stream of random ASCII special characters.
   *
   * @param count the number of characters to generate
   * @return a stream of special characters
   */
  private Stream<Character> getRandomSpecialChars(int count) {
    IntStream specialChars = SECURE_RANDOM.ints(count, 33, 45);
    return specialChars.mapToObj(data -> (char) data);
  }

  /**
   * Generates a stream of random alphabetic characters.
   *
   * @param count the number of characters to generate
   * @param uppercase whether to generate uppercase or lowercase characters
   * @return a stream of alphabetic characters
   */
  private Stream<Character> getRandomAlphabets(int count, boolean uppercase) {
    IntStream specialChars = SECURE_RANDOM.ints(count, uppercase ? 65 : 97, uppercase ? 90 : 122);
    return specialChars.mapToObj(data -> (char) data);
  }

  /**
   * Generates a stream of random numeric characters (digits).
   *
   * @param count the number of digits to generate
   * @return a stream of numeric characters
   */
  private Stream<Character> getRandomNumbers(int count) {
    IntStream specialChars = SECURE_RANDOM.ints(count, 48, 57);
    return specialChars.mapToObj(data -> (char) data);
  }


  /**
   * Derives an AES key from a password and salt using PBKDF2 with HMAC-SHA256.
   *
   * @param password the password to use for key derivation
   * @param salt the salt to use in key derivation
   * @return the derived AES {@link SecretKey}
   * @throws NoSuchAlgorithmException if PBKDF2 algorithm is unavailable
   * @throws InvalidKeySpecException if the key specification is invalid
   */
  private static SecretKey getAESKeyFromPassword(char[] password, byte[] salt)
      throws NoSuchAlgorithmException, InvalidKeySpecException {
    SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
    KeySpec spec = new PBEKeySpec(password, salt, 600_000, 256);
    return new SecretKeySpec(factory.generateSecret(spec).getEncoded(), "AES");
  }

  /**
   * Generates a cryptographically secure random byte array (nonce).
   *
   * @param numBytes the number of bytes to generate
   * @return a byte array filled with secure random data
   */
  private static byte[] getRandomNonce(int numBytes) {
    byte[] nonce = new byte[numBytes];
    SECURE_RANDOM.nextBytes(nonce);
    return nonce;
  }
}
