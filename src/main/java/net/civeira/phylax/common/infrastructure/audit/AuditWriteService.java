/* @autogenerated */
package net.civeira.phylax.common.infrastructure.audit;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.Timestamp;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;

import javax.sql.DataSource;

import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;

/**
 * Persists audit events to the audit store.
 *
 * The service writes audit records to the configured audit table. It is invoked by application
 * services when state changes occur. This provides a durable trail of operations for compliance and
 * debugging. The write path is optimized for append-only audit semantics.
 */
@ApplicationScoped
@RequiredArgsConstructor
public class AuditWriteService {

  private final DataSource dataSource;

  private final ObjectMapper mapper;

  /**
   * Records an audit event into the configured audit table.
   *
   * The table name is resolved from the provided prefix or schema. Events are stored with actor,
   * timestamp, entity, and payload details. Use this for mutation operations that require audit
   * trails.
   *
   * @param on audit table prefix or schema identifier
   * @param event audit event to persist
   */
  public void record(String on, AuditEvent event) {
    String sql = "INSERT INTO " + on + "_audit ( " + """
                id, operation, usecase, trace_id, entity_id,
                old_values, new_values,
                performed_by, tenant, timestamp,
                source_request, remote_address, remote_application, remote_device,
                claims, span_id
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """;

    try (Connection conn = dataSource.getConnection();
        PreparedStatement ps = conn.prepareStatement(sql)) {

      Map<String, String> oldValues = event.getOldValue();
      if (null == oldValues) {
        oldValues = Map.of();
      }
      Map<String, String> newValues = event.getNewValue();
      if (null == newValues) {
        newValues = Map.of();
      }

      // Detect only differences
      Map<String, String> filteredOld = new HashMap<>();
      Map<String, String> filteredNew = new HashMap<>();

      Set<String> allKeys = new HashSet<>();
      allKeys.addAll(oldValues.keySet());
      allKeys.addAll(newValues.keySet());

      for (String key : allKeys) {
        String oldVal = oldValues.get(key);
        String newVal = newValues.get(key);

        if (!Objects.equals(oldVal, newVal)) {
          if (oldVal != null) {
            filteredOld.put(key, oldVal);
          }
          if (newVal != null) {
            filteredNew.put(key, newVal);
          }
        }
      }
      ps.setString(1, UUID.randomUUID().toString());
      ps.setString(2, event.getOperation());
      ps.setString(3, event.getUsecase());
      ps.setString(4, event.getTraceId());
      ps.setString(5, event.getEntityId());
      ps.setString(6, mapper.writeValueAsString(filteredOld));
      ps.setString(7, mapper.writeValueAsString(filteredNew));
      ps.setString(8, event.getPerformedBy());
      ps.setString(9, event.getTenant());
      ps.setTimestamp(10, Timestamp.from(event.getTimestamp().toInstant()));
      ps.setString(11, event.getSourceRequest());
      ps.setString(12, event.getRemoteAddress());
      ps.setString(13, event.getRemoteApplication());
      ps.setString(14, event.getRemoteDevice());
      ps.setString(15, mapper.writeValueAsString(event.getClaims()));
      ps.setString(16, event.getSpanId());
      ps.executeUpdate();
    } catch (Exception e) {
      throw new RuntimeException("Error writing audit event", e);
    }
  }
}
