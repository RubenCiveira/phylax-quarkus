/* autogenerated */
package net.civeira.phylax.common.infrastructure.mail;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.apache.commons.io.FileUtils;
import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.quarkus.mailer.Mail;
import io.quarkus.mailer.Mailer;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;

/**
 * Sends email messages using the configured Quarkus mailer.
 *
 * The service supports synchronous and asynchronous delivery modes. It applies configuration
 * overrides and handles attachments and inline resources. Errors are reported via optional
 * observers on {@link EmailMessage} instances. This is intended for internal notifications and
 * automated emails.
 */
@ApplicationScoped
@RequiredArgsConstructor
public class EmailService {

  private static final Logger LOGGER = LoggerFactory.getLogger(EmailService.class);

  private final Mailer mailer;
  @ConfigProperty(name = "mailer.thread-pool", defaultValue = "5")
  private final int poolSize;
  @ConfigProperty(name = "mailer.auth-methods",
      defaultValue = "DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 PLAIN LOGIN")
  private final String mailAuthMethod;
  @ConfigProperty(name = "mailer.host", defaultValue = "")
  private final String mailHost;
  @ConfigProperty(name = "mailer.port", defaultValue = "857")
  private final int mailPort;
  @ConfigProperty(name = "mailer.start-tls", defaultValue = "REQUIRED")
  private final String mailStartTls;
  @ConfigProperty(name = "mailer.from", defaultValue = "")
  private final String mailFrom;
  @ConfigProperty(name = "mailer.username", defaultValue = "")
  private final String mailUsername;
  @ConfigProperty(name = "mailer.password", defaultValue = "")
  private final String mailPassword;

  private ExecutorService executor;

  /**
   * Sends messages asynchronously using the default configuration.
   *
   * Messages are queued into a thread pool for background sending. Observers on each message are
   * notified on success or failure. The method returns immediately and does not block the caller.
   *
   * @param message messages to send
   */
  public void delaySendMessages(EmailMessage... message) {
    delaySendMessages(Optional.empty(), message);
  }

  /**
   * Sends messages asynchronously using an optional configuration override.
   *
   * The override allows per-message SMTP settings and credentials. Messages are queued into a
   * thread pool for background sending. Observers on each message are notified on success or
   * failure.
   *
   * @param config optional mail configuration
   * @param message messages to send
   */
  public synchronized void delaySendMessages(Optional<MailConfiguration> config,
      EmailMessage... message) {
    if (null == executor) {
      executor = Executors.newFixedThreadPool(10);
    }
    for (final EmailMessage emailMessage : message) {
      executor.submit(() -> sendMessage(emailMessage, config));
    }
  }

  /**
   * Sends a message synchronously using the default configuration.
   *
   * The call blocks until the mailer finishes sending. Observers on the message are notified on
   * success or failure. Use the async methods when sending in request threads.
   *
   * @param message message to send
   */
  public void sendMessage(EmailMessage message) {
    sendMessage(message, Optional.empty());
  }

  /**
   * Sends a message synchronously using an optional configuration override.
   *
   * The override allows per-message SMTP settings and credentials. The call blocks until the mailer
   * finishes sending. Observers on the message are notified on success or failure.
   *
   * @param message message to send
   * @param config optional mail configuration
   */
  public void sendMessage(EmailMessage message, Optional<MailConfiguration> config) {
    try {
      String to = message.getTargetName() + " <" + message.getTargetAddress() + ">";
      Mail mail = null == message.getHtmlContent()
          ? Mail.withText(to, message.getSubject(), message.getContent())
          : Mail.withHtml(to, message.getSubject(), message.getHtmlContent());

      attached(mail, message.getEmbbeds(), true);
      attached(mail, message.getAttacheds(), false);
      if (null != message.getHtmlContent()) {
        mail.setText(
            null == message.getContent() ? message.getHtmlContent() : message.getContent());
      }
      /*
       * @ConfigProperty(name = "quarkus.mailer.from", defaultValue = "5") private final String
       * mailFrom;
       * 
       */
      System.setProperty("quarkus.mailer.host", mailHost);
      System.setProperty("quarkus.mailer.from", mailFrom);
      System.setProperty("quarkus.mailer.port", String.valueOf(mailPort));
      System.setProperty("quarkus.mailer.username", mailUsername);
      System.setProperty("quarkus.mailer.password", mailPassword);
      System.setProperty("quarkus.mailer.start-tls", mailStartTls);
      System.setProperty("quarkus.mailer.auth-methods", mailAuthMethod);

      config.ifPresent(conf -> {
        if (conf.isUseTtls()) {
          System.setProperty("quarkus.mailer.start-tls", "REQUIRED");
          System.setProperty("quarkus.mailer.auth-methods",
              "DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 PLAIN LOGIN");
        } else {
          System.setProperty("quarkus.mailer.start-tls", "NONE");
          System.setProperty("quarkus.mailer.auth-methods",
              "DIGEST-MD5 CRAM-SHA256 CRAM-SHA1 CRAM-MD5 PLAIN LOGIN");
        }
        System.setProperty("quarkus.mailer.host", conf.getSmtpHost());
        System.setProperty("quarkus.mailer.port", String.valueOf(conf.getSmtpPort()));
        System.setProperty("quarkus.mailer.username", conf.getSmtpLogin());
        System.setProperty("quarkus.mailer.password", conf.getSmtpPass());
        System.setProperty("quarkus.mailer.from",
            conf.getFromName() + "<" + conf.getFromEmail() + ">");
      });
      mailer.send(mail);
      System.err.println(mailFrom);
      System.err.println(this.mailHost);
      System.err.println(this.mailUsername);
      System.err.println(this.mailPassword);
      System.err.println("GOGOGOGGO");
      message.getSendedObserver().ifPresent(MailSended::ok);
    } catch (Exception ex) {
      message.getFailObserver().ifPresent(obs -> obs.fail(ex));
      LOGGER.error("Imposible enviar email {} a {} <{}> por {}", message.getSubject(),
          message.getTargetName(), message.getTargetAddress(), ex.getMessage());
    }
  }

  private void attached(Mail mail, List<Attach> attachs, boolean inline) {
    for (Attach attach : attachs) {
      attach.getFichero().ifPresent(file -> {
        String contentType = null;
        if (inline) {
          mail.addInlineAttachment(file.getName(), file, contentType, "<" + attach.getCid() + ">");
        } else {
          mail.addAttachment(file.getName(), file, contentType);
        }
      });
      attach.getDatasource().ifPresent(datasource -> {
        try {
          File file = Files.createTempFile("mail", ".bin").toFile();
          FileUtils.copyInputStreamToFile(datasource.getInputStream(), file);
          if (inline) {
            mail.addInlineAttachment(datasource.getName(), file, datasource.getContentType(),
                "<" + attach.getCid() + ">");
          } else {
            mail.addAttachment(datasource.getName(), file, datasource.getContentType());
          }
          file.delete();
        } catch (IOException ex) {
          LOGGER.error("Unable to retrieve attach datasource " + datasource.getName(), ex);
        }
      });
    }
  }
}
