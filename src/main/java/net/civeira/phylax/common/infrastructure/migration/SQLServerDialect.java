/* @autogenerated */
package net.civeira.phylax.common.infrastructure.migration;

/**
 * SQL dialect implementation for Microsoft SQL Server migrations.
 *
 * It provides SQL statements compatible with SQL Server syntax and system tables. The dialect uses
 * GETDATE() for timestamps and BIT for lock flags. Conditional table creation is handled with
 * sysobjects checks. This is used by the migration manager when SQL Server is detected.
 */
public class SQLServerDialect implements SQLDialect {

  /**
   * Builds the SQL to create the migration log table for SQL Server.
   *
   * It uses sysobjects to ensure the table exists before creation. The log table stores filename,
   * checksum, and error metadata.
   *
   * @param name table name
   * @return SQL statement for creating the log table
   */
  @Override
  public String createLogTable(String name) {
    return "IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='" + name
        + "' AND xtype='U')CREATE TABLE " + name
        + " (name NVARCHAR(250),filename NVARCHAR(250),md5sum NVARCHAR(64),execution DATETIME,error NVARCHAR(250));";
  }

  /**
   * Builds the SQL to create the migration lock table for SQL Server.
   *
   * It uses sysobjects to ensure the table exists before creation. The lock table uses BIT flags
   * and DATETIME for grant times.
   *
   * @param name table name
   * @return SQL statement for creating the lock table
   */
  @Override
  public String createLockTable(String name) {
    return "IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='" + name
        + "' AND xtype='U')CREATE TABLE " + name
        + " (id INT PRIMARY KEY,locked BIT,granted DATETIME);";
  }

  /**
   * Builds the SQL to insert the lock row for SQL Server.
   *
   * It checks whether the row exists before inserting. This establishes the single row used for
   * lock coordination.
   *
   * @param name table name
   * @return SQL statement for inserting the lock row
   */
  @Override
  public String insertLock(String name) {
    return "IF NOT EXISTS (SELECT * FROM " + name + " WHERE id = 1) INSERT INTO " + name
        + " (id, locked, granted) VALUES (1, 0, NULL);";
  }

  /**
   * Builds SQL to record a successful migration in SQL Server.
   *
   * The statement updates an existing entry or inserts a new one. It uses GETDATE() to record the
   * execution time.
   *
   * @param name table name
   * @param exists whether the entry already exists
   * @return SQL statement to mark success
   */
  @Override
  public String markOkSql(String name, boolean exists) {
    return exists
        ? "UPDATE " + name
            + " SET md5sum=?, error=NULL, execution=GETDATE() WHERE name=? AND filename=?"
        : "INSERT INTO " + name
            + " (md5sum, error, name, filename, execution) VALUES (?, NULL, ?, ?, GETDATE())";
  }

  /**
   * Builds SQL to record a failed migration in SQL Server.
   *
   * The statement updates an existing entry or inserts a new one. It uses GETDATE() to record the
   * execution time.
   *
   * @param name table name
   * @param exists whether the entry already exists
   * @return SQL statement to mark failure
   */
  @Override
  public String markFailSql(String name, boolean exists) {
    return exists
        ? "UPDATE " + name
            + " SET md5sum=?, error=?, execution=GETDATE() WHERE name=? AND filename=?"
        : "INSERT INTO " + name
            + " (md5sum, error, name, filename, execution) VALUES (?, ?, ?, ?, GETDATE())";
  }

  /**
   * Builds SQL to acquire the lock in SQL Server.
   *
   * The lock flag is set to 1 and the grant timestamp is updated. This is called before executing
   * migrations.
   *
   * @param name table name
   * @return SQL statement to acquire the lock
   */
  @Override
  public String updateLock(String name) {
    return "UPDATE " + name + " SET locked = 1, granted = GETDATE() WHERE id = 1";
  }

}
