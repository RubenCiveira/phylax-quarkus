/* @autogenerated */
package net.civeira.phylax.common.infrastructure.migration;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Duration;
import java.time.Instant;

/**
 * Defines SQL statements and behaviors for migration bookkeeping tables.
 *
 * Dialects supply DDL and DML for creating and updating migration log/lock tables. Implementations
 * adapt to vendor differences in syntax and date handling. Default methods provide common SQL for
 * lock management and migration tracking. This interface is used by the migration manager during
 * startup.
 */
public interface SQLDialect {

  /**
   * Builds the SQL statement to create the migration log table.
   *
   * The log table tracks executed migrations and their checksums. Implementations may add
   * vendor-specific column types or constraints.
   *
   * @return SQL statement to create the log table
   */
  String createLogTable(String name);

  /**
   * Builds the SQL statement to create the migration lock table.
   *
   * The lock table coordinates concurrent migration execution. Implementations may add
   * vendor-specific column types or constraints.
   *
   * @return SQL statement to create the lock table
   */
  String createLockTable(String name);

  /**
   * Returns SQL to insert the initial lock row.
   *
   * This row is used to coordinate lock acquisition across instances. It is typically inserted once
   * during migration setup.
   *
   * @return SQL statement to insert the lock row
   */
  default String insertLock(String name) {
    return "INSERT INTO " + name + " (id, locked, granted) VALUES (1, 0, NULL)";
  }

  /**
   * Returns SQL to release the migration lock.
   *
   * This sets the lock row to unlocked and clears the granted timestamp. Use this after successful
   * or failed migration execution.
   *
   * @return SQL statement to release the lock
   */
  default String releaseLock(String name) {
    return "UPDATE " + name + " SET locked = 0, granted = NULL WHERE id = 1";
  }

  /**
   * Returns SQL to mark a migration as successful.
   *
   * The statement updates an existing log entry or inserts a new one. The exists flag indicates
   * whether the entry already exists.
   *
   * @param exists whether a log entry already exists
   * @return SQL statement to mark the migration as successful
   */
  default String markOkSql(String name, boolean exists) {
    return exists
        ? "UPDATE " + name
            + " SET md5sum=?, error=NULL, execution=NOW() WHERE name=? AND filename=?"
        : "INSERT INTO " + name
            + " (md5sum, name, filename, error, execution) VALUES (?, NULL, ?, ?, NOW())";
  }

  /**
   * Returns SQL to mark a migration as failed.
   *
   * The statement updates an existing log entry or inserts a new one. The exists flag indicates
   * whether the entry already exists.
   *
   * @param exists whether a log entry already exists
   * @return SQL statement to mark the migration as failed
   */
  default String markFailSql(String name, boolean exists) {
    return exists
        ? "UPDATE " + name + " SET md5sum=?, error=?, execution=NOW() WHERE name=? AND filename=?"
        : "INSERT INTO " + name
            + " (md5sum, error, name, filename, execution) VALUES (?, ?, ?, ?, NOW())";
  }

  /**
   * Returns SQL to list executed migrations for a given application name.
   *
   * The result set includes filename, checksum, and error information. The statement orders results
   * by execution time.
   *
   * @return SQL statement to list executed migrations
   */
  default String listExecutedSql(String name) {
    return "SELECT filename, md5sum, error FROM " + name + " WHERE name = ? ORDER BY execution ASC";
  }

  /**
   * Returns SQL to acquire the migration lock.
   *
   * This sets the lock row to locked and stores the granted timestamp. It is used before running
   * migration scripts.
   *
   * @return SQL statement to acquire the lock
   */
  default String updateLock(String name) {
    return "UPDATE " + name + " SET locked = 1, granted = NOW() WHERE id = 1";
  }

  /**
   * Returns SQL to read the current lock state.
   *
   * The query returns both the lock flag and the granted timestamp. It is used to decide whether a
   * new lock can be acquired.
   *
   * @return SQL statement to read the lock state
   */
  default String selectLock(String name) {
    return "SELECT locked, granted FROM " + name + " WHERE id = 1 ";
  }

  /**
   * Interprets the lock state using the current row of the result set.
   *
   * It verifies the lock flag and ensures the grant timestamp is still valid. The duration
   * parameter defines how long a lock remains valid.
   *
   * @param rs result set containing the lock columns
   * @param duration lock validity duration
   * @return true when the lock is active and not expired
   * @throws SQLException when reading the result set fails
   */
  default boolean interpretLocked(ResultSet rs, Duration duration) throws SQLException {
    return rs.getInt("locked") == 1 && stillGranted(rs, duration);
  }

  /**
   * Checks whether the granted timestamp is still within the validity window.
   *
   * This is used to prevent stale locks from blocking migrations indefinitely. When the timestamp
   * is null, the lock is treated as not granted.
   *
   * @param rs result set containing the granted timestamp
   * @param duration lock validity duration
   * @return true when the granted timestamp is still valid
   * @throws SQLException when reading the result set fails
   */
  default boolean stillGranted(ResultSet rs, Duration duration) throws SQLException {
    Timestamp ts = rs.getTimestamp("granted");
    if (null == ts) {
      return false;
    } else {
      Instant grantedAt = ts.toInstant();
      Instant expiresAt = grantedAt.plus(duration);
      return Instant.now().isBefore(expiresAt);
    }
  }

}

