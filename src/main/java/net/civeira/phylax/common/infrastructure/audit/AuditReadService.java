/* @autogenerated */
package net.civeira.phylax.common.infrastructure.audit;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.sql.DataSource;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.enterprise.context.ApplicationScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Reads audit events from the underlying audit store.
 *
 * The service translates filter criteria into SQL queries against the audit table. It supports
 * pagination and tenant scoping for multi-tenant environments. Results are returned as
 * {@link AuditEvent} records for downstream processing. This is typically used by management
 * endpoints and operational tooling.
 */
@Slf4j
@ApplicationScoped
@RequiredArgsConstructor
public class AuditReadService {

  private final DataSource dataSource;

  private final ObjectMapper mapper;

  /**
   * Queries audit events using the provided filters and pagination.
   *
   * The query is scoped to a tenant and can filter by actor, action, or date range. It applies a
   * limit and offset for paging through large audit logs. The audit table name can be derived from
   * the provided prefix.
   *
   * @param on audit table prefix or schema identifier
   * @param entity entity name used for logging or routing
   * @param filter filter constraints for the query
   * @param tenant tenant identifier to scope results
   * @param limit maximum number of results
   * @param offset number of results to skip
   * @return matching audit events
   */
  public List<AuditEvent> findByFilters(String on, String entity, AuditQueryFilter filter,
      String tenant, int limit, int offset) {
    try (Connection conn = dataSource.getConnection()) {
      StringBuilder sql = new StringBuilder("SELECT * FROM " + on + " WHERE 1=1 ");
      List<Object> params = new ArrayList<>();

      filter.appendToFilter(sql, params);
      if (tenant != null) {
        sql.append("AND tenant = ? ");
        params.add(tenant);
      }

      String driver = conn.getMetaData().getDriverName().toLowerCase();
      if (driver.contains("postgresql")) {
        sql.append("ORDER BY timestamp DESC LIMIT ? OFFSET ?");
      } else if (driver.contains("oracle")) {
        sql.append("ORDER BY timestamp DESC LIMIT ? OFFSET ?");
      } else if (driver.contains("mariadb")) {
        sql.append("ORDER BY timestamp DESC LIMIT ?, ?");
      } else if (driver.contains("mysql")) {
        sql.append("ORDER BY timestamp DESC LIMIT ?, ?");
      } else if (driver.contains("sqlserver")) {
        sql.append("ORDER BY timestamp DESC LIMIT ? OFFSET ?");
      } else {
        sql.append("ORDER BY timestamp DESC LIMIT ? OFFSET ?");
      }
      params.add(limit);
      params.add(offset);

      try (PreparedStatement ps = conn.prepareStatement(sql.toString())) {
        for (int i = 0; i < params.size(); i++) {
          ps.setObject(i + 1, params.get(i));
        }
        ResultSet rs = ps.executeQuery();
        List<AuditEvent> results = new ArrayList<>();
        while (rs.next()) {
          AuditEvent event = AuditEvent.builder().operation(rs.getString("operation"))
              .usecase(rs.getString("usecase")).traceId(rs.getString("trace_id"))
              .spanId(rs.getString("span_id")).entityType(rs.getString("entity_type"))
              .entityId(rs.getString("entity_id")).oldValue(readMap("old_values", rs))
              .newValue(readMap("new_values", rs)).performedBy(rs.getString("performed_by"))
              .tenant(rs.getString("tenant"))
              .timestamp(rs.getTimestamp("timestamp").toInstant().atZone(ZoneId.systemDefault()))
              .sourceRequest(rs.getString("source_request"))
              .remoteAddress(rs.getString("remote_address"))
              .remoteDevice(rs.getString("remote_device")).claims(readMap("claims", rs)).build();
          results.add(event);
        }
        return results;
      }
    } catch (SQLException e) {
      throw new RuntimeException("Error reading audit events", e);
    }
  }

  private Map<String, String> readMap(String name, ResultSet rs) {
    try {
      return mapper.readValue(rs.getString(name), new TypeReference<>() {});
    } catch (JsonProcessingException | SQLException e) {
      log.error("Unable to read " + name + " json from audit", e);
      return Map.of();
    }
  }
}
