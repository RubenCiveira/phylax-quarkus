/* @autogenerated */
package net.civeira.phylax.common.infrastructure.sql;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.SQLException;

/**
 * A {@code RuntimeException} that wraps {@link SQLException} and provides logic for interpreting
 * SQL errors into domain-specific exceptions.
 * <p>
 * This class identifies common database constraint violations such as duplicate keys, referential
 * integrity violations, and cascade delete issues, and rethrows them as more descriptive exceptions
 * like {@link NotUniqueException}, {@link NotExistentReferenceException}, and
 * {@link NotEmptyChildsException}.
 * </p>
 */
public class UncheckedSqlException extends RuntimeException {
  private static final long serialVersionUID = 4262062984330839677L;

  /** Constant for identifying MariaDB database. */
  private static final String MARIA_DB = "MariaDB";

  /** Constant for identifying MySQL database. */
  private static final String MY_SQL = "MySQL";

  /** Constant for identifying Microsoft SQL Server database. */
  private static final String MICROSOFT_SQL_SERVER = "Microsoft SQL Server";

  /** Constant for identifying Oracle database. */
  private static final String ORACLE = "Oracle";

  /** Constant for identifying H2 in-memory database. */
  private static final String H2 = "H2";

  /** Constant for identifying PostgreSQL database. */
  private static final String POSTGRE_SQL = "PostgreSQL";

  /**
   * Factory method that analyzes a {@link SQLException} and converts it into a domain-specific
   * unchecked exception depending on the database type and error details.
   *
   * @param connection the JDBC {@link Connection} used to determine the database type
   * @param sqlException the original {@link SQLException} thrown
   * @return a subclass of {@code UncheckedSqlException} that represents a more specific domain
   *         error
   */
  public static UncheckedSqlException exception(Connection connection, SQLException sqlException) {
    String databaseProductName = getDatabaseProductName(connection);
    int errorCode = sqlException.getErrorCode();
    String sqlState = sqlException.getSQLState();
    sqlException.printStackTrace();
    if (isDuplicateKeyError(databaseProductName, sqlState, errorCode)) {
      return new NotUniqueException("Duplicate key error: " + sqlException.getMessage(),
          sqlException);
    } else if (isReferentialIntegrityError(databaseProductName, sqlState, errorCode,
        sqlException)) {
      return new NotExistentReferenceException(
          "Referential integrity violation: " + sqlException.getMessage(), sqlException);
    } else if (isCascadeDeleteError(databaseProductName, sqlState, errorCode, sqlException)) {
      return new NotEmptyChildsException("Cascade delete violation: " + sqlException.getMessage(),
          sqlException);
    } else {
      return new UncheckedSqlException("SQL error: " + sqlException.getMessage(), sqlException);
    }
  }

  /**
   * Determines if the error represents a duplicate key violation for a specific database.
   *
   * @param databaseProductName the database product name
   * @param sqlState the SQL state code
   * @param errorCode the SQL error code
   * @return {@code true} if it is a duplicate key error; {@code false} otherwise
   */
  private static String getDatabaseProductName(Connection connection) {
    try {
      DatabaseMetaData metaData = connection.getMetaData();
      return metaData.getDatabaseProductName();
    } catch (SQLException e) {
      throw new UncheckedSqlException("Unable to retrieve database product name", e);
    }
  }

  /**
   * Checks if the SQL error corresponds to a duplicate key violation.
   */
  private static boolean isDuplicateKeyError(String databaseProductName, String sqlState,
      int errorCode) {
    switch (databaseProductName) {
      case POSTGRE_SQL, H2:
        return "23505".equals(sqlState); // Unique violation
      case ORACLE:
        return errorCode == 1; // Unique constraint violated
      case MICROSOFT_SQL_SERVER:
        return errorCode == 2627 || errorCode == 2601; // Unique constraint or duplicate key
      case MY_SQL, MARIA_DB:
        return errorCode == 1062; // Duplicate entry
      default:
        return false;
    }
  }

  /**
   * Determines if the error represents a referential integrity violation.
   *
   * @param databaseProductName the database product name
   * @param sqlState the SQL state code
   * @param errorCode the SQL error code
   * @param sqlException the original SQL exception
   * @return {@code true} if it is a referential integrity violation; {@code false} otherwise
   */
  private static boolean isReferentialIntegrityError(String databaseProductName, String sqlState,
      int errorCode, SQLException sqlException) {
    switch (databaseProductName) {
      case POSTGRE_SQL, H2:
        return "23506".equals(sqlState); // Referential integrity violation
      case ORACLE:
        return errorCode == 2291; // Parent key not found
      case MICROSOFT_SQL_SERVER:
        return errorCode == 547 && !sqlException.getMessage().contains("DELETE");
      case MY_SQL, MARIA_DB:
        return errorCode == 1452; // Cannot add or update child row
      default:
        return false;
    }
  }

  /**
   * Determines if the error represents a cascade delete violation or restriction.
   *
   * @param databaseProductName the database product name
   * @param sqlState the SQL state code
   * @param errorCode the SQL error code
   * @param sqlException the original SQL exception
   * @return {@code true} if it is a cascade delete violation; {@code false} otherwise
   */
  private static boolean isCascadeDeleteError(String databaseProductName, String sqlState,
      int errorCode, SQLException sqlException) {
    switch (databaseProductName) {
      case POSTGRE_SQL, H2:
        return "23504".equals(sqlState); // Restrict violation
      case ORACLE:
        return errorCode == 2292; // Child record found
      case MICROSOFT_SQL_SERVER:
        return errorCode == 547;
      case MY_SQL, MARIA_DB:
        return errorCode == 1451; // Cannot delete or update parent row
      default:
        return false;
    }
  }

  /**
   * Constructs a new {@code UncheckedSqlException} using the provided {@link SQLException} as the
   * cause.
   *
   * @param ex the underlying SQL exception
   */
  public UncheckedSqlException(SQLException ex) {
    super(ex);
  }

  /**
   * Constructs a new {@code UncheckedSqlException} with a detail message and the original
   * {@link SQLException}.
   *
   * @param msg the exception message
   * @param ex the underlying SQL exception
   */
  public UncheckedSqlException(String msg, SQLException ex) {
    super(msg, ex);
  }

}
