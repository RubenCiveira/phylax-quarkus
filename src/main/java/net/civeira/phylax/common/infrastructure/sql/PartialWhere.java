/* @autogenerated */
package net.civeira.phylax.common.infrastructure.sql;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Builder class for constructing conditional SQL WHERE clauses in a composable, hierarchical and
 * functional way.
 * <p>
 * This class supports logical combinations (AND, OR, NOT) of individual conditions or nested
 * {@code PartialWhere} blocks, and integrates with the {@link SchematicQuery} to support
 * parameterized SQL.
 * </p>
 */
public class PartialWhere {
  /**
   * Combines multiple {@code PartialWhere} instances using logical OR.
   *
   * @param partials one or more {@code PartialWhere} instances
   * @return a new {@code PartialWhere} representing the OR of the inputs
   */
  public static PartialWhere or(PartialWhere... partials) {
    PartialWhere partial = new PartialWhere("or", "");
    for (PartialWhere part : partials) {
      if (!part.isEmpty()) {
        partial.params.add(new Object[] {part});
      }
    }
    return partial;
  }

  /**
   * Combines multiple optional {@code PartialWhere} instances using logical OR, ignoring empty or
   * absent values.
   *
   * @param partials optional {@code PartialWhere} instances
   * @return a new {@code PartialWhere} representing the OR of the inputs
   */
  @SafeVarargs
  public static PartialWhere or(Optional<PartialWhere>... partials) {
    PartialWhere partial = new PartialWhere("or", "");
    for (Optional<PartialWhere> part : partials) {
      part.ifPresent(tpart -> {
        if (!tpart.isEmpty()) {
          partial.params.add(new Object[] {tpart});
        }
      });
    }
    return partial;
  }

  /**
   * Negates a given {@code PartialWhere} using a logical NOT.
   *
   * @param partial the {@code PartialWhere} to negate
   * @return a new {@code PartialWhere} with a NOT prefix
   */
  public static PartialWhere not(PartialWhere partial) {
    PartialWhere negated = new PartialWhere("and", "not");
    if (!partial.isEmpty()) {
      negated.params.add(new Object[] {partial});
    }
    return negated;
  }

  /**
   * Negates a given optional {@code PartialWhere}, if present and not empty.
   *
   * @param partial optional {@code PartialWhere} to negate
   * @return a new {@code PartialWhere} with a NOT prefix
   */
  public static PartialWhere not(Optional<PartialWhere> partial) {
    PartialWhere negated = new PartialWhere("and", "not");
    partial.ifPresent(tpartial -> {
      if (!tpartial.isEmpty()) {
        negated.params.add(new Object[] {tpartial});
      }
    });
    return negated;
  }

  /**
   * Combines multiple {@code PartialWhere} instances using logical AND.
   *
   * @param partials one or more {@code PartialWhere} instances
   * @return a new {@code PartialWhere} representing the AND of the inputs
   */
  public static PartialWhere and(PartialWhere... partials) {
    PartialWhere partial = new PartialWhere("and", "");
    for (PartialWhere part : partials) {
      if (!part.isEmpty()) {
        partial.params.add(new Object[] {part});
      }
    }
    return partial;
  }

  /**
   * Combines multiple optional {@code PartialWhere} instances using logical AND, ignoring empty or
   * absent values.
   *
   * @param partials optional {@code PartialWhere} instances
   * @return a new {@code PartialWhere} representing the AND of the inputs
   */
  @SafeVarargs
  public static PartialWhere and(Optional<PartialWhere>... partials) {
    PartialWhere partial = new PartialWhere("and", "");
    for (Optional<PartialWhere> part : partials) {
      part.ifPresent(tpart -> {
        if (!tpart.isEmpty()) {
          partial.params.add(new Object[] {tpart});
        }
      });
    }
    return partial;
  }

  /**
   * Creates a single condition with an ON-clause (typically used in JOINs).
   *
   * @param on the optional alias/table name
   * @param field the field name to compare
   * @param operator the SQL comparison operator
   * @param value the parameter value to bind
   * @return a {@code PartialWhere} containing this single condition
   */
  public static PartialWhere where(String on, String field, SqlOperator operator,
      SqlParameterValue value) {
    PartialWhere partial = new PartialWhere("and", "");
    partial.params.add(new Object[] {on, field, operator, value});
    return partial;
  }

  /**
   * Creates a single condition without an ON-clause.
   *
   * @param field the field name
   * @param operator the SQL comparison operator
   * @param value the parameter value
   * @return a {@code PartialWhere} containing this condition
   */
  public static PartialWhere where(String field, SqlOperator operator, SqlParameterValue value) {
    PartialWhere partial = new PartialWhere("and", "");
    partial.params.add(new Object[] {null, field, operator, value});
    return partial;
  }

  /**
   * Returns an empty {@code PartialWhere} that has no conditions.
   *
   * @return an empty {@code PartialWhere}
   */
  public static PartialWhere empty() {
    PartialWhere partial = new PartialWhere("", "");
    return partial;
  }

  /** Logical join type: "and" or "or". */
  private final String join;

  /** Logical prefix or modifier: "", "not", etc. */
  private final String converter;

  /** Internal list of condition groups or nested partials. */
  /* default */ List<Object[]> params = new ArrayList<>();

  /**
   * Constructs a new {@code PartialWhere} with join type and converter.
   *
   * @param join the join keyword ("and", "or")
   * @param converter a prefix modifier such as "not"
   */
  private PartialWhere(String join, String converter) {
    this.join = join;
    this.converter = converter;
  }

  /**
   * Checks whether this {@code PartialWhere} contains no conditions.
   *
   * @return {@code true} if empty; {@code false} otherwise
   */
  /* default */ boolean isEmpty() {
    return params.isEmpty();
  }

  /**
   * Builds the SQL WHERE clause recursively, registering parameters on the provided
   * {@link SchematicQuery}.
   *
   * @param prefix a prefix index used to generate unique parameter names
   * @param parametrized the parent {@link SchematicQuery} that collects parameters
   * @return a SQL WHERE string representation of this partial condition
   */
  /* default */ String append(int prefix, SchematicQuery parametrized) {
    List<String> wheres = new ArrayList<>();
    for (Object[] param : params) {
      if (param.length == 1) {
        PartialWhere p = (PartialWhere) param[0];
        if (!p.isEmpty()) {
          String where = p.append(++prefix, parametrized);
          prefix += where.length();
          wheres.add(where);
        }
      } else {
        String on = (String) param[0];
        String field = (String) param[1];
        SqlOperator operator = (SqlOperator) param[2];
        SqlParameterValue value = (SqlParameterValue) param[3];
        String name = "_field_" + (++prefix);
        parametrized.getParametrized().with(name, value);
        wheres.add((null == on ? "" : parametrized.escape(on) + ".") + parametrized.escape(field)
            + " " + operator.value + " :" + name);
      }
    }
    if (wheres.isEmpty()) {
      return "";
    } else if (wheres.size() == 1) {
      return (converter + " " + wheres.get(0)).trim();
    } else {
      return converter + "(" + String.join(" " + join + " ", wheres) + ")";
    }
  }
}
