/* @autogenerated */
package net.civeira.phylax.common.infrastructure.sql;

import lombok.extern.slf4j.Slf4j;

/**
 * Represents a typed SQL query that can be configured and executed.
 *
 * The query supports named parameter binding and optional row locking. It delegates execution to
 * the underlying {@link SqlTemplate} for consistency. Callers provide a {@link SqlConverter} to map
 * result rows into domain objects. Use {@link #forUpdate()} to request a locking read when
 * supported.
 *
 * @param <T> the type of the object to map the result to
 */
@Slf4j
public final class SqlQuery<T> extends AbstractSqlQuery<T, SqlQuery<T>> {

  /**
   * The SQL string to be executed.
   */
  private final String sql;

  /**
   * The SQL template engine used to build and execute the query.
   */
  private final SqlTemplate template;

  /**
   * Flag indicating whether the query should be executed with a row lock (FOR UPDATE).
   */
  private boolean lock = false;

  /**
   * Constructs a new SqlQuery.
   *
   * The SQL string is stored and executed later with parameter binding. Use
   * {@link SqlTemplate#createSqlQuery(String)} to create queries. The template manages connection
   * and optional tracing.
   *
   * @param template the SQL template engine used to prepare the final query
   * @param sql the SQL statement as a string
   */
  /* default */ SqlQuery(SqlTemplate template, String sql) {
    super(template);
    this.sql = sql;
    this.template = template;
  }

  /**
   * Enables row locking for this query (i.e., adds FOR UPDATE).
   *
   * This is used to lock selected rows for subsequent updates. Locking behavior depends on the
   * underlying database dialect. Returns the query instance for fluent chaining.
   *
   * @return the current SqlQuery instance with locking enabled
   */
  public SqlQuery<T> forUpdate() {
    lock = true;
    return this;
  }

  /**
   * Disables row locking for this query.
   *
   * This is the default behavior for read-only queries. Returns the query instance for fluent
   * chaining. Use this to override a previous {@link #forUpdate()} call.
   *
   * @return the current SqlQuery instance with locking disabled
   */
  public SqlQuery<T> forQuery() {
    lock = false;
    return this;
  }

  /**
   * Adds a named parameter to the query.
   *
   * The parameter name must match a placeholder in the SQL string. The value provider handles
   * binding to the prepared statement. Returns the query instance for fluent chaining.
   *
   * @param name the name of the parameter
   * @param consumer the value provider for the parameter
   * @return the current SqlQuery instance
   */
  @Override
  public SqlQuery<T> with(String name, SqlParameterValue consumer) {
    super.with(name, consumer);
    return this;
  }

  /**
   * Executes the SQL query using the given converter.
   *
   * The query is executed with locking when {@link #forUpdate()} was called. The converter maps
   * each row into the requested result type. Returns a {@link SqlResult} wrapper for lazy access to
   * results.
   *
   * @param converter the result converter
   * @return the result of the query execution
   */
  @Override
  public SqlResult<T> query(SqlConverter<T> converter) {
    log.info("QUER: " + sql);
    return executeQuery(lock ? template.sqlWithQueryLock(sql) : sql, converter);
  }
}
