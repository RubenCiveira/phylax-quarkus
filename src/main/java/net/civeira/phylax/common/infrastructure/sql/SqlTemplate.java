/* @autogenerated */
package net.civeira.phylax.common.infrastructure.sql;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.sql.DataSource;

import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.SpanKind;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Context;

/**
 * Provides SQL command/query creation and transaction management utilities.
 *
 * The template wraps a JDBC connection and exposes helpers to build queries and commands. It
 * optionally integrates with OpenTelemetry to create spans around SQL execution. The class also
 * provides vendor-specific locking hints for SQL Server. Use it as the entry point for repository
 * SQL operations.
 */
public class SqlTemplate implements AutoCloseable {
  /** The underlying SQL connection. */
  private final Connection connection;

  /** Optional OpenTelemetry tracer for SQL span tracking. */
  private final Tracer tracer;

  /**
   * Cached result of SQL Server driver detection. {@code null} means not yet computed; it is
   * resolved once on first use and reused for all subsequent lock operations on this connection.
   * Driver metadata never changes for the lifetime of a connection.
   */
  private Boolean sqlserver;

  /**
   * Constructs a template using a direct {@link Connection}.
   *
   * The connection is used for all operations created by this template. Callers are responsible for
   * lifecycle management unless using {@link #close()}. Passing a null connection results in an
   * {@link IllegalArgumentException}.
   *
   * @param connection the active JDBC connection
   * @throws IllegalArgumentException if the connection is {@code null}
   */
  public SqlTemplate(Connection connection) {
    if (connection == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    this.connection = connection;
    this.tracer = null;
  }

  /**
   * Constructs a template using a {@link DataSource}, acquiring a new connection.
   *
   * The connection is obtained immediately and stored for future operations. This is convenient
   * when a template must manage its own connection. Errors are wrapped in
   * {@link UncheckedSqlException} for uniform handling.
   *
   * @param source the data source to acquire a connection from
   * @throws IllegalArgumentException if the source is {@code null}
   * @throws UncheckedSqlException if obtaining the connection fails
   */
  public SqlTemplate(DataSource source) {
    if (source == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    try {
      this.connection = source.getConnection();
      this.tracer = null;
    } catch (SQLException ex) {
      throw new UncheckedSqlException(ex);
    }
  }

  /**
   * Constructs a template with OpenTelemetry tracing support.
   *
   * The tracer is used to create spans around query execution. When no valid parent span is
   * present, spans are not created. This keeps tracing overhead minimal for background operations.
   *
   * @param connection the JDBC connection
   * @param tracer the tracer for telemetry
   * @throws IllegalArgumentException if the connection is {@code null}
   */
  public SqlTemplate(Connection connection, Tracer tracer) {
    if (connection == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    this.connection = connection;
    this.tracer = tracer;
  }

  /**
   * Constructs a template using a {@link DataSource} and OpenTelemetry tracing.
   *
   * The connection is obtained immediately and tracing is enabled if a tracer is provided. Errors
   * while obtaining the connection are wrapped in {@link UncheckedSqlException}. Use this when you
   * want SQL operations to emit telemetry spans.
   *
   * @param source the data source
   * @param tracer the tracer for telemetry
   * @throws IllegalArgumentException if the source is {@code null}
   * @throws UncheckedSqlException if obtaining the connection fails
   */
  public SqlTemplate(DataSource source, Tracer tracer) {
    if (source == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    try {
      this.connection = source.getConnection();
      this.tracer = tracer;
    } catch (SQLException ex) {
      throw new UncheckedSqlException(ex);
    }
  }

  /**
   * Begins a transaction by setting auto-commit to {@code false}.
   *
   * This is a no-op if auto-commit is already disabled. Use {@link #commit()} or
   * {@link #rollback()} to end the transaction. Exceptions are wrapped into
   * {@link UncheckedSqlException}.
   */
  public void begin() {
    try {
      if (connection.getAutoCommit()) {
        connection.setAutoCommit(false);
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /**
   * Commits the current transaction and re-enables auto-commit.
   *
   * This is a no-op if auto-commit is already enabled. After commit, auto-commit is restored to
   * avoid leaking state. Exceptions are wrapped into {@link UncheckedSqlException}.
   */
  public void commit() {
    try {
      if (!connection.getAutoCommit()) {
        connection.commit();
        connection.setAutoCommit(true); // Vuelve a habilitar auto-commit
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /**
   * Rolls back the current transaction and re-enables auto-commit.
   *
   * This is a no-op if auto-commit is already enabled. After rollback, auto-commit is restored to
   * avoid leaking state. Exceptions are wrapped into {@link UncheckedSqlException}.
   */
  public void rollback() {
    try {
      if (!connection.getAutoCommit()) {
        connection.rollback();
        connection.setAutoCommit(true); // Vuelve a habilitar auto-commit
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /**
   * Closes the underlying JDBC connection if not already closed.
   *
   * Use this when the template owns the connection lifecycle. For pooled data sources, ensure
   * closing returns the connection to the pool. Exceptions are wrapped into
   * {@link UncheckedSqlException}.
   */
  public void close() {
    try {
      if (!connection.isClosed()) {
        connection.close();
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /**
   * Adds SQL Server table lock hint to a SELECT clause.
   *
   * When the underlying driver is SQL Server, table hints are appended. For other databases, the
   * SQL is returned unchanged. This is used to emulate row-level locking semantics.
   *
   * @param select the select query
   * @return the query with locking clause if on SQL Server
   */
  /* default */ String withTableLock(String select) {
    return isSqlserver() ? select + " WITH (UPDLOCK, ROWLOCK) " : select;
  }

  /**
   * Adds query-level lock hint to a SQL query.
   *
   * For SQL Server, this returns the SQL unchanged and uses table hints elsewhere. For other
   * databases, it appends FOR UPDATE to the query. This is used to lock selected rows for update
   * operations.
   *
   * @param sql the SQL query
   * @return the query with locking syntax depending on the database
   */
  /* default */ String withQueryLock(String sql) {
    return isSqlserver() ? sql : sql + " FOR UPDATE";
  }

  /**
   * Applies SQL Server-specific locking clause within the FROM section.
   *
   * For SQL Server, it injects WITH (UPDLOCK, ROWLOCK) into the FROM table. For other databases, it
   * appends FOR UPDATE. This is used when SELECT ... FOR UPDATE is not supported.
   *
   * @param sql the SQL query
   * @return the modified SQL with row locking hints
   */
  /* default */ String sqlWithQueryLock(String sql) {
    if (isSqlserver()) {
      String regex =
          "(?i)(FROM\\s+)(\\[?[a-zA-Z0-9_\\s]+\\]?)(\\s+(?:AS\\s+)?[a-zA-Z0-9_]+)?(\\s+|$)";
      Pattern pattern = Pattern.compile(regex);
      Matcher matcher = pattern.matcher(sql);

      // Reemplazo con la tabla + WITH (UPDLOCK, ROWLOCK)
      return matcher.replaceFirst("$1$2 WITH (UPDLOCK, ROWLOCK)$3$4");
    } else {
      return sql + " FOR UPDATE";
    }
  }

  /**
   * Returns the underlying JDBC connection.
   *
   * Use this when you need to access connection metadata or configure settings. Callers should
   * avoid closing the connection if it is managed elsewhere. This method is package-private to
   * limit external use.
   *
   * @return the JDBC connection
   */
  /* default */ Connection currentConnection() {
    return connection;
  }

  /**
   * Creates a span for tracing if tracing is enabled and a parent span exists.
   *
   * Spans are only created when the tracer is present and the parent is valid. This avoids creating
   * root spans for background tasks. The caller is responsible for ending the span.
   *
   * @param title the span name
   * @return an {@link Optional} span
   */
  /* default */ Optional<Span> createSpan(String title) {
    if (null != tracer) {
      Span parentSpan = Span.current();
      if (parentSpan.getSpanContext().isValid()) {
        return Optional.of(tracer.spanBuilder(title).setParent(Context.current().with(parentSpan))
            .setSpanKind(SpanKind.INTERNAL).startSpan());
      }
    }
    return Optional.empty();
  }

  /**
   * Creates a span using a provided parent span.
   *
   * The span is created only when a valid parent is provided and tracing is enabled. This allows
   * nested spans during complex query execution flows. The caller is responsible for ending the
   * span.
   *
   * @param title the span name
   * @param parent the optional parent span
   * @return an {@link Optional} span
   */
  /* default */ Optional<Span> createSpan(String title, Optional<Span> parent) {
    if (null != tracer && parent.isPresent()) {
      Span parentSpan = parent.get();
      if (parentSpan.getSpanContext().isValid()) {
        return Optional.of(tracer.spanBuilder(title).setParent(Context.current().with(parentSpan))
            .setSpanKind(SpanKind.INTERNAL).startSpan());
      }
    }
    return Optional.empty();
  }

  /**
   * Creates a {@link SqlSchematicQuery} from the given table name.
   *
   * Schematic queries are used to build structured SQL with dynamic filters. The table name is used
   * as the base for generated SQL. The returned query can be further configured with parameters and
   * limits.
   *
   * @param table the table name
   * @return a new {@code SqlSchematicQuery}
   */
  public <T> SqlSchematicQuery<T> createSqlSchematicQuery(String table) {
    return new SqlSchematicQuery<>(this, table);
  }

  /**
   * Creates a {@link SqlQuery} from the given SQL string.
   *
   * Use this for arbitrary SELECT statements with parameter binding. The returned query can be
   * executed with a row converter. This is the primary entry point for custom queries.
   *
   * @param sql the SQL query
   * @return a new {@code SqlQuery}
   */
  public <T> SqlQuery<T> createSqlQuery(String sql) {
    return new SqlQuery<>(this, sql);
  }

  /**
   * Creates a {@link SqlCommand} from the given SQL string.
   *
   * Use this for INSERT, UPDATE, or DELETE statements. The returned command can be executed with
   * parameter binding. This is the primary entry point for write operations.
   *
   * @param sql the SQL statement
   * @return a new {@code SqlCommand}
   */
  public SqlCommand createSqlCommand(String sql) {
    return new SqlCommand(this, sql);
  }

  /**
   * Checks if the underlying database is Microsoft SQL Server.
   *
   * The result is computed on first call and cached for the lifetime of this template instance.
   * Driver metadata does not change within a connection, so querying it repeatedly is unnecessary.
   *
   * @return {@code true} if SQL Server is detected; {@code false} otherwise
   */
  private boolean isSqlserver() {
    if (sqlserver == null) {
      try {
        String driver = connection.getMetaData().getDriverName().toLowerCase();
        sqlserver = driver.contains("sqlserver");
      } catch (SQLException ex) {
        throw UncheckedSqlException.exception(connection, ex);
      }
    }
    return sqlserver;
  }
}
