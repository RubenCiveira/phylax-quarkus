/* @autogenerated */
package net.civeira.phylax.common.infrastructure.sql;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.sql.DataSource;

import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.SpanKind;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Context;

/**
 * Provides SQL command/query creation and transaction management utilities with optional
 * OpenTelemetry tracing integration.
 */
public class SqlTemplate implements AutoCloseable {
  /** The underlying SQL connection. */
  private final Connection connection;

  /** Optional OpenTelemetry tracer for SQL span tracking. */
  private final Tracer tracer;

  /**
   * Constructs a template using a direct {@link Connection}.
   *
   * @param connection the active JDBC connection
   * @throws IllegalArgumentException if the connection is {@code null}
   */
  public SqlTemplate(Connection connection) {
    if (connection == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    this.connection = connection;
    this.tracer = null;
  }

  /**
   * Constructs a template using a {@link DataSource}, acquiring a new connection.
   *
   * @param source the data source to acquire a connection from
   * @throws IllegalArgumentException if the source is {@code null}
   * @throws UncheckedSqlException if obtaining the connection fails
   */
  public SqlTemplate(DataSource source) {
    if (source == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    try {
      this.connection = source.getConnection();
      this.tracer = null;
    } catch (SQLException ex) {
      throw new UncheckedSqlException(ex);
    }
  }

  /**
   * Constructs a template with OpenTelemetry tracing support.
   *
   * @param connection the JDBC connection
   * @param tracer the tracer for telemetry
   * @throws IllegalArgumentException if the connection is {@code null}
   */
  public SqlTemplate(Connection connection, Tracer tracer) {
    if (connection == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    this.connection = connection;
    this.tracer = tracer;
  }

  /**
   * Constructs a template using a {@link DataSource} and OpenTelemetry tracing.
   *
   * @param source the data source
   * @param tracer the tracer for telemetry
   * @throws IllegalArgumentException if the source is {@code null}
   * @throws UncheckedSqlException if obtaining the connection fails
   */
  public SqlTemplate(DataSource source, Tracer tracer) {
    if (source == null) {
      throw new IllegalArgumentException("Connection cannot be null");
    }
    try {
      this.connection = source.getConnection();
      this.tracer = tracer;
    } catch (SQLException ex) {
      throw new UncheckedSqlException(ex);
    }
  }

  /**
   * Begins a transaction by setting auto-commit to {@code false}.
   */
  public void begin() {
    try {
      if (connection.getAutoCommit()) {
        connection.setAutoCommit(false);
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /**
   * Commits the current transaction and re-enables auto-commit.
   */
  public void commit() {
    try {
      if (!connection.getAutoCommit()) {
        connection.commit();
        connection.setAutoCommit(true); // Vuelve a habilitar auto-commit
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /**
   * Rolls back the current transaction and re-enables auto-commit.
   */
  public void rollback() {
    try {
      if (!connection.getAutoCommit()) {
        connection.rollback();
        connection.setAutoCommit(true); // Vuelve a habilitar auto-commit
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /**
   * Closes the underlying JDBC connection if not already closed.
   */
  public void close() {
    try {
      if (!connection.isClosed()) {
        connection.close();
      }
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }

  /**
   * Adds SQL Server table lock hint to a SELECT clause.
   *
   * @param select the select query
   * @return the query with locking clause if on SQL Server
   */
  /* default */ String withTableLock(String select) {
    return isSqlserver() ? select + " WITH (UPDLOCK, ROWLOCK) " : select;
  }

  /**
   * Adds query-level lock hint to a SQL query.
   *
   * @param sql the SQL query
   * @return the query with locking syntax depending on the database
   */
  /* default */ String withQueryLock(String sql) {
    return isSqlserver() ? sql : sql + " FOR UPDATE";
  }

  /**
   * Applies SQL Server-specific locking clause within the FROM section for SqlServer.
   *
   * @param sql the SQL query
   * @return the modified SQL with SQL Server row locking hints
   */
  /* default */ String sqlWithQueryLock(String sql) {
    if (isSqlserver()) {
      String regex =
          "(?i)(FROM\\s+)(\\[?[a-zA-Z0-9_\\s]+\\]?)(\\s+(?:AS\\s+)?[a-zA-Z0-9_]+)?(\\s+|$)";
      Pattern pattern = Pattern.compile(regex);
      Matcher matcher = pattern.matcher(sql);

      // Reemplazo con la tabla + WITH (UPDLOCK, ROWLOCK)
      return matcher.replaceFirst("$1$2 WITH (UPDLOCK, ROWLOCK)$3$4");
    } else {
      return sql + " FOR UPDATE";
    }
  }

  /**
   * Returns the underlying JDBC connection.
   *
   * @return the JDBC connection
   */
  /* default */ Connection currentConnection() {
    return connection;
  }

  /**
   * Creates a span for tracing if tracing is enabled and there's a valid parent span.
   *
   * @param title the span name
   * @return an {@link Optional} span
   */
  /* default */ Optional<Span> createSpan(String title) {
    if (null != tracer) {
      Span parentSpan = Span.current();
      if (parentSpan.getSpanContext().isValid()) {
        return Optional.of(tracer.spanBuilder(title).setParent(Context.current().with(parentSpan))
            .setSpanKind(SpanKind.INTERNAL).startSpan());
      }
    }
    return Optional.empty();
  }

  /**
   * Creates a span using a provided parent span.
   *
   * @param title the span name
   * @param parent the optional parent span
   * @return an {@link Optional} span
   */
  /* default */ Optional<Span> createSpan(String title, Optional<Span> parent) {
    if (null != tracer && parent.isPresent()) {
      Span parentSpan = parent.get();
      if (parentSpan.getSpanContext().isValid()) {
        return Optional.of(tracer.spanBuilder(title).setParent(Context.current().with(parentSpan))
            .setSpanKind(SpanKind.INTERNAL).startSpan());
      }
    }
    return Optional.empty();
  }

  /**
   * Creates a {@link SqlSchematicQuery} from the given table name.
   *
   * @param table the table name
   * @return a new {@code SqlSchematicQuery}
   */
  public <T> SqlSchematicQuery<T> createSqlSchematicQuery(String table) {
    return new SqlSchematicQuery<>(this, table);
  }

  /**
   * Creates a {@link SqlQuery} from the given SQL string.
   *
   * @param sql the SQL query
   * @return a new {@code SqlQuery}
   */
  public <T> SqlQuery<T> createSqlQuery(String sql) {
    return new SqlQuery<>(this, sql);
  }

  /**
   * Creates a {@link SqlQuery} from the given SQL string.
   *
   * @param sql the SQL query
   * @return a new {@code SqlQuery}
   */
  public SqlCommand createSqlCommand(String sql) {
    return new SqlCommand(this, sql);
  }

  /**
   * Checks if the underlying database is Microsoft SQL Server.
   *
   * @return {@code true} if SQL Server is detected; {@code false} otherwise
   */
  private boolean isSqlserver() {
    try {
      String driver = connection.getMetaData().getDriverName().toLowerCase();
      return driver.contains("sqlserver");
    } catch (SQLException ex) {
      throw UncheckedSqlException.exception(connection, ex);
    }
  }
}
