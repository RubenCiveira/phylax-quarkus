/* @autogenerated */
package net.civeira.phylax.common.infrastructure;

import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Locale.LanguageRange;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.eclipse.microprofile.jwt.JsonWebToken;

import io.quarkus.security.identity.SecurityIdentity;
import jakarta.enterprise.context.RequestScoped;
import jakarta.ws.rs.core.HttpHeaders;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.ResponseBuilder;
import jakarta.ws.rs.core.UriInfo;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.common.algorithms.metadata.Timestamped;
import net.civeira.phylax.common.security.Actor;
import net.civeira.phylax.common.security.Connection;
import net.civeira.phylax.common.security.Interaction;

@RequestScoped
@RequiredArgsConstructor
public class CurrentRequest {
  private final SecurityIdentity security;
  private final JsonWebToken jwt;
  private final UriInfo uriInfo;
  private final HttpHeaders headers;
  private final @ConfigProperty(name = "mp.jwt.audiences") String audiences;

  public String getPublicHost() {
    /*
     * Forwarded X-Forwarded-Proto X-Forwarded-Host X-Forwarded-Port X-Forwarded-Ssl
     * X-Forwarded-Prefix
     */
    String scheme = headers.getHeaderString("X-Forwarded-Proto");
    String host = headers.getHeaderString("X-Forwarded-Host");
    String port = headers.getHeaderString("X-Forwarded-Port");
    String prefix = headers.getHeaderString("X-Forwarded-Prefix");

    // Fallbacks si los headers no est√°n presentes
    if (scheme == null)
      scheme = uriInfo.getRequestUri().getScheme();
    if (host == null)
      host = uriInfo.getRequestUri().getHost();
    if (port == null) {
      // Si no hay header, usa el puerto del request URI solo si no es el default
      int uriPort = uriInfo.getRequestUri().getPort();
      port = (uriPort == -1 || uriPort == 80 || uriPort == 443) ? "" : ":" + uriPort;
    } else {
      port = ":" + port;
    }
    if (prefix == null)
      prefix = "";
    return scheme + "://" + host + port + prefix;
  }

  public boolean isAnonymous() {
    return security.isAnonymous();
  }

  private Optional<String> getFirstHeader(String name) {
    return Optional.ofNullable(headers.getHeaderString(name));
  }

  public Response cacheableResponse(Object stampData, String eTag) {
    return cacheableResponse(stampData, stampData, eTag);
  }

  public Response cacheableResponse(Object stamp, Object data, String eTag) {
    return (((stamp instanceof Timestamped)
        ? ((Timestamped) stamp).getGeneratedAt().map(instant -> {
          boolean needUpdate = getFirstHeader("if-modified-since")
              .map(since -> instant.getEpochSecond() > ZonedDateTime
                  .parse(since, DateTimeFormatter.RFC_1123_DATE_TIME).toInstant().getEpochSecond())
              .orElse(true);
          return (needUpdate
              ? Response.ok(data).header("Etag", eTag).header("Last-Modified",
                  instant.atOffset(ZoneOffset.UTC).format(DateTimeFormatter.RFC_1123_DATE_TIME))
              : Response.notModified(String.valueOf(instant.hashCode())));
        })
        : Optional.<ResponseBuilder>empty()).orElseGet(() -> Response.ok(data))).build();
  }

  public Interaction interaction() {
    Actor actor = getActor();
    Connection conn = getConnection();
    return new Interaction(Interaction.builder().actor(actor).connection(conn)) {};
  }

  public Actor getActor() {
    Actor.ActorBuilder builder = Actor.builder();
    if (security.isAnonymous()) {
      builder = builder.autenticated(false).roles(List.of());
    } else {
      // System.err.println("Principal: " + security.getPrincipal().getName());
      // System.err.println("Roles: " + security.getRoles());
      // System.err.println("Filtrados desde " + audiences);
      // System.err
      // .println("Quedan como " +
      // security.getRoles().stream().map(this::removePrefix).filter(Objects::nonNull).toList() );

      builder = builder.name(security.getPrincipal().getName()).roles(
          security.getRoles().stream().map(this::removePrefix).filter(Objects::nonNull).toList());
      Object claim = jwt.getClaim("tid");
      if (null != claim) {
        builder = builder.tenant(String.valueOf(claim));
      } else {
        builder = builder.tenant(jwt.getIssuer());
      }
      Map<String, String> claims = new HashMap<>();
      for (String string : jwt.getClaimNames()) {
        claims.put(string, jwt.getClaim(string).toString());
      }
      builder = builder.claims(claims);
    }
    return builder.build();
  }

  public Connection getConnection() {
    String device = headers.getHeaderString("X-Device-ID");
    return Connection.builder().remoteDevice(device).locale(getRequestHeaderLocale())
        .request(uriInfo.getPath()).build();
  }

  private String removePrefix(String role) {
    if (!role.contains(".")) {
      return role;
    }
    return Arrays.asList(audiences.split("\\,")).stream()
        .filter(pref -> role.startsWith(pref + ".")).findFirst()
        .map(pref -> role.substring(pref.length() + 1)).orElse(null);
  }

  private Locale getRequestHeaderLocale() {
    Locale locale = Locale.getDefault();
    String localeHeader = headers.getHeaderString("Accept-Language");
    if (null != localeHeader) {
      List<LanguageRange> parse = Locale.LanguageRange.parse(localeHeader);
      if (!parse.isEmpty()) {
        Locale lookup = Locale.lookup(parse, Arrays.asList(Locale.getAvailableLocales()));
        locale = null == lookup ? locale : lookup;
      }
    }
    return locale;
  }
}
