/* @autogenerated */
package net.civeira.phylax.common.infrastructure;

import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Locale.LanguageRange;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.eclipse.microprofile.jwt.JsonWebToken;

import io.quarkus.security.identity.SecurityIdentity;
import jakarta.enterprise.context.RequestScoped;
import jakarta.ws.rs.core.HttpHeaders;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.ResponseBuilder;
import jakarta.ws.rs.core.UriInfo;
import lombok.RequiredArgsConstructor;
import net.civeira.phylax.common.algorithms.metadata.Timestamped;
import net.civeira.phylax.common.security.Actor;
import net.civeira.phylax.common.security.Connection;
import net.civeira.phylax.common.security.Interaction;

/**
 * Provides helpers to derive actor, connection, and cache metadata from the current request.
 *
 * It builds {@link Actor} and {@link Connection} objects from security identity and headers. The
 * class also offers cache-aware response building using timestamped payloads. It is request-scoped
 * and relies on HTTP headers and JWT claims for context. Use it in controllers and gateways that
 * need consistent request metadata.
 */
@RequestScoped
@RequiredArgsConstructor
public class CurrentRequest {
  private final SecurityIdentity security;
  private final JsonWebToken jwt;
  private final UriInfo uriInfo;
  private final HttpHeaders headers;
  private final @ConfigProperty(name = "mp.jwt.audiences") String audiences;

  /**
   * Builds the public host URL using forwarded headers when available.
   *
   * This inspects proxy headers to reconstruct the external URL seen by clients. When headers are
   * absent, it falls back to request URI details. The result includes scheme, host, port, and any
   * forwarded prefix.
   *
   * @return public scheme, host, port, and prefix URL
   */
  public String getPublicHost() {
    /*
     * Forwarded X-Forwarded-Proto X-Forwarded-Host X-Forwarded-Port X-Forwarded-Ssl
     * X-Forwarded-Prefix
     */
    String scheme = headers.getHeaderString("X-Forwarded-Proto");
    String host = headers.getHeaderString("X-Forwarded-Host");
    String port = headers.getHeaderString("X-Forwarded-Port");
    String prefix = headers.getHeaderString("X-Forwarded-Prefix");

    // Fallbacks si los headers no est√°n presentes
    if (scheme == null)
      scheme = uriInfo.getRequestUri().getScheme();
    if (host == null)
      host = uriInfo.getRequestUri().getHost();
    if (port == null) {
      // Si no hay header, usa el puerto del request URI solo si no es el default
      int uriPort = uriInfo.getRequestUri().getPort();
      port = (uriPort == -1 || uriPort == 80 || uriPort == 443) ? "" : ":" + uriPort;
    } else {
      port = ":" + port;
    }
    if (prefix == null)
      prefix = "";
    return scheme + "://" + host + port + prefix;
  }

  /**
   * Checks whether the current security identity is anonymous.
   *
   * This uses the Quarkus security identity and guards against runtime failures. A failure to
   * resolve identity is treated as anonymous for safety. Use this to decide access behavior in
   * request-scoped components.
   *
   * @return true when the identity is anonymous
   */
  public boolean isAnonymous() {
    try {
      return security.isAnonymous();
    } catch (RuntimeException re) {
      return true;
    }
  }

  private Optional<String> getFirstHeader(String name) {
    return Optional.ofNullable(headers.getHeaderString(name));
  }

  /**
   * Builds a cache-aware response using the given stamp object and ETag.
   *
   * When the stamp implements {@link Timestamped}, it uses Last-Modified logic. If the request is
   * not modified, it returns a 304 response. Otherwise it returns a 200 response with ETag and
   * Last-Modified headers.
   *
   * @param stampData timestamped data used to compute cache headers
   * @param eTag response entity tag
   * @return a cacheable response
   */
  public Response cacheableResponse(Object stampData, String eTag) {
    return cacheableResponse(stampData, stampData, eTag);
  }

  /**
   * Builds a cache-aware response using a stamp and response payload.
   *
   * This computes Last-Modified from the stamp and compares If-Modified-Since. When unchanged, it
   * returns a not-modified response without a body. Otherwise it returns the payload with cache
   * headers applied.
   *
   * @param stamp timestamped object used to compute cache headers
   * @param data response payload
   * @param eTag response entity tag
   * @return a cacheable response
   */
  public Response cacheableResponse(Object stamp, Object data, String eTag) {
    return (((stamp instanceof Timestamped)
        ? ((Timestamped) stamp).getGeneratedAt().map(instant -> {
          boolean needUpdate = getFirstHeader("if-modified-since")
              .map(since -> instant.getEpochSecond() > ZonedDateTime
                  .parse(since, DateTimeFormatter.RFC_1123_DATE_TIME).toInstant().getEpochSecond())
              .orElse(true);
          return (needUpdate
              ? Response.ok(data).header("Etag", eTag).header("Last-Modified",
                  instant.atOffset(ZoneOffset.UTC).format(DateTimeFormatter.RFC_1123_DATE_TIME))
              : Response.notModified(String.valueOf(instant.hashCode())));
        })
        : Optional.<ResponseBuilder>empty()).orElseGet(() -> Response.ok(data))).build();
  }

  /**
   * Creates an interaction object using the current actor and connection.
   *
   * This is a convenience method for passing request metadata into use cases. The interaction
   * captures both user identity and request origin details. Use it when invoking application
   * services from controllers.
   *
   * @return interaction descriptor
   */
  public Interaction interaction() {
    Actor actor = getActor();
    Connection conn = getConnection();
    return new Interaction(Interaction.builder().actor(actor).connection(conn)) {};
  }

  /**
   * Builds the actor for the current request using the security identity and JWT.
   *
   * It extracts roles, tenant information, and selected claims from the token. Anonymous identities
   * are represented with empty role lists. The resulting actor is used in interaction and auditing
   * flows.
   *
   * @return resolved actor
   */
  public Actor getActor() {
    Actor.ActorBuilder builder = Actor.builder();
    if (security.isAnonymous()) {
      builder = builder.autenticated(false).roles(List.of());
    } else {
      builder = builder.name(security.getPrincipal().getName()).roles(
          security.getRoles().stream().map(this::removePrefix).filter(Objects::nonNull).toList());
      Object claim = jwt.getClaim("tid");
      if (null != claim) {
        builder = builder.tenant(String.valueOf(claim));
      } else {
        builder = builder.tenant(jwt.getIssuer());
      }
      Map<String, String> claims = new HashMap<>();
      for (String string : jwt.getClaimNames()) {
        Object claimWithName = jwt.getClaim(string);
        if (claimWithName != null) {
          claims.put(string, claim.toString());
        }
      }
      builder = builder.claims(claims);
    }
    return builder.build();
  }

  /**
   * Builds the connection metadata for the current request.
   *
   * It captures locale, device id, and request path details. This metadata is used for auditing and
   * request tracing. The locale is derived from the Accept-Language header.
   *
   * @return connection descriptor
   */
  public Connection getConnection() {
    String device = headers.getHeaderString("X-Device-ID");
    return Connection.builder().remoteDevice(device).locale(getRequestHeaderLocale())
        .request(uriInfo.getPath()).build();
  }

  private String removePrefix(String role) {
    if (!role.contains(".")) {
      return role;
    }
    return Arrays.asList(audiences.split("\\,")).stream()
        .filter(pref -> role.startsWith(pref + ".")).findFirst()
        .map(pref -> role.substring(pref.length() + 1)).orElse(null);
  }

  private Locale getRequestHeaderLocale() {
    Locale locale = Locale.getDefault();
    String localeHeader = headers.getHeaderString("Accept-Language");
    if (null != localeHeader) {
      List<LanguageRange> parse = Locale.LanguageRange.parse(localeHeader);
      if (!parse.isEmpty()) {
        Locale lookup = Locale.lookup(parse, Arrays.asList(Locale.getAvailableLocales()));
        locale = null == lookup ? locale : lookup;
      }
    }
    return locale;
  }
}
