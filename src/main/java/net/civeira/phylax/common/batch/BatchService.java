/* @autogenerated */
package net.civeira.phylax.common.batch;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.UUID;

import org.eclipse.microprofile.context.ManagedExecutor;

import jakarta.enterprise.context.RequestScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.batch.BatchProgress.GlobalStatus;
import net.civeira.phylax.common.batch.BatchStepProgress.Status;
import net.civeira.phylax.common.batch.storage.MasiveOperationStorage;

/**
 * Manages asynchronous execution and tracking of multi-step batch jobs.
 *
 * The service initializes batch steps, persists progress, and runs them in a background executor.
 * Each step is executed via an {@link ExecutorPlan} and persisted through
 * {@link MasiveOperationStorage}. Progress is saved between steps so clients can monitor
 * long-running work. When the job finishes, it is marked for expiration based on the preservation
 * duration.
 */
@Slf4j
@RequestScoped
@RequiredArgsConstructor
public class BatchService {
  /** The storage backend used to persist and restore batch progress. */
  private final MasiveOperationStorage storage;
  /** Managed executor service used to run batch jobs asynchronously. */
  private final ManagedExecutor executor;
  /** Put the thread on suspend to avoid resources overload */
  private final SleepService sleeper = new RealSleepService();

  /**
   * Starts the asynchronous execution of a batch job composed of multiple steps.
   *
   * This initializes step progress, stores the initial state, and launches a background task. Steps
   * run sequentially using their {@link Executor} implementations with progress persisted.
   * Exceptions are recorded per step without stopping the overall job execution. The job is
   * finalized and scheduled for expiration after the preservation window.
   *
   * @param actor the identifier of the user or system initiating the batch job
   * @param preservation how long the batch result should be preserved after completion
   * @param plans ordered set of execution plans that compose the batch
   * @return a {@link BatchIdentificator} containing the batch UID and step names
   */
  @SuppressWarnings({"rawtypes", "unchecked"})
  public BatchIdentificator start(String actor, Duration preservation, ExecutorPlan<?>... plans) {
    String taskUid = UUID.randomUUID().toString();
    List<BatchStepProgress> map = new ArrayList<>();
    for (int i = 0; i < plans.length; i++) {
      ExecutorPlan<?> plan = plans[i];
      BatchStepProgress step = new BatchStepProgress();
      step.setName(plan.getName());
      step.setStatus(Status.PENDING);
      map.add(step);
    }
    BatchProgress progress = BatchProgress.builder().uid(taskUid).steps(map)
        .startTime(Instant.now()).status(GlobalStatus.PENDING).build();

    storage.save(taskUid, actor, progress);
    executor.runAsync(() -> {
      // We must delay until the http request finish to ensure a new Request Context is build
      sleep("Initial delay to close request context", 5000);
      try {
        for (int i = 0; i < plans.length; i++) {
          ExecutorPlan<?> plan = plans[i];
          Executor task = plan.getExecutor();
          BatchStepProgress massiveOperationResult = map.get(i);
          try {
            massiveOperationResult.setStatus(Status.PROCESSING);
            storage.save(taskUid, actor, progress);
            task.run(massiveOperationResult, t -> {
              storage.save(taskUid, actor, progress);
            }, plan.getParams());
            massiveOperationResult.setStatus(Status.FINISHED);
            storage.save(taskUid, actor, progress);
          } catch (RuntimeException ex) {
            massiveOperationResult.setError(ex.getMessage());
            massiveOperationResult.setStatus(Status.FAILED);
            storage.save(taskUid, actor, progress);
          }
        }
      } finally {
        storage.finish(taskUid, Instant.now().plus(preservation), actor);
      }
    });
    return BatchIdentificator.builder()
        .steps(progress.getSteps().stream().map(BatchStepProgress::getName).toList()).uid(taskUid)
        .build();
  }

  /**
   * Retrieves the current progress of a batch job.
   *
   * This delegates to the storage layer to restore the last persisted state. The locale parameter
   * is reserved for future localization of messages. Callers should provide the actor to enforce
   * ownership constraints. Returns empty when no batch with the given uid is found for the actor.
   *
   * @param uid unique batch identifier
   * @param locale locale to apply for future localization
   * @param actor actor or user who owns the batch
   * @return optional containing the {@link BatchProgress} if found
   */
  public Optional<BatchProgress> retrieve(String uid, Locale locale, String actor) {
    return storage.restores(uid, actor);
  }

  /**
   * Returns the sleep service responsible for delaying between execution phases.
   *
   * This is exposed to allow overriding in tests or specialized implementations. The default
   * implementation uses a real sleep to avoid resource overload. Callers should not depend on this
   * for business logic timing.
   *
   * @return the {@link SleepService} implementation used
   */
  protected SleepService sleeper() {
    return sleeper;
  }

  /**
   * Internal utility method to pause the thread for a specified time.
   *
   * <p>
   * This is used to ensure the request context is closed before background execution starts.
   * </p>
   *
   * @param label description of the context (used for logging)
   * @param time the time in milliseconds to sleep
   */
  private void sleep(String label, long time) {
    try {
      sleeper().sleep(time);
    } catch (InterruptedException e) {
      log.error("Interrupt the thread {}", label, e);
      Thread.currentThread().interrupt();
    }
  }

}
