/* @autogenerated */
package net.civeira.phylax.common.batch;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.UUID;

import org.eclipse.microprofile.context.ManagedExecutor;

import jakarta.enterprise.context.RequestScoped;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.batch.BatchProgress.GlobalStatus;
import net.civeira.phylax.common.batch.BatchStepProgress.Status;
import net.civeira.phylax.common.batch.storage.MasiveOperationStorage;

/**
 * Service responsible for managing the execution and tracking of batch jobs composed of multiple
 * steps.
 *
 * <p>
 * This service provides the logic to initiate, execute, and monitor batch processes asynchronously.
 * Each batch process consists of a series of {@link ExecutorPlan} steps, whose execution state is
 * tracked and persisted via {@link MasiveOperationStorage}.
 * </p>
 *
 * <p>
 * Each job runs independently in a background thread, with progress persisted at each stage, and
 * finalization logic applied at the end of execution.
 * </p>
 */
@Slf4j
@RequestScoped
@RequiredArgsConstructor
public class BatchService {
  /** The storage backend used to persist and restore batch progress. */
  private final MasiveOperationStorage storage;
  /** Managed executor service used to run batch jobs asynchronously. */
  private final ManagedExecutor executor;
  /** Put the thread on suspend to avoid resources overload */
  private final SleepService sleeper = new RealSleepService();

  /**
   * Starts the asynchronous execution of a batch job composed of multiple steps.
   *
   * <p>
   * This method initializes the step definitions, persists the initial state, and launches an
   * asynchronous process to sequentially execute all steps. Each step is executed using its
   * corresponding {@link Executor}, and its progress is updated after execution.
   * </p>
   *
   * @param actor the identifier of the user or system initiating the batch job
   * @param preservation how long the batch result should be preserved after completion
   * @param plans the ordered set of execution plans (steps) that compose the batch
   * @return a {@link BatchIdentificator} containing the batch UID and step names
   */
  @SuppressWarnings({"rawtypes", "unchecked"})
  public BatchIdentificator start(String actor, Duration preservation, ExecutorPlan<?>... plans) {
    String taskUid = UUID.randomUUID().toString();
    List<BatchStepProgress> map = new ArrayList<>();
    for (int i = 0; i < plans.length; i++) {
      ExecutorPlan<?> plan = plans[i];
      BatchStepProgress step = new BatchStepProgress();
      step.setName(plan.getName());
      step.setStatus(Status.PENDING);
      map.add(step);
    }
    BatchProgress progress = BatchProgress.builder().uid(taskUid).steps(map)
        .startTime(Instant.now()).status(GlobalStatus.PENDING).build();

    storage.save(taskUid, actor, progress);
    executor.runAsync(() -> {
      // We must delay until the http request finish to ensure a new Request Context is build
      sleep("Initial delay to close request context", 5000);
      try {
        for (int i = 0; i < plans.length; i++) {
          ExecutorPlan<?> plan = plans[i];
          Executor task = plan.getExecutor();
          BatchStepProgress massiveOperationResult = map.get(i);
          try {
            massiveOperationResult.setStatus(Status.PROCESSING);
            storage.save(taskUid, actor, progress);
            task.run(massiveOperationResult, t -> {
              storage.save(taskUid, actor, progress);
            }, plan.getParams());
            massiveOperationResult.setStatus(Status.FINISHED);
            storage.save(taskUid, actor, progress);
          } catch (RuntimeException ex) {
            massiveOperationResult.setError(ex.getMessage());
            massiveOperationResult.setStatus(Status.FAILED);
            storage.save(taskUid, actor, progress);
          }
        }
      } finally {
        storage.finish(taskUid, Instant.now().plus(preservation), actor);
      }
    });
    return BatchIdentificator.builder()
        .steps(progress.getSteps().stream().map(BatchStepProgress::getName).toList()).uid(taskUid)
        .build();
  }

  /**
   * Retrieves the current progress of a batch job.
   *
   * @param uid the unique identifier of the batch
   * @param locale the locale to apply for any localization (currently unused here)
   * @param actor the actor or user who owns the batch
   * @return an optional containing the {@link BatchProgress} if found
   */
  public Optional<BatchProgress> retrieve(String uid, Locale locale, String actor) {
    return storage.restores(uid, actor);
  }

  /**
   * Returns the sleep service responsible for delaying between execution phases. Can be overridden
   * for testing.
   *
   * @return the {@link SleepService} implementation used
   */
  protected SleepService sleeper() {
    return sleeper;
  }

  /**
   * Internal utility method to pause the thread for a specified time.
   *
   * <p>
   * This is used to ensure the request context is closed before background execution starts.
   * </p>
   *
   * @param label description of the context (used for logging)
   * @param time the time in milliseconds to sleep
   */
  private void sleep(String label, long time) {
    try {
      sleeper().sleep(time);
    } catch (InterruptedException e) {
      log.error("Interrupt the thread {}", label, e);
      Thread.currentThread().interrupt();
    }
  }

}
