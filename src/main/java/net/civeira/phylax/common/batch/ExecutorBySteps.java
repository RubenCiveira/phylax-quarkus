/* @autogenerated */
package net.civeira.phylax.common.batch;

import java.util.ArrayList;
import java.util.List;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.exception.AbstractFailsException;
import net.civeira.phylax.common.value.validation.ExecutionFail;

/**
 * Abstract base class for step-based batch execution where processing is performed in three phases:
 * reading, transforming, and writing items.
 *
 * <p>
 * This executor buffers the results, tracks progress using {@link BatchStepProgress}, and handles
 * exceptions gracefully to register failures per item. It is designed to be subclassed by concrete
 * implementations that define reading and writing logic, and optionally override transformation
 * logic.
 * </p>
 *
 * @param <T> the type of input items
 * @param <R> the type of output/processed items
 * @param <P> the type of parameters passed to the execution
 */
@Slf4j
@RequiredArgsConstructor
public abstract class ExecutorBySteps<T, R, P> implements Executor<P> {
  /** Time to sleep in milliseconds after reading items. */
  private long readSleep = 100;

  /** Time to sleep in milliseconds after processing each item. */
  private long processSleep = 100;

  /** Time to sleep in milliseconds after writing items. */
  private long writeSleep = 100;

  /** Maximum number of processed items to buffer before writing. */
  private int bufferSize = 10;

  /** Put the thread on suspend to avoid resources overload */
  private final SleepService sleeper = new RealSleepService();

  /**
   * Main execution method that orchestrates reading, processing, and writing items.
   *
   * @param result the step result container to track status
   * @param store the monitor for reporting progress updates
   * @param param the input parameters for this step
   */
  @Override
  public void run(BatchStepProgress result, Monitor store, P param) {
    List<Object[]> results = new ArrayList<>();

    List<T> items = read(result, store, param);
    for (T item : items) {
      R processed = process(item, result, store, param);
      if (null != processed) {
        results.add(new Object[] {item, processed});
      }
      if (results.size() == bufferSize) {
        write(results, result, store, param);
      }
    }
    write(results, result, store, param);
    finish(param);
  }

  /**
   * Reads all input items for the batch step.
   *
   * @param param the parameters passed to the step
   * @return a list of input items to process
   */
  protected abstract List<T> read(P param);

  /**
   * Transforms a single input item to an output result. Default implementation returns the input
   * as-is.
   *
   * @param item the item to process
   * @param param the parameters passed to the step
   * @return the processed item
   */
  @SuppressWarnings("unchecked")
  protected R process(T item, P param) {
    return (R) item;
  }

  /**
   * Finalization logic to be optionally overridden. Called once after all processing and writing is
   * completed.
   *
   * @param param the parameters passed to the step
   */
  protected void finish(P param) {}


  /**
   * Provides a textual identifier for an item, used for error tracking.
   *
   * @param input the input item
   * @return a string description or identifier of the item
   */
  protected String itemDescriptor(T input) {
    return input.toString();
  }

  /**
   * Writes a single processed item. Must be implemented by subclasses.
   *
   * @param item the processed output
   * @param param the parameters passed to the step
   */
  protected abstract void write(R item, P param);

  /**
   * Returns the sleep service responsible for delaying between execution phases. Can be overridden
   * for testing.
   *
   * @return the {@link SleepService} implementation used
   */
  protected SleepService sleeper() {
    return sleeper;
  }

  /**
   * Reads and updates progress information using the monitor.
   *
   * @param result the step result tracker
   * @param store the monitor for state updates
   * @param param the step parameters
   * @return the list of input items
   */
  private List<T> read(BatchStepProgress result, Monitor store, P param) {
    List<T> items = read(param);
    result.setTotalItems(items.size());
    store.updateState(result);
    sleep("after read items", readSleep);
    return items;
  }

  /**
   * Processes a single item and handles validation and execution errors.
   *
   * @param item the item to process
   * @param result the progress tracker
   * @param store the monitor for state updates
   * @param param the step parameters
   * @return the result of processing, or {@code null} if an error occurred
   */
  private R process(T item, BatchStepProgress result, Monitor store, P param) {
    String ref = itemDescriptor(item);
    try {
      R processed = process(item, param);
      sleep("after process items", processSleep);
      return processed;
    } catch (AbstractFailsException ex) {
      ex.getFails().forEach(fail -> result.addError(ref, fail));
      store.updateState(result);
      return null;
    } catch (Exception ex) {
      result.addError(ref, new ExecutionFail(ex.getClass().getName(), ex.getMessage()));
      store.updateState(result);
      return null;
    }
  }

  /**
   * Writes a batch of buffered items, updating success or failure state accordingly.
   *
   * @param items buffered input-output item pairs
   * @param result the step progress tracker
   * @param store the monitor to update the progress state
   * @param param the parameters passed to the step
   */
  @SuppressWarnings("unchecked")
  private void write(List<Object[]> items, BatchStepProgress result, Monitor store, P param) {
    for (Object[] rows : items) {
      T input = (T) rows[0];
      R output = (R) rows[1];
      String ref = itemDescriptor(input);
      try {
        write(output, param);
        result.addOk(ref);
      } catch (AbstractFailsException ex) {
        ex.getFails().forEach(fail -> result.addError(ref, fail));
      } catch (Exception ex) {
        result.addError(ref, new ExecutionFail(ex.getClass().getName(), ex.getMessage()));
      }
      store.updateState(result);
      sleep("after write items", writeSleep);
    }
    items.clear();
  }

  /**
   * Utility method to pause execution for a given number of milliseconds.
   *
   * @param label descriptive label for logging
   * @param time sleep duration in milliseconds
   */
  private void sleep(String label, long time) {
    try {
      sleeper().sleep(time);
    } catch (InterruptedException e) {
      log.error("Interrupt the thread {}", label, e);
      Thread.currentThread().interrupt();
    }
  }

}
