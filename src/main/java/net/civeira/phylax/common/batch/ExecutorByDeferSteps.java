/* @autogenerated */
package net.civeira.phylax.common.batch;

import java.util.ArrayList;
import java.util.List;

import io.quarkus.arc.Arc;
import io.quarkus.arc.ManagedContext;
import lombok.Builder;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.batch.stepper.ItemDescriptor;
import net.civeira.phylax.common.batch.stepper.ItemProcessor;
import net.civeira.phylax.common.batch.stepper.ItemReader;
import net.civeira.phylax.common.batch.stepper.ItemWriter;
import net.civeira.phylax.common.batch.stepper.StepContext;
import net.civeira.phylax.common.batch.stepper.StepCounter;
import net.civeira.phylax.common.batch.stepper.StepFinalizer;
import net.civeira.phylax.common.batch.stepper.StepInitializer;
import net.civeira.phylax.common.exception.AbstractFailsException;
import net.civeira.phylax.common.value.validation.ExecutionFail;

/**
 * Executor implementation that runs a batch step in deferred read/process/write stages.
 *
 * The executor is configured with component classes that are resolved via CDI at runtime. It
 * supports step initialization, counting, processing, and finalization with optional hooks. Results
 * are buffered and written in batches to control throughput. Sleep intervals between phases help
 * avoid resource contention in large workloads.
 *
 * @param <T> the input item type
 * @param <R> the result/output item type
 * @param <P> the execution parameters type
 * @param <S> the step state type
 */
@Slf4j
@Builder
public class ExecutorByDeferSteps<T, R, P, S> implements Executor<P> {
  /** Sleep time in milliseconds after each read cycle. */
  @Builder.Default
  private long readSleep = 100;
  /** Sleep time in milliseconds after each process operation. */
  @Builder.Default
  private long processSleep = 100;
  /** Sleep time in milliseconds after each write cycle. */
  @Builder.Default
  private long writeSleep = 100;
  /** Maximum number of processed items to accumulate before writing. */
  @Builder.Default
  private int bufferSize = 10;
  /** Optional step initializer class. */
  private final Class<?> initializer;
  /** Item processor class to transform T → R. */
  private final Class<?> processor;
  /** Reader class to fetch input items. */
  private final Class<?> reader;
  /** Writer class to persist results. */
  private final Class<?> writer;
  /** Item descriptor class to generate item references. */
  private final Class<?> descriptor;
  /** Optional step finalizer class. */
  private final Class<?> finalizer;
  /** Optional step counter class for estimating total items. */
  private final Class<?> counter;
  /** Put the thread on suspend to avoid resources overload */
  private final SleepService sleeper = new RealSleepService();

  /**
   * Executes the batch step by initializing context and performing read/process/write cycles.
   *
   * It activates the request context, resolves CDI components, and runs the step loop. Progress is
   * updated after processing and writing, with errors captured per item. Optional initializer,
   * counter, and finalizer hooks are invoked when configured.
   *
   * @param result step result tracker
   * @param store monitor used to persist progress updates
   * @param param execution parameters
   */
  @Override
  @SuppressWarnings("unchecked")
  public void run(BatchStepProgress result, Monitor store, P param) {
    sleep("Initial delay to close request context", 3000);
    StepContext<P, S> context = new StepContext<P, S>(param, store);

    ManagedContext requestContext = Arc.container().requestContext();
    if (!requestContext.isActive()) {
      System.out.println("EL contexto no está activo, lo activamnos");
      requestContext.activate(); // Activar contexto manualmente
    } else {
      System.out.println("El contexto ya está activo, lo dejamos");
    }
    try {
      StepInitializer<P, S> forInit = null == initializer ? null
          : (StepInitializer<P, S>) Arc.container().instance(initializer).get();
      ItemDescriptor<T, P, S> forDescriptor = null == descriptor ? new ItemDescriptor<T, P, S>() {
        @Override
        public String itemDescription(T item, StepContext<P, S> context) {
          return item.toString();
        }
      } : (ItemDescriptor<T, P, S>) Arc.container().instance(descriptor).get();
      ItemReader<T, P, S> forReader = (ItemReader<T, P, S>) Arc.container().instance(reader).get();
      ItemWriter<R, P, S> forWriter = (ItemWriter<R, P, S>) Arc.container().instance(writer).get();
      ItemProcessor<T, R, P, S> forProcessor =
          (ItemProcessor<T, R, P, S>) Arc.container().instance(processor).get();
      StepFinalizer<P, S> forFinalizer = null == finalizer ? null
          : (StepFinalizer<P, S>) Arc.container().instance(finalizer).get();
      StepCounter<P, S> forCounter =
          null == counter ? null : (StepCounter<P, S>) Arc.container().instance(counter).get();

      if (null != forInit) {
        forInit.init(context);
      }
      if (null != forCounter) {
        result.setTotalItems(forCounter.approximatedItems(context));
        store.updateState(result);
      }

      List<T> itemsWindow;
      List<Object[]> results = new ArrayList<>();
      while (procesable(itemsWindow = forReader.read(context))) {
        for (T item : itemsWindow) {
          R processed = process(item, forProcessor, forDescriptor, result, store, context);
          if (null != processed) {
            results.add(new Object[] {item, processed});
          }
          if (results.size() == bufferSize) {
            write(results, forWriter, forDescriptor, result, store, context);
            store.updateState(result);
            sleep("after write items", writeSleep);
            results.clear();
          }
        }
        sleep("after read items", readSleep);
      }
      if (!results.isEmpty()) {
        write(results, forWriter, forDescriptor, result, store, context);
      }
      store.updateState(result);
      if (null != forFinalizer) {
        forFinalizer.finish(context);
      }
      store.updateState(result);
    } finally {
      requestContext.terminate();
    }
  }

  /**
   * Returns the sleep service responsible for delaying between execution phases.
   *
   * This can be overridden in tests to avoid real delays. The default implementation uses a real
   * sleep for throttling. Callers should not use this for business timing logic.
   *
   * @return the {@link SleepService} implementation used
   */
  protected SleepService sleeper() {
    return sleeper;
  }

  /**
   * Checks whether the given list of items is non-null and not empty.
   *
   * This is used to decide whether another read cycle should continue. Empty or null lists signal
   * that no more items are available. The method keeps the step loop logic concise and readable.
   *
   * @param items list of items to check
   * @return true if items can be processed
   */
  private boolean procesable(List<T> items) {
    return items != null && !items.isEmpty();
  }

  /**
   * Processes a single item using the configured processor and handles errors.
   *
   * Validation failures are captured as structured errors on the result. Unexpected exceptions are
   * also recorded to keep the batch running. The item descriptor provides an identifier for error
   * reporting.
   *
   * @param item item to process
   * @param processor processor implementation
   * @param descriptor descriptor used to identify the item
   * @param result step result container
   * @param store monitor to update the state
   * @param context execution context
   * @return processed result, or null when an error occurs
   */
  private R process(T item, ItemProcessor<T, R, P, S> processor, ItemDescriptor<T, P, S> descriptor,
      BatchStepProgress result, Monitor store, StepContext<P, S> context) {
    String ref = descriptor.itemDescription(item, context);
    try {
      R processed = processor.process(item, context);
      sleep("after process items", processSleep);
      return processed;
    } catch (AbstractFailsException ex) {
      ex.getFails().forEach(fail -> result.addError(ref, fail));
      store.updateState(result);
      return null;
    } catch (Exception ex) {
      result.addError(ref, new ExecutionFail(ex.getClass().getName(), ex.getMessage()));
      store.updateState(result);
      return null;
    }
  }

  /**
   * Writes a list of processed items and updates the batch result accordingly.
   *
   * The method groups input/output pairs and delegates to the writer. On success, it records OK
   * entries using the item descriptor. On failure, it records errors for each input item in the
   * batch.
   *
   * @param items list of input/output pairs to write
   * @param writer writer component
   * @param descriptor descriptor used to identify items
   * @param result step result container
   * @param store monitor to update the state
   * @param context execution context
   */
  @SuppressWarnings("unchecked")
  private void write(List<Object[]> items, ItemWriter<R, P, S> writer,
      ItemDescriptor<T, P, S> descriptor, BatchStepProgress result, Monitor store,
      StepContext<P, S> context) {
    List<T> inputs = new ArrayList<>();
    List<R> outputs = new ArrayList<>();
    for (Object[] rows : items) {
      inputs.add((T) rows[0]);
      outputs.add((R) rows[1]);
    }
    try {
      writer.write(outputs, context);
      inputs.forEach(input -> {
        result.addOk(descriptor.itemDescription(input, context));
      });
    } catch (Exception ex) {
      inputs.forEach(input -> {
        result.addError(descriptor.itemDescription(input, context),
            new ExecutionFail(ex.getClass().getName(), ex.getMessage()));
      });
    }
  }

  /**
   * Utility method to pause execution for a specified duration.
   *
   * @param label description for logging
   * @param time time in milliseconds to sleep
   */
  private void sleep(String label, long time) {
    try {
      sleeper().sleep(time);
    } catch (InterruptedException e) {
      log.error("Interrupt the thread {}", label, e);
      Thread.currentThread().interrupt();
    }
  }
}
