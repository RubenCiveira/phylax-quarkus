/* @autogenerated */
package net.civeira.phylax.common.batch;

import java.util.ArrayList;
import java.util.List;

import io.quarkus.arc.Arc;
import io.quarkus.arc.ManagedContext;
import lombok.Builder;
import lombok.extern.slf4j.Slf4j;
import net.civeira.phylax.common.batch.stepper.ItemDescriptor;
import net.civeira.phylax.common.batch.stepper.ItemProcessor;
import net.civeira.phylax.common.batch.stepper.ItemReader;
import net.civeira.phylax.common.batch.stepper.ItemWriter;
import net.civeira.phylax.common.batch.stepper.StepContext;
import net.civeira.phylax.common.batch.stepper.StepCounter;
import net.civeira.phylax.common.batch.stepper.StepFinalizer;
import net.civeira.phylax.common.batch.stepper.StepInitializer;
import net.civeira.phylax.common.exception.AbstractFailsException;
import net.civeira.phylax.common.value.validation.ExecutionFail;

/**
 * Executor implementation that runs a batch step in deferred stages: reading, processing, and
 * writing.
 *
 * <p>
 * This executor is dynamically built using class references to component types (reader, writer,
 * processor, etc.) that are resolved using Quarkus Arc CDI container at runtime. It is designed to
 * be highly modular and reusable.
 * </p>
 *
 * <p>
 * The execution includes configurable sleep durations between stages, context lifecycle management,
 * and progressive persistence of step results.
 * </p>
 *
 * @param <T> the input item type
 * @param <R> the result/output item type
 * @param <P> the execution parameters type
 * @param <S> the step state type
 */
@Slf4j
@Builder
public class ExecutorByDeferSteps<T, R, P, S> implements Executor<P> {
  /** Sleep time in milliseconds after each read cycle. */
  @Builder.Default
  private long readSleep = 100;
  /** Sleep time in milliseconds after each process operation. */
  @Builder.Default
  private long processSleep = 100;
  /** Sleep time in milliseconds after each write cycle. */
  @Builder.Default
  private long writeSleep = 100;
  /** Maximum number of processed items to accumulate before writing. */
  @Builder.Default
  private int bufferSize = 10;
  /** Optional step initializer class. */
  private final Class<?> initializer;
  /** Item processor class to transform T → R. */
  private final Class<?> processor;
  /** Reader class to fetch input items. */
  private final Class<?> reader;
  /** Writer class to persist results. */
  private final Class<?> writer;
  /** Item descriptor class to generate item references. */
  private final Class<?> descriptor;
  /** Optional step finalizer class. */
  private final Class<?> finalizer;
  /** Optional step counter class for estimating total items. */
  private final Class<?> counter;
  /** Put the thread on suspend to avoid resources overload */
  private final SleepService sleeper = new RealSleepService();

  /**
   * Executes the batch step by initializing context and executing read-process-write cycles.
   *
   * @param result the step result tracker
   * @param store a monitor to update execution state
   * @param param execution parameters
   */
  @Override
  @SuppressWarnings("unchecked")
  public void run(BatchStepProgress result, Monitor store, P param) {
    sleep("Initial delay to close request context", 3000);
    StepContext<P, S> context = new StepContext<P, S>(param, store);

    ManagedContext requestContext = Arc.container().requestContext();
    if (!requestContext.isActive()) {
      System.out.println("EL contexto no está activo, lo activamnos");
      requestContext.activate(); // Activar contexto manualmente
    } else {
      System.out.println("El contexto ya está activo, lo dejamos");
    }
    try {
      StepInitializer<P, S> forInit = null == initializer ? null
          : (StepInitializer<P, S>) Arc.container().instance(initializer).get();
      ItemDescriptor<T, P, S> forDescriptor = null == descriptor ? new ItemDescriptor<T, P, S>() {
        @Override
        public String itemDescription(T item, StepContext<P, S> context) {
          return item.toString();
        }
      } : (ItemDescriptor<T, P, S>) Arc.container().instance(descriptor).get();
      ItemReader<T, P, S> forReader = (ItemReader<T, P, S>) Arc.container().instance(reader).get();
      ItemWriter<R, P, S> forWriter = (ItemWriter<R, P, S>) Arc.container().instance(writer).get();
      ItemProcessor<T, R, P, S> forProcessor =
          (ItemProcessor<T, R, P, S>) Arc.container().instance(processor).get();
      StepFinalizer<P, S> forFinalizer = null == finalizer ? null
          : (StepFinalizer<P, S>) Arc.container().instance(finalizer).get();
      StepCounter<P, S> forCounter =
          null == counter ? null : (StepCounter<P, S>) Arc.container().instance(counter).get();

      if (null != forInit) {
        forInit.init(context);
      }
      if (null != forCounter) {
        result.setTotalItems(forCounter.approximatedItems(context));
        store.updateState(result);
      }

      List<T> itemsWindow;
      List<Object[]> results = new ArrayList<>();
      while (procesable(itemsWindow = forReader.read(context))) {
        for (T item : itemsWindow) {
          R processed = process(item, forProcessor, forDescriptor, result, store, context);
          if (null != processed) {
            results.add(new Object[] {item, processed});
          }
          if (results.size() == bufferSize) {
            write(results, forWriter, forDescriptor, result, store, context);
            store.updateState(result);
            sleep("after write items", writeSleep);
            results.clear();
          }
        }
        sleep("after read items", readSleep);
      }
      if (!results.isEmpty()) {
        write(results, forWriter, forDescriptor, result, store, context);
      }
      store.updateState(result);
      if (null != forFinalizer) {
        forFinalizer.finish(context);
      }
      store.updateState(result);
    } finally {
      requestContext.terminate();
    }
  }

  /**
   * Returns the sleep service responsible for delaying between execution phases. Can be overridden
   * for testing.
   *
   * @return the {@link SleepService} implementation used
   */
  protected SleepService sleeper() {
    return sleeper;
  }

  /**
   * Checks whether the given list of items is non-null and not empty.
   *
   * @param items the list of items to check
   * @return {@code true} if items can be processed
   */
  private boolean procesable(List<T> items) {
    return items != null && !items.isEmpty();
  }

  /**
   * Processes a single item using the configured processor, handling any exceptions.
   *
   * @param item the item to process
   * @param processor the processor implementation
   * @param descriptor descriptor used to identify the item
   * @param result the step result container
   * @param store the monitor to update the state
   * @param context the execution context
   * @return the processed result, or {@code null} if an error occurred
   */
  private R process(T item, ItemProcessor<T, R, P, S> processor, ItemDescriptor<T, P, S> descriptor,
      BatchStepProgress result, Monitor store, StepContext<P, S> context) {
    String ref = descriptor.itemDescription(item, context);
    try {
      R processed = processor.process(item, context);
      sleep("after process items", processSleep);
      return processed;
    } catch (AbstractFailsException ex) {
      ex.getFails().forEach(fail -> result.addError(ref, fail));
      store.updateState(result);
      return null;
    } catch (Exception ex) {
      result.addError(ref, new ExecutionFail(ex.getClass().getName(), ex.getMessage()));
      store.updateState(result);
      return null;
    }
  }

  /**
   * Writes a list of processed items and updates the batch result accordingly.
   *
   * @param items list of input/output pairs to write
   * @param writer the writer component
   * @param descriptor descriptor used to identify items
   * @param result the step result container
   * @param store the monitor to update the state
   * @param context the execution context
   */
  @SuppressWarnings("unchecked")
  private void write(List<Object[]> items, ItemWriter<R, P, S> writer,
      ItemDescriptor<T, P, S> descriptor, BatchStepProgress result, Monitor store,
      StepContext<P, S> context) {
    List<T> inputs = new ArrayList<>();
    List<R> outputs = new ArrayList<>();
    for (Object[] rows : items) {
      inputs.add((T) rows[0]);
      outputs.add((R) rows[1]);
    }
    try {
      writer.write(outputs, context);
      inputs.forEach(input -> {
        result.addOk(descriptor.itemDescription(input, context));
      });
    } catch (Exception ex) {
      inputs.forEach(input -> {
        result.addError(descriptor.itemDescription(input, context),
            new ExecutionFail(ex.getClass().getName(), ex.getMessage()));
      });
    }
  }

  /**
   * Utility method to pause execution for a specified duration.
   *
   * @param label description for logging
   * @param time time in milliseconds to sleep
   */
  private void sleep(String label, long time) {
    try {
      sleeper().sleep(time);
    } catch (InterruptedException e) {
      log.error("Interrupt the thread {}", label, e);
      Thread.currentThread().interrupt();
    }
  }
}
