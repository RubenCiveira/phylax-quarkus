/* @autogenerated */
package net.civeira.phylax.common.algorithms;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * Streaming utility that allows controlled, paginated access to a data sequence.
 *
 * The slider buffers an iterator and yields filtered elements in batches. When the current data is
 * exhausted, it can request more elements dynamically. This is useful for incremental loading where
 * a target number of matches is needed. Subclasses implement {@link #next(List, int)} to define how
 * to fetch more data.
 *
 * @param <T> the type of elements being streamed and processed
 */
public abstract class Slider<T> {
  private final int limit;
  private final List<T> items;

  /**
   * Constructs a new {@code Slider} from an initial data source and a result limit.
   *
   * @param items the source iterator providing the initial data
   * @param limit the maximum number of results expected in a sliding operation
   */
  protected Slider(Iterator<T> items, int limit) {
    this.items = new ArrayList<>();
    while (items.hasNext()) {
      this.items.add(items.next());
    }
    this.limit = limit;
  }

  /**
   * Provides additional data when the current iterator is exhausted.
   *
   * Implementations receive the list of accepted items and a target count. The returned iterator
   * should yield enough elements to fill the requested limit. Returning null indicates there is no
   * more data to fetch.
   *
   * @param valids the currently accepted (filtered) elements
   * @param limit number of additional elements requested
   * @return next batch iterator or null when exhausted
   */
  public abstract Iterator<T> next(List<T> valids, int limit);

  /**
   * Returns all buffered elements, including unfiltered data.
   *
   * This exposes the internal buffer collected from the initial iterator. It is useful for
   * diagnostics or pre-processing before sliding. The returned list is the same backing list used
   * by the slider.
   *
   * @return a list containing all elements currently held in memory
   */
  public List<T> all() {
    return items;
  }

  /**
   * Returns a single element from the buffer when exactly one exists.
   *
   * This is useful for assertions where a unique element is expected. It throws when more than one
   * element is present. Returns empty when the buffer is empty.
   *
   * @return optional containing the single element, or empty if none
   * @throws IllegalStateException when more than one element is present
   */
  public Optional<T> one() {
    if (items.size() > 1) {
      throw new IllegalStateException(
          "There are " + items.size() + " values when one was expected");
    }
    return items.isEmpty() ? Optional.empty() : Optional.of(items.get(0));
  }

  /**
   * Returns an iterator that slides through the data using a filter predicate.
   *
   * The iterator yields only elements that match the predicate. It requests more data via
   * {@link #next(List, int)} until the limit is reached. When no more data is available, iteration
   * ends.
   *
   * @param predicate filter to determine which elements are considered valid
   * @return iterator over filtered elements with sliding pagination
   */
  public Iterator<T> slide(Predicate<T> predicate) {
    return applySlide(predicate);
  }

  private Iterator<T> applySlide(Predicate<T> predicate) {
    // Tengo que construir un iterador qeu cuando se termine llame al siguiente
    return new SlideIterator<>(items.iterator(), predicate, filteredData -> {
      int registrosUtiles = filteredData.size();
      int registrosFaltantes = limit - filteredData.size();
      double ratioDescarte = 1.0 - ((double) registrosUtiles / limit);
      int nuevosRegistros = (int) Math.ceil(registrosFaltantes / (1.0 - ratioDescarte));
      return registrosFaltantes > 0 ? next(filteredData, nuevosRegistros) : null;
    });
  }
}


/**
 * Internal helper iterator for {@link Slider} that supports dynamic loading.
 *
 * It wraps an underlying iterator and applies the predicate to each candidate. When the current
 * iterator is exhausted, it requests a new iterator from the supplier. Collected items are tracked
 * to estimate how many new elements are needed. This class is package-private and used only by the
 * slider implementation.
 *
 * @param <T> the type of elements being iterated
 */
class SlideIterator<T> implements Iterator<T> {
  private Iterator<T> current;
  private T nextItem;
  private boolean prepared = false;

  private final Predicate<T> predicate;
  private final Function<List<T>, Iterator<T>> next;
  private final List<T> page = new ArrayList<>();
  private final List<T> filteredItems = new ArrayList<>();

  /**
   * Constructs a new slide iterator for the given inputs.
   *
   * The initial iterator is used until it is exhausted. The next function supplies additional
   * iterators as needed. The predicate determines which elements are yielded to callers.
   *
   * @param initial initial iterator to stream elements from
   * @param predicate filter used to accept elements
   * @param next supplier for additional iterators when needed
   */
  public SlideIterator(Iterator<T> initial, Predicate<T> predicate,
      Function<List<T>, Iterator<T>> next) {
    super();
    this.next = next;
    this.current = initial;
    this.predicate = predicate;
  }

  /**
   * Returns {@code true} when another element is available.
   *
   * This method may trigger loading of additional data when needed. It prepares the next element
   * using the predicate filter. Returns false when no further data can be fetched.
   *
   * @return true if another element is available
   */
  @Override
  public boolean hasNext() {
    prepareNext();
    return nextItem != null;
  }

  /**
   * Returns the next filtered element in the iteration.
   *
   * This advances the iterator and records the returned element. It throws when no more elements
   * are available. The method relies on {@link #hasNext()} preparation.
   *
   * @return next accepted element
   */
  @Override
  public T next() {
    prepareNext();
    if (nextItem == null)
      throw new NoSuchElementException();
    T item = nextItem;
    filteredItems.add(item);
    nextItem = null;
    prepared = false;
    return item;
  }

  private void prepareNext() {
    if (prepared)
      return;
    while (true) {
      while (current.hasNext()) {
        T candidate = current.next();
        page.add(candidate);
        if (predicate.test(candidate)) {
          nextItem = candidate;
          prepared = true;
          return;
        }
      }
      if (page.isEmpty()) {
        nextItem = null;
        prepared = true;
        return;
      } else {
        current = next.apply(page);
        page.clear();
        if (current == null) {
          nextItem = null;
          prepared = true;
          return;
        }
      }
    }
  }
}
