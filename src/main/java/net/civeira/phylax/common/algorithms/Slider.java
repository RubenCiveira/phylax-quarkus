/* @autogenerated */
package net.civeira.phylax.common.algorithms;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * An abstract streaming utility that allows controlled, paginated access to a data sequence.
 *
 * <p>
 * The {@code Slider} class wraps an existing {@link Iterator} and buffers its data. It provides
 * mechanisms to "slide" through elements in a filtered, paginated way, dynamically requesting more
 * elements as needed. It is designed for cases where data needs to be processed in chunks, possibly
 * with filtering, and where more data may be loaded progressively.
 * </p>
 *
 * <p>
 * Subclasses must implement the {@link #next(List, int)} method, which defines how additional data
 * is fetched when more elements are needed.
 * </p>
 *
 * @param <T> the type of elements being streamed and processed
 */
public abstract class Slider<T> {
  private final int limit;
  private final List<T> items;

  /**
   * Constructs a new {@code Slider} from an initial data source and a result limit.
   *
   * @param items the source iterator providing the initial data
   * @param limit the maximum number of results expected in a sliding operation
   */
  protected Slider(Iterator<T> items, int limit) {
    this.items = new ArrayList<>();
    while (items.hasNext()) {
      this.items.add(items.next());
    }
    this.limit = limit;
  }

  /**
   * Abstract method to be implemented by subclasses to provide additional data when needed.
   *
   * @param valids the currently accepted (filtered) elements
   * @param limit the number of additional elements needed to reach the desired result size
   * @return an {@link Iterator} providing the next batch of elements, or {@code null} if no more
   *         data is available
   */
  public abstract Iterator<T> next(List<T> valids, int limit);

  /**
   * Returns all buffered elements, including unfiltered data.
   *
   * @return a list containing all elements currently held in memory
   */
  public List<T> all() {
    return items;
  }

  /**
   * Returns a single element from the buffer if exactly one exists.
   *
   * @return an {@link Optional} containing the element if exactly one exists, otherwise throws an
   *         exception or returns empty
   * @throws IllegalStateException if more than one element is present
   */
  public Optional<T> one() {
    if (items.size() > 1) {
      throw new IllegalStateException(
          "There are " + items.size() + " values when one was expected");
    }
    return items.isEmpty() ? Optional.empty() : Optional.of(items.get(0));
  }

  /**
   * Returns an iterator that slides through the data based on the given predicate.
   *
   * <p>
   * This iterator will continue to load additional elements using the {@link #next(List, int)}
   * method until the configured {@code limit} of accepted elements is reached, or no more data is
   * available.
   * </p>
   *
   * @param predicate a filter to determine which elements are considered valid
   * @return an iterator that streams valid elements with sliding pagination
   */
  public Iterator<T> slide(Predicate<T> predicate) {
    return applySlide(predicate);
  }

  private Iterator<T> applySlide(Predicate<T> predicate) {
    // Tengo que construir un iterador qeu cuando se termine llame al siguiente
    return new SlideIterator<>(items.iterator(), predicate, filteredData -> {
      int registrosUtiles = filteredData.size();
      int registrosFaltantes = limit - filteredData.size();
      double ratioDescarte = 1.0 - ((double) registrosUtiles / limit);
      int nuevosRegistros = (int) Math.ceil(registrosFaltantes / (1.0 - ratioDescarte));
      return registrosFaltantes > 0 ? next(filteredData, nuevosRegistros) : null;
    });
  }
}


/**
 * Internal helper iterator for the {@link Slider}, which wraps an underlying iterator and
 * dynamically loads additional data when the current stream is exhausted.
 *
 * <p>
 * Each element returned is stored in a list to be passed to the sliding logic in order to determine
 * how much additional data is needed and whether to continue streaming.
 * </p>
 *
 * @param <T> the type of elements being iterated
 */
class SlideIterator<T> implements Iterator<T> {
  private Iterator<T> current;
  private T nextItem;
  private boolean prepared = false;

  private final Predicate<T> predicate;
  private final Function<List<T>, Iterator<T>> next;
  private final List<T> page = new ArrayList<>();
  private final List<T> filteredItems = new ArrayList<>();

  /**
   * Constructs a new {@code FD} iterator.
   *
   * @param initial the initial iterator to stream elements from
   * @param next a function that returns a new iterator when more data is needed, based on
   *        previously collected items
   */
  public SlideIterator(Iterator<T> initial, Predicate<T> predicate,
      Function<List<T>, Iterator<T>> next) {
    super();
    this.next = next;
    this.current = initial;
    this.predicate = predicate;
  }

  /**
   * Returns {@code true} if the iterator has more elements, including potentially fetched ones.
   *
   * @return {@code true} if more elements are available
   */
  @Override
  public boolean hasNext() {
    prepareNext();
    return nextItem != null;
  }

  /**
   * Returns the next element in the iteration.
   *
   * @return the next element
   */
  @Override
  public T next() {
    prepareNext();
    if (nextItem == null)
      throw new NoSuchElementException();
    T item = nextItem;
    filteredItems.add(item);
    nextItem = null;
    prepared = false;
    return item;
  }

  private void prepareNext() {
    if (prepared)
      return;
    while (true) {
      while (current.hasNext()) {
        T candidate = current.next();
        page.add(candidate);
        if (predicate.test(candidate)) {
          nextItem = candidate;
          prepared = true;
          return;
        }
      }
      if (page.isEmpty()) {
        nextItem = null;
        prepared = true;
        return;
      } else {
        current = next.apply(page);
        page.clear();
        if (current == null) {
          nextItem = null;
          prepared = true;
          return;
        }
      }
    }
  }
}
