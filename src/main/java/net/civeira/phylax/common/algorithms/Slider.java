/* @autogenerated */
package net.civeira.phylax.common.algorithms;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * Streaming utility that allows controlled, paginated access to a data sequence.
 *
 * The slider buffers an iterator and yields filtered elements in batches. When the current data is
 * exhausted, it can request more elements dynamically. This is useful for incremental loading where
 * a target number of matches is needed. Subclasses implement {@link #next(List, int)} to define how
 * to fetch more data.
 *
 * <p>
 * The source iterator is stored lazily: it is only drained into memory when {@link #all()} or
 * {@link #one()} is called. Callers that use {@link #slide(Predicate)} consume the source iterator
 * directly without loading everything into memory first. {@code all()}/{@code one()} and
 * {@code slide()} are mutually exclusive â€” calling both on the same instance produces undefined
 * results.
 * </p>
 *
 * @param <T> the type of elements being streamed and processed
 */
public abstract class Slider<T> {
  private final int limit;
  private Iterator<T> source;
  private List<T> items;

  /**
   * Constructs a new {@code Slider} from an initial data source and a result limit.
   *
   * The source iterator is stored but not consumed at construction time. Data is loaded lazily when
   * {@link #all()} or {@link #one()} is called, or consumed directly by {@link #slide(Predicate)}.
   *
   * @param items the source iterator providing the initial data
   * @param limit the maximum number of results expected in a sliding operation
   */
  protected Slider(Iterator<T> items, int limit) {
    this.source = items;
    this.items = null;
    this.limit = limit;
  }

  /**
   * Provides additional data when the current iterator is exhausted.
   *
   * Implementations receive the list of accepted items and a target count. The returned iterator
   * should yield enough elements to fill the requested limit. Returning null indicates there is no
   * more data to fetch.
   *
   * @param valids the currently accepted (filtered) elements
   * @param limit number of additional elements requested
   * @return next batch iterator or null when exhausted
   */
  public abstract Iterator<T> next(List<T> valids, int limit);

  /**
   * Returns all buffered elements, including unfiltered data.
   *
   * This drains the source iterator into memory on first call and caches the result. It is useful
   * for diagnostics or pre-processing before sliding. The returned list is the same backing list
   * used by the slider.
   *
   * @return a list containing all elements currently held in memory
   */
  public List<T> all() {
    return ensureLoaded();
  }

  /**
   * Returns a single element from the buffer when exactly one exists.
   *
   * This is useful for assertions where a unique element is expected. It throws when more than one
   * element is present. Returns empty when the buffer is empty.
   *
   * @return optional containing the single element, or empty if none
   * @throws IllegalStateException when more than one element is present
   */
  public Optional<T> one() {
    List<T> loaded = ensureLoaded();
    if (loaded.size() > 1) {
      throw new IllegalStateException(
          "There are " + loaded.size() + " values when one was expected");
    }
    return loaded.isEmpty() ? Optional.empty() : Optional.of(loaded.get(0));
  }

  /**
   * Returns an iterator that slides through the data using a filter predicate.
   *
   * The iterator yields only elements that match the predicate. It requests more data via
   * {@link #next(List, int)} until the limit is reached. When no more data is available, iteration
   * ends.
   *
   * @param predicate filter to determine which elements are considered valid
   * @return iterator over filtered elements with sliding pagination
   */
  public Iterator<T> slide(Predicate<T> predicate) {
    return applySlide(predicate);
  }

  private List<T> ensureLoaded() {
    if (items == null) {
      items = new ArrayList<>();
      while (source.hasNext()) {
        items.add(source.next());
      }
    }
    return items;
  }

  private Iterator<T> applySlide(Predicate<T> predicate) {
    Iterator<T> initial = items != null ? items.iterator() : source;
    return new SlideIterator<>(initial, predicate, filteredData -> {
      int registrosUtiles = filteredData.size();
      int registrosFaltantes = limit - filteredData.size();
      if (registrosFaltantes <= 0) {
        return null;
      }
      if (registrosUtiles == 0) {
        // No accepted items yet; cannot estimate discard ratio. Request the full remaining limit.
        return next(filteredData, registrosFaltantes);
      }
      double ratioDescarte = 1.0 - ((double) registrosUtiles / limit);
      int nuevosRegistros = (int) Math.ceil(registrosFaltantes / (1.0 - ratioDescarte));
      return next(filteredData, nuevosRegistros);
    });
  }
}


/**
 * Internal helper iterator for {@link Slider} that supports dynamic loading.
 *
 * It wraps an underlying iterator and applies the predicate to each candidate. When the current
 * iterator is exhausted, it requests a new iterator from the supplier. The accepted items are
 * tracked so that the caller can estimate how many new elements are needed. This class is
 * package-private and used only by the slider implementation.
 *
 * @param <T> the type of elements being iterated
 */
class SlideIterator<T> implements Iterator<T> {
  private Iterator<T> current;
  private T nextItem;
  private boolean prepared = false;
  private int seenInCurrentBatch = 0;

  private final Predicate<T> predicate;
  private final Function<List<T>, Iterator<T>> next;
  private final List<T> filteredItems = new ArrayList<>();

  /**
   * Constructs a new slide iterator for the given inputs.
   *
   * The initial iterator is used until it is exhausted. The next function supplies additional
   * iterators as needed. The predicate determines which elements are yielded to callers.
   *
   * @param initial initial iterator to stream elements from
   * @param predicate filter used to accept elements
   * @param next supplier for additional iterators when needed; receives the list of accepted items
   *        so far and must return the next batch iterator, or {@code null} when exhausted
   */
  public SlideIterator(Iterator<T> initial, Predicate<T> predicate,
      Function<List<T>, Iterator<T>> next) {
    super();
    this.next = next;
    this.current = initial;
    this.predicate = predicate;
  }

  /**
   * Returns {@code true} when another element is available.
   *
   * This method may trigger loading of additional data when needed. It prepares the next element
   * using the predicate filter. Returns false when no further data can be fetched.
   *
   * @return true if another element is available
   */
  @Override
  public boolean hasNext() {
    prepareNext();
    return nextItem != null;
  }

  /**
   * Returns the next filtered element in the iteration.
   *
   * This advances the iterator and records the returned element. It throws when no more elements
   * are available. The method relies on {@link #hasNext()} preparation.
   *
   * @return next accepted element
   */
  @Override
  public T next() {
    prepareNext();
    if (nextItem == null)
      throw new NoSuchElementException();
    T item = nextItem;
    filteredItems.add(item);
    nextItem = null;
    prepared = false;
    return item;
  }

  private void prepareNext() {
    if (prepared)
      return;
    while (true) {
      while (current.hasNext()) {
        T candidate = current.next();
        seenInCurrentBatch++;
        if (predicate.test(candidate)) {
          nextItem = candidate;
          prepared = true;
          return;
        }
      }
      if (seenInCurrentBatch == 0) {
        // Batch was empty: no more data available.
        nextItem = null;
        prepared = true;
        return;
      } else {
        // Batch exhausted but had items: request next batch passing the accepted items so far.
        seenInCurrentBatch = 0;
        current = next.apply(filteredItems);
        if (current == null) {
          nextItem = null;
          prepared = true;
          return;
        }
      }
    }
  }
}
