/* @autogenerated */
package net.civeira.phylax.common.value.validation.validators;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

class IPAddressValidatorUnitTest {

  @Test
  void shouldValidateValidIPv4() {
    IPAddressValidator validator =
        new IPAddressValidator(IPAddressValidator.IPVersion.IPV4, "Error");
    assertTrue(validator.validate("192.168.1.1").isValid());
  }

  @Test
  void shouldInvalidateInvalidIPv4() {
    IPAddressValidator validator =
        new IPAddressValidator(IPAddressValidator.IPVersion.IPV4, "Error");
    assertFalse(validator.validate("999.999.999.999").isValid());
  }

  @Test
  void shouldInvalidateNegativeIPv4() {
    IPAddressValidator validator =
        new IPAddressValidator(IPAddressValidator.IPVersion.IPV4, "Error");
    assertFalse(validator.validate("-1.-1.-1.-1").isValid());
  }

  @Test
  void shouldValidateValidIPv6() {
    IPAddressValidator validator =
        new IPAddressValidator(IPAddressValidator.IPVersion.IPV6, "Error");
    assertTrue(validator.validate("2001:0db8:85a3:0000:0000:8a2e:0370:7334").isValid());
  }

  @Test
  void shouldInvalidateInvalidIPv6() {
    IPAddressValidator validator =
        new IPAddressValidator(IPAddressValidator.IPVersion.IPV6, "Error");
    assertFalse(validator.validate("2001:db8:::1").isValid());
  }

  @Test
  void shouldValidateValidIPForBothVersions() {
    IPAddressValidator validator =
        new IPAddressValidator(IPAddressValidator.IPVersion.BOTH, "Error");
    assertTrue(validator.validate("192.168.1.1").isValid());
    assertTrue(validator.validate("2001:0db8:85a3:0000:0000:8a2e:0370:7334").isValid());
  }

  @Test
  void shouldInvalidateIPForMismatchedVersion() {
    IPAddressValidator ipv4Validator =
        new IPAddressValidator(IPAddressValidator.IPVersion.IPV4, "Error");
    assertFalse(ipv4Validator.validate("2001:0db8:85a3:0000:0000:8a2e:0370:7334").isValid());

    IPAddressValidator ipv6Validator =
        new IPAddressValidator(IPAddressValidator.IPVersion.IPV6, "Error");
    assertFalse(ipv6Validator.validate("192.168.1.1").isValid());
  }

  @Test
  void shouldInvalidateNullAndEmptyIP() {
    IPAddressValidator validator =
        new IPAddressValidator(IPAddressValidator.IPVersion.BOTH, "Error");
    assertFalse(validator.validate(null).isValid());
    assertFalse(validator.validate("").isValid());
  }

  @Test
  void shouldValidateIPWithinSubnet() {
    IPAddressValidator validator = new IPAddressValidator(IPAddressValidator.IPVersion.IPV4,
        "192.168.1.0", "255.255.255.0", "Error");
    assertTrue(validator.validate("192.168.1.100").isValid());
  }

  @Test
  void shouldInvalidateIPOutsideSubnet() {
    IPAddressValidator validator = new IPAddressValidator(IPAddressValidator.IPVersion.IPV4,
        "192.168.1.0", "255.255.255.0", "Error");
    assertFalse(validator.validate("192.168.2.100").isValid());
  }

  @Test
  void shouldThrowExceptionForIncompleteSubnetConfiguration() {
    assertThrows(IllegalArgumentException.class,
        () -> new IPAddressValidator(IPAddressValidator.IPVersion.IPV4, "192.168.1.0", null,
            "Error"));

    assertThrows(IllegalArgumentException.class,
        () -> new IPAddressValidator(IPAddressValidator.IPVersion.IPV4, null, "255.255.255.0",
            "Error"));
  }

  @Test
  void shouldInitializeWithNetworkAndSubnet() {
    IPAddressValidator validator = new IPAddressValidator(IPAddressValidator.IPVersion.IPV4,
        "192.168.1.0", "255.255.255.0", "Error");
    assertNotNull(validator);
  }
}
