/* @autogenerated */
package net.civeira.phylax.common.value.validation;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;

import java.util.Locale;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import net.civeira.phylax.common.value.YamlLocaleMessages;

class AbstractFailUnitTest {

  @Mock
  private YamlLocaleMessages mockMessages;

  @BeforeEach
  void setUp() {
    MockitoAnnotations.openMocks(this);
    AbstractFail.setLocalizedMessages(Locale.ENGLISH, mockMessages);
  }

  @Test
  void constructorShouldInitializeWithFieldAndValue() {
    String code = "ERR001";
    String field = "username";
    String value = "invalidUser";
    AbstractFail fail = new ConcreteFail(code, field, value);

    assertEquals(code, fail.getCode(), "El código debería coincidir");
    assertNull(fail.getViolation(), "La violación debería ser nula");
    assertEquals(1, fail.getWrongValues().size(), "Debe haber un solo valor erróneo");
    assertEquals(field, fail.getWrongValues().get(0).getField(), "El campo debe coincidir");
    assertEquals(value, fail.getWrongValues().get(0).getWrongValue(),
        "El valor erróneo debe coincidir");
  }

  @Test
  void constructorShouldInitializeWithException() {
    String code = "ERR002";
    Exception exception = new RuntimeException("Error grave");
    AbstractFail fail = new ConcreteFail(code, exception);

    assertEquals(code, fail.getCode(), "El código debería coincidir");
    assertEquals("Error grave", fail.getViolation(), "La violación debería coincidir");
    assertTrue(fail.getWrongValues().isEmpty(), "No debería haber valores erróneos");
  }

  @Test
  void shouldLocalizeWithCorrectMessages() {
    setupMockMessages("ERR003", "email", "Invalid email format", "Localized Error Code",
        "Localized description");
    AbstractFail fail = new ConcreteFail("ERR003", "email", "invalid@");
    AbstractFail.LocalizedFail localizedFail = fail.localize(Locale.ENGLISH, false);

    assertEquals("Localized description", localizedFail.getDescription());
    assertEquals("Localized Error Code", localizedFail.getCode());
    assertEquals(1, localizedFail.getWrongValues().size());
    assertEquals("Invalid email format", localizedFail.getWrongValues().get(0).getErrorMessage());
  }

  @Test
  void shouldNotLocalizeIfMessagesDoNotExist() {
    AbstractFail fail = new ConcreteFail("NO_ERR", "email", "invalid@", "wm");
    AbstractFail.LocalizedFail localizedFail = fail.localize(Locale.ENGLISH, true);

    assertNull(localizedFail.getDescription());
    assertEquals("NO_ERR", localizedFail.getCode());
    assertNull(localizedFail.getViolation());
    assertEquals("wm", localizedFail.getWrongValues().get(0).getErrorMessage());
  }

  @Test
  void shouldExposeViolationIfConfigured() {
    RuntimeException re = new RuntimeException("Too many connections");
    AbstractFail fail = new ConcreteFail("NO_ERR", re);
    AbstractFail.LocalizedFail localizedFail = fail.localize(Locale.ENGLISH, true);

    assertEquals("Too many connections", localizedFail.getViolation());
  }

  @Test
  void shouldNotExposeViolationIfNotConfigured() {
    RuntimeException re = new RuntimeException("Too many connections");
    setupMockMessages("ERR003", "email", "Invalid email format", "Localized Error Code",
        "Localized description");
    AbstractFail fail = new ConcreteFail("ERR003", re);
    AbstractFail.LocalizedFail localizedFail = fail.localize(Locale.ENGLISH, true);

    assertNull(localizedFail.getViolation());
  }

  private void setupMockMessages(String code, String field, String fieldError, String localizedCode,
      String description) {
    when(mockMessages.contains(code + ".code")).thenReturn(true);
    when(mockMessages.contains(code + ".description")).thenReturn(true);
    when(mockMessages.get(code + ".description")).thenReturn(description);
    when(mockMessages.get(code + ".code")).thenReturn(localizedCode);
    when(mockMessages.contains(code + ".field." + field)).thenReturn(true);
    when(mockMessages.get(code + ".field." + field)).thenReturn(fieldError);
    when(mockMessages.get(code + ".show-violation")).thenReturn("false");
  }

  private static class ConcreteFail extends AbstractFail {
    public ConcreteFail(String code, String field, Object wrongValue) {
      super(code, field, wrongValue);
    }

    public ConcreteFail(String code, Exception source) {
      super(code, source);
    }

    public ConcreteFail(String code, String field, Object wrongValue, String errorMessage) {
      super(code, field, wrongValue, errorMessage);
    }
  }
}
