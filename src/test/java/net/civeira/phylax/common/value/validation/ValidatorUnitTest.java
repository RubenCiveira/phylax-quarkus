/* @autogenerated */
package net.civeira.phylax.common.value.validation;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockitoAnnotations;

class ValidatorUnitTest {

  @BeforeEach
  void setUp() {
    MockitoAnnotations.openMocks(this);
  }

  @Test
  void validateShouldReturnExpectedResult() {
    ValidationResult result = new MockValidator(true).validate("test");
    assertTrue(result.isValid(), "El resultado debería ser válido");
    assertTrue(result.getErrors().isEmpty(), "La lista de errores debería estar vacía");
  }

  @Test
  void andShouldCombineValidators() {
    MockValidator one = new MockValidator(true);
    MockValidator two = new MockValidator(false);
    Validator<String> combinedValidator = one.and(two);

    ValidationResult result = combinedValidator.validate("test");

    assertFalse(result.isValid(), "El resultado debería ser inválido");
    assertEquals(1, result.getErrors().size(), "Debe haber un error registrado");
    assertEquals("nope", result.getErrors().get(0), "El mensaje de error debe coincidir");

    MockValidator one2 = new MockValidator(true);
    MockValidator two2 = new MockValidator(true);
    Validator<String> rightCombinedValidator = one2.and(two2);

    ValidationResult trueResult = rightCombinedValidator.validate("test");
    assertTrue(trueResult.isValid(), "El resultado debería ser válido");
    assertTrue(trueResult.getErrors().isEmpty(), "La lista de errores debería estar vacía");

    MockValidator one3 = new MockValidator(false);
    MockValidator two3 = new MockValidator(true);
    Validator<String> alsoWrongCombinedValidator = one3.and(two3);

    ValidationResult result3 = alsoWrongCombinedValidator.validate("test");
    assertFalse(result3.isValid(), "El resultado debería ser inválido");
    assertEquals(1, result3.getErrors().size(), "Debe haber un error registrado");
    assertEquals("nope", result3.getErrors().get(0), "El mensaje de error debe coincidir");
  }

  @Test
  void orShouldReturnValidIfAnyValidatorIsValid() {
    MockValidator one = new MockValidator(true);
    MockValidator two = new MockValidator(false);

    Validator<String> rightCombinedValidator = one.or(two);
    ValidationResult result1 = rightCombinedValidator.validate("test");

    assertTrue(result1.isValid(), "El resultado debería ser válido");
    assertTrue(result1.getErrors().isEmpty(), "No debería haber errores");

    MockValidator one2 = new MockValidator(false);
    MockValidator two2 = new MockValidator(false);

    Validator<String> wrongCombinedValidator = one2.or(two2);
    ValidationResult result2 = wrongCombinedValidator.validate("test");

    assertFalse(result2.isValid(), "El resultado debería ser inválido");
    assertEquals(2, result2.getErrors().size(), "Debe haber dos errores");

    MockValidator one3 = new MockValidator(false);
    MockValidator two3 = new MockValidator(true);

    Validator<String> alsoRightCombinedValidator = one3.or(two3);
    ValidationResult result3 = alsoRightCombinedValidator.validate("test");

    assertTrue(result3.isValid(), "El resultado debería ser válido");
    assertTrue(result3.getErrors().isEmpty(), "No debería haber errores");
  }

  @Test
  void negateShouldInvertValidationResult() {
    Validator<String> negatedTrueValidator = new MockValidator(true).negate("Negado");
    ValidationResult resultTrue = negatedTrueValidator.validate("test");

    assertFalse(resultTrue.isValid(), "El resultado debería ser inválido");
    assertEquals(1, resultTrue.getErrors().size(), "Debe haber un error registrado");
    assertEquals("Negado", resultTrue.getErrors().get(0), "El mensaje de error debe coincidir");

    Validator<String> negatedFalseValidator = new MockValidator(false).negate("Negado");
    ValidationResult resultFalse = negatedFalseValidator.validate("test");

    assertTrue(resultFalse.isValid(), "El resultado debería ser valido");
    assertTrue(resultFalse.getErrors().isEmpty(), "Debe haber un error registrado");
  }

  public static class MockValidator implements Validator<String> {
    private final boolean response;

    public MockValidator(boolean response) {
      super();
      this.response = response;
    }


    @Override
    public ValidationResult validate(String t) {
      return response ? new ValidationResult() : new ValidationResult("nope");
    }
  }
}
