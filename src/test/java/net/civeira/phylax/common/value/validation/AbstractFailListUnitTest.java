/* @autogenerated */
package net.civeira.phylax.common.value.validation;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockitoAnnotations;

class AbstractFailListUnitTest {

  @BeforeEach
  void setUp() {
    MockitoAnnotations.openMocks(this);
  }

  @Test
  void defaultConstructorShouldCreateEmptyList() {
    AbstractFailList failList = new AbstractFailList();
    assertTrue(failList.isEmpty(), "La lista debería estar vacía");
    assertFalse(failList.hasErrors(), "La lista no debería tener errores");
  }

  @Test
  void constructorWithSingleFailShouldContainOneElement() {
    AbstractFailList failList = new AbstractFailList(new ConcreteFail());
    assertFalse(failList.isEmpty(), "La lista no debería estar vacía");
    assertTrue(failList.hasErrors(), "La lista debería tener errores");
    assertEquals(1, failList.getFails().count(), "La lista debería contener un solo fallo");
  }

  @Test
  void constructorWithListShouldContainAllElements() {
    AbstractFailList failList =
        new AbstractFailList(List.of(new ConcreteFail(), new ConcreteFail()));
    assertFalse(failList.isEmpty(), "La lista no debería estar vacía");
    assertTrue(failList.hasErrors(), "La lista debería tener errores");
    assertEquals(2, failList.getFails().count(), "La lista debería contener dos fallos");
  }

  @Test
  void addShouldIncreaseSize() {
    AbstractFailList failList = new AbstractFailList();
    failList.add(new ConcreteFail());
    assertEquals(1, failList.getFails().count(),
        "La lista debería contener un fallo después de añadir uno");
  }

  @Test
  void addListShouldMergeFails() {
    AbstractFailList failList1 = new AbstractFailList(new ConcreteFail());
    AbstractFailList failList2 = new AbstractFailList(new ExternalFail());
    failList1.add(failList2);
    assertEquals(2, failList1.getFails().count(), "La lista combinada debería contener dos fallos");
  }

  @Test
  void includeViolationShouldReturnTrueIfTypeExists() {
    AbstractFailList failList = new AbstractFailList(new ConcreteFail());
    assertTrue(failList.includeViolation(ConcreteFail.class),
        "Debería detectar la presencia del tipo especificado");
    assertFalse(failList.includeViolation(ExternalFail.class),
        "No debería detectar la presencia del tipo especificado");
  }

  @Test
  void includeCodeShouldReturnTrueIfCodeExists() {
    AbstractFailList failList = new AbstractFailList(new ConcreteFail("ERR123"));
    assertTrue(failList.includeCode("ERR123"),
        "Debería detectar la presencia del código especificado");
    assertFalse(failList.includeCode("ERR"),
        "No debería detectar la presencia del código especificado");
  }

  // Clase concreta para pruebas, ya que AbstractFail es abstracta
  private static class ConcreteFail extends AbstractFail {
    public ConcreteFail() {
      super("cf", "", "");
    }

    public ConcreteFail(String code) {
      super(code, "", "");
    }
  }

  // Clase concreta para pruebas, ya que AbstractFail es abstracta
  private static class ExternalFail extends AbstractFail {
    public ExternalFail() {
      super("ef", "", "");
    }
  }

}
