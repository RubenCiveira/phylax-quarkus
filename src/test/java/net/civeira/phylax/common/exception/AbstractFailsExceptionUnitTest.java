/* @autogenerated */
package net.civeira.phylax.common.exception;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.Collection;
import java.util.List;
import java.util.Locale;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import net.civeira.phylax.common.value.validation.AbstractFail;
import net.civeira.phylax.common.value.validation.AbstractFail.LocalizedFail;
import net.civeira.phylax.common.value.validation.AbstractFail.LocalizedWrongValue;
import net.civeira.phylax.common.value.validation.AbstractFailList;
import net.civeira.phylax.common.value.validation.ConstraintFail;

class AbstractFailsExceptionUnitTest {

  private MockAbstractFail mockFail1;
  private MockAbstractFail mockFail2;
  private AbstractFailList failList;

  private AbstractFailsException exception;

  @BeforeEach
  void setup() {
    mockFail1 = mock(MockAbstractFail.class);
    mockFail2 = mock(MockAbstractFail.class);

    failList = spy(new AbstractFailList(List.of(mockFail1, mockFail2)));

    // Create anonymous subclass to test
    exception = new AbstractFailsException(failList) {
      private static final long serialVersionUID = 1L;
    };
  }

  @Test
  void testConstructorWithSingleFail() {
    AbstractFailsException single = new AbstractFailsException(mockFail1) {
      private static final long serialVersionUID = 1L;
    };
    assertTrue(single.hasErrors());
    assertEquals(1, single.getFails().count());
  }

  @Test
  void testHasErrorsDelegatesToFailList() {
    when(failList.hasErrors()).thenReturn(true);
    assertTrue(exception.hasErrors());
    verify(failList).hasErrors();
  }

  @Test
  void testIsEmptyDelegatesToFailList() {
    when(failList.isEmpty()).thenReturn(false);
    assertFalse(exception.isEmpty());
    verify(failList).isEmpty();
  }

  @Test
  void testIncludeViolationDelegatesToFailList() {
    @SuppressWarnings("unchecked")
    Class<ConstraintFail> violationClass = (Class<ConstraintFail>) (Class<?>) ConstraintFail.class;
    when(failList.includeViolation(violationClass)).thenReturn(true);

    assertTrue(exception.includeViolation(violationClass));
    verify(failList).includeViolation(violationClass);
  }

  @Test
  void testIncludeCodeDelegatesToFailList() {
    when(failList.includeCode("E001")).thenReturn(true);
    assertTrue(exception.includeCode("E001"));
    verify(failList).includeCode("E001");
  }

  @Test
  void testLocalizeCombinesLocalizedFailsWithSameCode() {
    // Prepare localized fails with same code
    LocalizedWrongValue wrongValue1 =
        LocalizedWrongValue.builder().field("input1").wrongValue("val1").build();
    LocalizedWrongValue wrongValue2 =
        LocalizedWrongValue.builder().field("input2").wrongValue("val2").build();

    LocalizedFail localized1 = LocalizedFail.builder().code("DUPLICATE").description("Error A")
        .wrongValues(List.of(wrongValue1)).build();

    LocalizedFail localized2 = LocalizedFail.builder().code("DUPLICATE").description("Error A")
        .wrongValues(List.of(wrongValue2)).build();

    AbstractFail failA = mock(AbstractFail.class);
    AbstractFail failB = mock(AbstractFail.class);

    when(failA.localize(Locale.ENGLISH, true)).thenReturn(localized1);
    when(failB.localize(Locale.ENGLISH, true)).thenReturn(localized2);

    AbstractFailsException ex =
        new AbstractFailsException(new AbstractFailList(List.of(failA, failB))) {
          private static final long serialVersionUID = 1L;
        };

    Collection<LocalizedFail> localized = ex.localize(Locale.ENGLISH, true);

    assertEquals(1, localized.size());
    LocalizedFail combined = localized.iterator().next();
    assertEquals("DUPLICATE", combined.getCode());
    assertEquals(2, combined.getWrongValues().size());
  }
}


class MockAbstractFailList extends AbstractFailList {

}


class MockAbstractFail extends AbstractFail {
  public MockAbstractFail(String code, Exception source) {
    super(code, source);
  }
}
