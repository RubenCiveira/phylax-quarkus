/* @autogenerated */
package net.civeira.phylax.common.crypto;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

import java.security.GeneralSecurityException;
import java.util.Optional;

import javax.crypto.Cipher;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import net.civeira.phylax.testing.mock.LoggerChecker;

class AesCipherServiceUnitTest {
  private AesCipherService aesCipherService;

  @BeforeEach
  void setUp() {
    aesCipherService = new AesCipherService("testKey");
  }

  @Test
  void testEncryptionAndDecryptionUsingAppKey() {
    String originalText = "Hello, OpenAI!";

    String encryptedText = aesCipherService.encryptForAll(originalText);
    Optional<String> decryptedText = aesCipherService.decryptForAll(encryptedText);

    assertTrue(decryptedText.isPresent());
    assertEquals(originalText, decryptedText.get());
  }

  @Test
  void testEncryptionAndDecryptionUsingCustomKey() {
    String originalText = "Hello, OpenAI!";
    String customKey = "customKey";

    String encryptedText = aesCipherService.encrypt(originalText, customKey);
    String encryptedText2 = aesCipherService.encrypt(originalText, customKey);
    Optional<String> decryptedText = aesCipherService.decrypt(encryptedText, customKey);

    assertNotEquals(encryptedText, encryptedText2);
    assertTrue(decryptedText.isPresent());
    assertEquals(originalText, decryptedText.get());
  }

  @Test
  void testDecryptionWithWrongKey() throws Exception {
    String originalText = "Hello, OpenAI!";
    String customKey = "customKey";
    String wrongKey = "wrongKey";

    String encryptedText = aesCipherService.encrypt(originalText, customKey);

    try (LoggerChecker checker = LoggerChecker.bind(aesCipherService)) {
      Optional<String> decryptedText = aesCipherService.decrypt(encryptedText, wrongKey);
      assertFalse(decryptedText.isPresent());
      Assertions.assertFalse(checker.containsError("Unable to decript text for "));
      Assertions.assertEquals(0, checker.logCount());

      checker.reset();
      checker.setLevelToError();
      decryptedText = aesCipherService.decrypt(encryptedText, wrongKey);
      assertFalse(decryptedText.isPresent());
      Assertions.assertTrue(checker.containsError("Unable to decript text for "));
    }
  }

  @Test
  void testGenerateSecureRandomApi() {
    String api1 = aesCipherService.generateSecureRandomApiSecret();
    String api2 = aesCipherService.generateSecureRandomApiSecret();
    String api3 = aesCipherService.generateSecureRandomApiSecret();
    String api4 = aesCipherService.generateSecureRandomApiSecret();
    String api5 = aesCipherService.generateSecureRandomApiSecret();
    String api6 = aesCipherService.generateSecureRandomApiSecret();

    assertTrue(hasApiRequiredConvination(api1));
    assertTrue(hasApiRequiredConvination(api2));
    assertTrue(hasApiRequiredConvination(api3));
    assertTrue(hasApiRequiredConvination(api4));
    assertTrue(hasApiRequiredConvination(api5));
    assertTrue(hasApiRequiredConvination(api6));

    assertTrue(areDistinctAndNotNumberPrefix(api1, api2, api3, api4, api5, api6));

  }

  @Test
  void testGenerateSecureRandomPassword() {
    String password = aesCipherService.generateSecureRandomPassword();
    String password1 = aesCipherService.generateSecureRandomPassword();
    String password2 = aesCipherService.generateSecureRandomPassword();
    String password3 = aesCipherService.generateSecureRandomPassword();
    String password4 = aesCipherService.generateSecureRandomPassword();

    assertTrue(hasPasswordRequiredConvination(password));
    assertTrue(hasPasswordRequiredConvination(password1));
    assertTrue(hasPasswordRequiredConvination(password2));
    assertTrue(hasPasswordRequiredConvination(password3));
    assertTrue(hasPasswordRequiredConvination(password4));

    assertTrue(areDistinctAndNotNumberPrefix(password, password1, password2, password3, password4));
  }

  @Test
  void testError() throws Exception {
    try (MockedStatic<Cipher> mockCipher = Mockito.mockStatic(Cipher.class)) {
      when(Cipher.getInstance("AES/GCM/NoPadding")).thenAnswer(call -> {
        throw new GeneralSecurityException("Test exception");
      });
      assertThrows(IllegalStateException.class, () -> aesCipherService.encrypt("uno", "otro"));
    }
  }

  private boolean hasPasswordRequiredConvination(String password) {
    int numberCharCount = 0;
    int specialCharCount = 0;
    int lowerCase = 0;
    int upperCase = 0;
    for (char c : password.toCharArray()) {
      if (c >= 33 && c <= 47) {
        specialCharCount++;
      }
      if (c >= 48 && c <= 57) {
        numberCharCount++;
      }
      if (c >= 65 && c <= 90) {
        upperCase++;
      }
      if (c >= 97 && c <= 122) {
        lowerCase++;
      }
    }

    assertEquals(10, password.length());

    return password != null && 10 == password.length() && numberCharCount == 2
        && specialCharCount == 2 && lowerCase == 4 && upperCase == 2;
  }

  private boolean hasApiRequiredConvination(String password) {
    int numberCharCount = 0;
    int specialCharCount = 0;
    int lowerCase = 0;
    int upperCase = 0;
    for (char c : password.toCharArray()) {
      if (c >= 33 && c <= 47) {
        specialCharCount++;
      }
      if (c >= 48 && c <= 57) {
        numberCharCount++;
      }
      if (c >= 65 && c <= 90) {
        upperCase++;
      }
      if (c >= 97 && c <= 122) {
        lowerCase++;
      }
    }

    assertEquals(33, password.length());

    return password != null && 33 == password.length() && numberCharCount == 6
        && specialCharCount == 5 && lowerCase == 20 && upperCase == 2;
  }

  private boolean areDistinctAndNotNumberPrefix(String... strings) {
    boolean equals = false;
    boolean startWithNumber = true;
    for (int i = 0; i < strings.length; i++) {
      for (int j = 0; j < strings.length; j++) {
        if (i != j) {
          if (strings[i].equals(strings[j])) {
            equals = true;
          }
        }
      }
      for (int j = 0; j < 2; j++) {
        char c = strings[i].charAt(j);
        if (c < 48 || c > 57) {
          startWithNumber = false;
        }
      }
    }
    return !equals && !startWithNumber;
  }
}
