/* @autogenerated */
package net.civeira.phylax.common.infrastructure.sql;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockStatic;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.SQLException;
import java.util.Optional;

import javax.sql.DataSource;

import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;

import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.SpanBuilder;
import io.opentelemetry.api.trace.SpanContext;
import io.opentelemetry.api.trace.Tracer;

class SqlTemplateUnitTest {

  @Test
  void constructorWithConnection() {
    Connection conn = mock(Connection.class);
    SqlTemplate template = new SqlTemplate(conn);
    assertNotNull(template);
  }

  @Test
  void constructorWithDataSource() throws SQLException {
    DataSource ds = mock(DataSource.class);
    Connection conn = mock(Connection.class);
    when(ds.getConnection()).thenReturn(conn);

    SqlTemplate template = new SqlTemplate(ds);
    assertNotNull(template);
  }


  @Test
  void constructorWithDataSourceThrows() throws SQLException {
    DataSource ds = mock(DataSource.class);
    when(ds.getConnection()).thenThrow(SQLException.class);
    assertThrows(UncheckedSqlException.class, () -> new SqlTemplate(ds));
  }

  @Test
  void constructorWithDataAndTracerSource() throws SQLException {
    DataSource ds = mock(DataSource.class);
    Connection conn = mock(Connection.class);
    when(ds.getConnection()).thenReturn(conn);
    Tracer tracer = mock(Tracer.class);

    SqlTemplate template = new SqlTemplate(ds, tracer);
    assertNotNull(template);
  }


  @Test
  void constructorWithDataSourceAndTracerThrowsUncheckedSqlException() throws SQLException {
    DataSource ds = mock(DataSource.class);
    when(ds.getConnection()).thenThrow(new SQLException("DB down"));
    Tracer tracer = mock(Tracer.class);

    assertThrows(UncheckedSqlException.class, () -> new SqlTemplate(ds, tracer));
  }

  @Test
  void beginDisablesAutoCommit() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.getAutoCommit()).thenReturn(true);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      template.begin();
    }
    verify(conn).setAutoCommit(false);
  }

  @Test
  void beginDoesNothingIfAlreadyFalse() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.getAutoCommit()).thenReturn(false);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      template.begin();
    }
    verify(conn, never()).setAutoCommit(false);
  }

  @Test
  void commitAppliesOnlyIfNotAutoCommit() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.getAutoCommit()).thenReturn(false);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      template.commit();
    }
    verify(conn).commit();
    verify(conn).setAutoCommit(true);
  }

  @Test
  void rollbackAppliesOnlyIfNotAutoCommit() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.getAutoCommit()).thenReturn(false);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      template.rollback();
    }
    verify(conn).rollback();
    verify(conn).setAutoCommit(true);
  }

  @Test
  void closeConnectionIfOpen() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.isClosed()).thenReturn(false);

    SqlTemplate template = new SqlTemplate(conn);
    template.close();

    verify(conn).close();
  }

  @Test
  void closeDoesNothingIfAlreadyClosed() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.isClosed()).thenReturn(true);

    SqlTemplate template = new SqlTemplate(conn);
    template.close();

    verify(conn, never()).close();
  }

  @Test
  void testWithTableLockSqlServer() throws SQLException {
    Connection conn = mock(Connection.class);
    DatabaseMetaData meta = mock(DatabaseMetaData.class);
    when(meta.getDriverName()).thenReturn("SQLServer JDBC");
    when(conn.getMetaData()).thenReturn(meta);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      String result = template.withTableLock("SELECT * FROM table");

      assertTrue(result.contains("WITH (UPDLOCK, ROWLOCK)"));
    }
  }

  @Test
  void testWithTableLockOtherDb() throws SQLException {
    Connection conn = mock(Connection.class);
    DatabaseMetaData meta = mock(DatabaseMetaData.class);
    when(meta.getDriverName()).thenReturn("PostgreSQL");
    when(conn.getMetaData()).thenReturn(meta);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      String result = template.withTableLock("SELECT * FROM table");

      assertFalse(result.contains("WITH"));
    }
  }

  @Test
  void testWithQueryLockSqlServer() throws SQLException {
    Connection conn = mock(Connection.class);
    DatabaseMetaData meta = mock(DatabaseMetaData.class);
    when(meta.getDriverName()).thenReturn("SQLServer");
    when(conn.getMetaData()).thenReturn(meta);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      String result = template.withQueryLock("SELECT * FROM table");

      assertFalse(result.contains("FOR UPDATE"));
    }
  }

  @Test
  void testWithQueryLockOtherDb() throws SQLException {
    Connection conn = mock(Connection.class);
    DatabaseMetaData meta = mock(DatabaseMetaData.class);
    when(meta.getDriverName()).thenReturn("H2");
    when(conn.getMetaData()).thenReturn(meta);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      String result = template.withQueryLock("SELECT * FROM table");

      assertTrue(result.endsWith("FOR UPDATE"));
    }
  }

  @Test
  void testSqlWithQueryLockSqlServer() throws SQLException {
    Connection conn = mock(Connection.class);
    DatabaseMetaData meta = mock(DatabaseMetaData.class);
    when(meta.getDriverName()).thenReturn("SQLServer");
    when(conn.getMetaData()).thenReturn(meta);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      String result = template.sqlWithQueryLock("SELECT * FROM [users] u");

      assertTrue(result.contains("WITH (UPDLOCK, ROWLOCK)"));
    }
  }

  @Test
  void testSqlWithQueryLockOtherDb() throws SQLException {
    Connection conn = mock(Connection.class);
    DatabaseMetaData meta = mock(DatabaseMetaData.class);
    when(meta.getDriverName()).thenReturn("PostgreSQL");
    when(conn.getMetaData()).thenReturn(meta);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      String result = template.sqlWithQueryLock("SELECT * FROM users");

      assertTrue(result.endsWith("FOR UPDATE"));
    }
  }

  @Test
  void testCreateSpanWithoutTracerReturnsEmpty() {
    Connection conn = mock(Connection.class);
    try (SqlTemplate template = new SqlTemplate(conn)) {
      assertTrue(template.createSpan("Test").isEmpty());
    }
  }

  @Test
  void testCreateSpanWithTracerAndInvalidParentReturnsEmpty() {
    Tracer tracer = mock(Tracer.class);
    Connection conn = mock(Connection.class);
    try (SqlTemplate template = new SqlTemplate(conn, tracer)) {
      Span current = mock(Span.class);
      SpanContext ctx = mock(SpanContext.class);
      when(ctx.isValid()).thenReturn(false);
      when(current.getSpanContext()).thenReturn(ctx);
      Span.current(); // simulate
      assertTrue(template.createSpan("span").isEmpty());
    }
  }

  @Test
  void testCreateSpanWithValidParent() {
    Tracer tracer = mock(Tracer.class);
    Span span = mock(Span.class);
    SpanContext ctx = mock(SpanContext.class);
    when(ctx.isValid()).thenReturn(true);
    when(span.getSpanContext()).thenReturn(ctx);

    // Fully chained mock of SpanBuilder
    io.opentelemetry.api.trace.SpanBuilder spanBuilder =
        mock(io.opentelemetry.api.trace.SpanBuilder.class);
    when(tracer.spanBuilder("query")).thenReturn(spanBuilder);
    when(spanBuilder.setParent(any())).thenReturn(spanBuilder);
    when(spanBuilder.setSpanKind(any())).thenReturn(spanBuilder);
    when(spanBuilder.startSpan()).thenReturn(mock(Span.class));

    SqlTemplate template = new SqlTemplate(mock(Connection.class), tracer);
    Optional<Span> result = template.createSpan("query", Optional.of(span));

    assertTrue(result.isPresent());
  }

  @Test
  void testCreateSqlObjects() {
    SqlTemplate template = new SqlTemplate(mock(Connection.class));
    assertNotNull(template.createSqlQuery("SELECT * FROM test"));
    assertNotNull(template.createSqlCommand("DELETE FROM test"));
    assertNotNull(template.createSqlSchematicQuery("test_table"));
  }

  @Test
  void constructorWithNullConnectionThrows() {
    assertThrows(IllegalArgumentException.class, () -> new SqlTemplate((Connection) null));
  }

  @Test
  void constructorWithNullDataSourceThrows() {
    assertThrows(IllegalArgumentException.class, () -> new SqlTemplate((DataSource) null));
  }

  @Test
  void constructorWithNullConnectionAndTracerThrows() {
    Tracer tracer = mock(Tracer.class);
    assertThrows(IllegalArgumentException.class, () -> new SqlTemplate((Connection) null, tracer));
  }

  @Test
  void constructorWithNullDataSourceAndTracerThrows() {
    Tracer tracer = mock(Tracer.class);
    assertThrows(IllegalArgumentException.class, () -> new SqlTemplate((DataSource) null, tracer));
  }

  @Test
  void beginThrowsUncheckedSqlExceptionWhenAutoCommitFails() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.getAutoCommit()).thenThrow(new SQLException("auto-commit"));

    UncheckedSqlException mockEx =
        new UncheckedSqlException(new SQLException(mock(SQLException.class)));

    try (MockedStatic<UncheckedSqlException> mocked = mockStatic(UncheckedSqlException.class)) {
      mocked.when(() -> UncheckedSqlException.exception(any(), any())).thenReturn(mockEx);

      try (SqlTemplate template = new SqlTemplate(conn)) {
        assertThrows(UncheckedSqlException.class, template::begin);
      }
      mocked.verify(() -> UncheckedSqlException.exception(eq(conn), any()));
    }
  }

  @Test
  void commitThrowsUncheckedSqlExceptionWhenCommitFails() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.getAutoCommit()).thenReturn(false);
    doThrow(new SQLException("commit failed")).when(conn).commit();

    UncheckedSqlException mockEx =
        new UncheckedSqlException(new SQLException(mock(SQLException.class)));

    try (MockedStatic<UncheckedSqlException> mocked = mockStatic(UncheckedSqlException.class)) {
      mocked.when(() -> UncheckedSqlException.exception(any(), any())).thenReturn(mockEx);

      try (SqlTemplate template = new SqlTemplate(conn)) {
        assertThrows(UncheckedSqlException.class, template::commit);
      }
      mocked.verify(() -> UncheckedSqlException.exception(eq(conn), any()));
    }
  }

  @Test
  void rollbackThrowsUncheckedSqlExceptionWhenRollbackFails() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.getAutoCommit()).thenReturn(false);
    doThrow(new SQLException("rollback failed")).when(conn).rollback();

    UncheckedSqlException mockEx =
        new UncheckedSqlException(new SQLException(mock(SQLException.class)));

    try (MockedStatic<UncheckedSqlException> mocked = mockStatic(UncheckedSqlException.class)) {
      mocked.when(() -> UncheckedSqlException.exception(any(), any())).thenReturn(mockEx);

      try (SqlTemplate template = new SqlTemplate(conn)) {
        assertThrows(UncheckedSqlException.class, template::rollback);
      }
      mocked.verify(() -> UncheckedSqlException.exception(eq(conn), any()));
    }
  }

  @Test
  void closeThrowsUncheckedSqlExceptionWhenCloseFails() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.isClosed()).thenReturn(false);
    doThrow(new SQLException("close failed")).when(conn).close();

    UncheckedSqlException mockEx =
        new UncheckedSqlException(new SQLException(mock(SQLException.class)));

    try (MockedStatic<UncheckedSqlException> mocked = mockStatic(UncheckedSqlException.class)) {
      mocked.when(() -> UncheckedSqlException.exception(any(), any())).thenReturn(mockEx);

      SqlTemplate template = new SqlTemplate(conn);
      assertThrows(UncheckedSqlException.class, template::close);
      mocked.verify(() -> UncheckedSqlException.exception(eq(conn), any()));
    }
  }

  @Test
  void commitDoesNothingWhenAutoCommitIsTrue() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.getAutoCommit()).thenReturn(true);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      template.commit();
    }
    // Asegurarse de que commit y setAutoCommit no fueron llamados
    verify(conn, never()).commit();
    verify(conn, never()).setAutoCommit(true);
  }

  @Test
  void rollbackDoesNothingWhenAutoCommitIsTrue() throws SQLException {
    Connection conn = mock(Connection.class);
    when(conn.getAutoCommit()).thenReturn(true);

    try (SqlTemplate template = new SqlTemplate(conn)) {
      template.rollback();
    }
    // Asegurarse de que rollback y setAutoCommit no fueron llamados
    verify(conn, never()).rollback();
    verify(conn, never()).setAutoCommit(true);
  }

  @Test
  void isSqlserverThrowsUncheckedSqlExceptionOnMetadataFailure() throws SQLException {
    Connection conn = mock(Connection.class);
    DatabaseMetaData meta = mock(DatabaseMetaData.class);

    when(conn.getMetaData()).thenReturn(meta);
    when(meta.getDriverName()).thenThrow(new SQLException("Metadata error"));

    UncheckedSqlException expected = new UncheckedSqlException(new SQLException("mocked"));

    try (MockedStatic<UncheckedSqlException> mocked = mockStatic(UncheckedSqlException.class)) {
      mocked.when(() -> UncheckedSqlException.exception(any(), any())).thenReturn(expected);

      try (SqlTemplate template = new SqlTemplate(conn)) {
        // Invocar método privado indirectamente a través de método que lo use
        assertThrows(UncheckedSqlException.class, () -> template.withQueryLock("SELECT * FROM t"));
      }
      mocked.verify(() -> UncheckedSqlException.exception(eq(conn), any()));
    }
  }

  @Test
  void createSpanWithValidCurrentSpanCreatesSpan() {
    Tracer tracer = mock(Tracer.class);
    Connection conn = mock(Connection.class);

    // Mock del span y su contexto válido
    Span span = mock(Span.class);
    SpanContext context = mock(SpanContext.class);
    when(context.isValid()).thenReturn(true);
    when(span.getSpanContext()).thenReturn(context);

    // Mock del SpanBuilder
    SpanBuilder spanBuilder = mock(SpanBuilder.class);
    when(tracer.spanBuilder("my-span")).thenReturn(spanBuilder);
    when(spanBuilder.setParent(any())).thenReturn(spanBuilder);
    when(spanBuilder.setSpanKind(any())).thenReturn(spanBuilder);
    Span resultSpan = mock(Span.class);
    when(spanBuilder.startSpan()).thenReturn(resultSpan);

    try (MockedStatic<Span> mockedSpan = mockStatic(Span.class)) {
      mockedSpan.when(Span::current).thenReturn(span);

      try (SqlTemplate template = new SqlTemplate(conn, tracer)) {
        Optional<Span> optSpan = template.createSpan("my-span");

        assertTrue(optSpan.isPresent());
        assertSame(resultSpan, optSpan.get());
      }
      mockedSpan.verify(Span::current);
      verify(tracer).spanBuilder("my-span");
      verify(spanBuilder).startSpan();
    }
  }

  @Test
  void createSpanWithInvalidParentSpanContextReturnsEmpty() {
    Tracer tracer = mock(Tracer.class);
    Connection conn = mock(Connection.class);

    Span parentSpan = mock(Span.class);
    SpanContext ctx = mock(SpanContext.class);
    when(ctx.isValid()).thenReturn(false);
    when(parentSpan.getSpanContext()).thenReturn(ctx);

    try (SqlTemplate template = new SqlTemplate(conn, tracer)) {
      Optional<Span> result = template.createSpan("query", Optional.of(parentSpan));

      assertTrue(result.isEmpty());
    }
  }

  @Test
  void createSpanWithAbsentParentReturnsEmpty() {
    Tracer tracer = mock(Tracer.class);
    Connection conn = mock(Connection.class);

    try (SqlTemplate template = new SqlTemplate(conn, tracer)) {
      Optional<Span> result = template.createSpan("query", Optional.empty());

      assertTrue(result.isEmpty());
    }
  }

  @Test
  void createSpanWithNullTracerReturnsEmpty() {
    Connection conn = mock(Connection.class);
    Span parent = mock(Span.class);
    try (SqlTemplate template = new SqlTemplate(conn, null)) {
      Optional<Span> result = template.createSpan("query", Optional.of(parent));
      assertTrue(result.isEmpty());
    }
  }

}
