/* @autogenerated */
package net.civeira.phylax.common.algorithms;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Queue;
import java.util.function.Predicate;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

class SliderTestUnitTest {

  private List<String> initialData;

  @BeforeEach
  void setup() {
    initialData = new ArrayList<>(Arrays.asList("apple", "banana", "carrot"));
  }

  /**
   * Concrete implementation for testing purposes.
   */
  static class TestSlider extends Slider<String> {
    private final Queue<Iterator<String>> batches;

    public TestSlider(Iterator<String> initial, int limit, Queue<Iterator<String>> batches) {
      super(initial, limit);
      this.batches = batches;
    }

    @Override
    public Iterator<String> next(List<String> valids, int limit) {
      return batches.isEmpty() ? null : batches.poll();
    }
  }

  @Test
  void testAllReturnsInitialData() {
    Slider<String> slider = new TestSlider(initialData.iterator(), 5, new LinkedList<>());
    List<String> all = slider.all();
    assertEquals(3, all.size());
    assertEquals("apple", all.get(0));
  }

  @Test
  void testOneReturnsElementIfOnlyOne() {
    Slider<String> slider =
        new TestSlider(Collections.singletonList("only").iterator(), 5, new LinkedList<>());
    Optional<String> result = slider.one();
    assertTrue(result.isPresent());
    assertEquals("only", result.get());
  }

  @Test
  void testOneThrowsIfMultiple() {
    Slider<String> slider = new TestSlider(initialData.iterator(), 5, new LinkedList<>());
    assertThrows(IllegalStateException.class, slider::one);
  }

  @Test
  void testOneReturnsEmptyIfNone() {
    Slider<String> slider = new TestSlider(Collections.emptyIterator(), 5, new LinkedList<>());
    Optional<String> result = slider.one();
    assertTrue(result.isEmpty());
  }

  @Test
  void testConstructorDoesNotDrainIterator() {
    int[] consumed = {0};
    Iterator<String> counting = new Iterator<String>() {
      private final String[] data = {"x", "y", "z"};
      private int idx = 0;

      @Override
      public boolean hasNext() {
        return idx < data.length;
      }

      @Override
      public String next() {
        consumed[0]++;
        return data[idx++];
      }
    };

    new TestSlider(counting, 5, new LinkedList<>());

    assertEquals(0, consumed[0], "Constructor must not consume the iterator eagerly");
  }

  @Test
  void testSlideWithAllItemsFilteredInFirstBatch() {
    // All items in the initial batch are rejected by the predicate.
    // This exercises the division-by-zero guard: filteredItems is empty when the
    // first batch exhausts, so matchCount == 0 and the discard ratio cannot be computed.
    Queue<Iterator<String>> batches = new LinkedList<>();
    batches.add(Arrays.asList("dog", "dolphin").iterator());

    Slider<String> slider =
        new TestSlider(Arrays.asList("cat", "cow", "chicken").iterator(), 3, batches);

    Iterator<String> result = slider.slide(s -> s.startsWith("d"));
    List<String> collected = new ArrayList<>();
    while (result.hasNext()) {
      collected.add(result.next());
    }

    assertEquals(List.of("dog", "dolphin"), collected);
  }

  @Test
  void testSlideWithoutNextPagination() {
    Queue<Iterator<String>> nextBatches = new LinkedList<>();
    Slider<String> slider = new TestSlider(initialData.iterator(), 2, nextBatches);

    Predicate<String> startsWithAorB = s -> s.startsWith("a") || s.startsWith("b");

    Iterator<String> result = slider.slide(startsWithAorB);
    List<String> collected = new ArrayList<>();
    while (result.hasNext()) {
      collected.add(result.next());
    }

    assertEquals(List.of("apple", "banana"), collected);
  }

  @Test
  void testSlideWithPagination() {
    Queue<Iterator<String>> batches = new LinkedList<>();
    batches.add(Arrays.asList("date", "elderberry").iterator());
    batches.add(Arrays.asList("fig").iterator());

    Slider<String> slider = new TestSlider(initialData.iterator(), 4, batches);

    Predicate<String> includeAll = s -> true;

    Iterator<String> result = slider.slide(includeAll);
    List<String> collected = new ArrayList<>();
    while (result.hasNext()) {
      collected.add(result.next());
    }

    assertEquals(List.of("apple", "banana", "carrot", "date"), collected.subList(0, 4));
    // Remaining items may still be available
    assertTrue(collected.size() >= 4);
  }

  @Test
  void testSlideStopsWhenNoMoreData() {
    Queue<Iterator<String>> batches = new LinkedList<>();
    batches.add(Arrays.asList("date", "elderberry").iterator());
    // No further batches

    Slider<String> slider = new TestSlider(initialData.iterator(), 10, batches);

    Predicate<String> onlyStartsWithD = s -> s.startsWith("d");

    Iterator<String> result = slider.slide(onlyStartsWithD);
    List<String> collected = new ArrayList<>();
    while (result.hasNext()) {
      collected.add(result.next());
    }

    assertTrue(collected.contains("date"));
    assertFalse(collected.contains("apple"));
    assertFalse(collected.contains("banana"));
  }

  @Test
  void testErrorOnNextForEmpty() {
    Queue<Iterator<String>> batches = new LinkedList<>();
    // No further batches

    List<String> strs = List.of();
    Slider<String> slider = new TestSlider(strs.iterator(), 10, batches);
    Predicate<String> onlyStartsWithD = s -> s.startsWith("d");

    Iterator<String> result = slider.slide(onlyStartsWithD);

    Assertions.assertThrows(NoSuchElementException.class, result::next);
  }

  @Test
  void testNextForEmptyPage() {
    Queue<Iterator<String>> batches = new LinkedList<>();
    batches.add(List.of("d1", "d2").iterator());
    // No further batches

    List<String> strs = List.of("x1", "x2");
    Slider<String> slider = new TestSlider(strs.iterator(), 10, batches);
    Predicate<String> onlyStartsWithD = s -> s.startsWith("d");

    Iterator<String> result = slider.slide(onlyStartsWithD);

    Assertions.assertEquals("d1", result.next());
    Assertions.assertEquals("d2", result.next());
    Assertions.assertThrows(NoSuchElementException.class, result::next);
  }
}
