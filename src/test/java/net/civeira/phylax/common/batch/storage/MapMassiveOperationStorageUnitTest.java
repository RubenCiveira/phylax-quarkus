/* @autogenerated */
package net.civeira.phylax.common.batch.storage;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.List;
import java.util.Optional;

import javax.sql.DataSource;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import net.civeira.phylax.common.batch.BatchProgress;
import net.civeira.phylax.common.batch.BatchProgress.GlobalStatus;
import net.civeira.phylax.common.batch.BatchStepProgress;
import net.civeira.phylax.common.batch.BatchStepProgress.Status;

class MapMassiveOperationStorageUnitTest {

  @Mock
  private DataSource dataSource;
  @Mock
  private Connection connection;
  @Mock
  private PreparedStatement stmt;
  @Mock
  private ResultSet resultSet;

  @Spy
  private ObjectMapper objectMapper = new ObjectMapper();

  @InjectMocks
  private MapMassiveOperationStorage storage;

  private final String task = "export-task";
  private final String actor = "user123";

  @BeforeEach
  void setup() throws Exception {
    MockitoAnnotations.openMocks(this);

    objectMapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
    objectMapper.findAndRegisterModules();

    when(dataSource.getConnection()).thenReturn(connection);
    when(connection.prepareStatement(anyString())).thenReturn(stmt);
    when(stmt.executeQuery()).thenReturn(resultSet);
  }

  @Test
  void testSaveInsertsNewRecord() throws Exception {
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getLong(1)).thenReturn(0L);
    when(stmt.executeUpdate()).thenReturn(1);

    BatchProgress progress = BatchProgress.builder().uid(task).startTime(Instant.now())
        .steps(List.of(progress(Status.PENDING))).build();

    storage.save(task, actor, progress);

    verify(connection, atLeastOnce()).prepareStatement(contains("INSERT INTO"));
  }

  @Test
  void testSaveUpdatesExistingRecord() throws Exception {
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getLong(1)).thenReturn(1L);
    when(stmt.executeUpdate()).thenReturn(1);

    BatchProgress progress = BatchProgress.builder().uid(task).startTime(Instant.now())
        .steps(List.of(progress(Status.PROCESSING))).build();

    storage.save(task, actor, progress);

    verify(connection, atLeastOnce()).prepareStatement(contains("UPDATE _long_tasks"));
  }

  @Test
  void testRestoresReturnsProgress() throws Exception {
    Instant now = Instant.now();
    String json = objectMapper.writeValueAsString(List.of(progress(Status.FINISHED)));

    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString(1)).thenReturn(json);
    when(resultSet.getTimestamp(2)).thenReturn(Timestamp.from(now));
    when(resultSet.getTimestamp(3)).thenReturn(null);

    Optional<BatchProgress> result = storage.restores(task, actor);

    assertTrue(result.isPresent());
    assertEquals(GlobalStatus.FINISHED, result.get().getStatus());
  }

  @Test
  void testRestoresReturnsEmptyWhenNoResult() throws Exception {
    when(resultSet.next()).thenReturn(false);

    Optional<BatchProgress> result = storage.restores(task, actor);

    assertTrue(result.isEmpty());
  }

  @Test
  void testFinishUpdatesCompletion() throws Exception {
    when(stmt.executeUpdate()).thenReturn(1);

    storage.finish(task, Instant.now().plusSeconds(3600), actor);

    verify(stmt, Mockito.times(2)).executeUpdate();
    verify(connection, atLeastOnce())
        .prepareStatement(contains("UPDATE _long_tasks SET completion"));
  }

  @Test
  void testSaveThrowsExceptionOnJsonError() throws Exception {
    ObjectMapper mockMapper = mock(ObjectMapper.class);
    MapMassiveOperationStorage faultyStorage =
        new MapMassiveOperationStorage(mockMapper, dataSource);

    when(mockMapper.writeValueAsString(any())).thenThrow(new JsonProcessingException("fail") {
      private static final long serialVersionUID = 1L;
    });
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getLong(1)).thenReturn(0L);

    BatchProgress progress =
        BatchProgress.builder().uid(task).startTime(Instant.now()).steps(List.of()).build();

    assertThrows(IllegalArgumentException.class, () -> faultyStorage.save(task, actor, progress));
  }

  @SuppressWarnings("unchecked")
  @Test
  void testRestoresThrowsExceptionOnJsonError() throws Exception {
    ObjectMapper mockMapper = mock(ObjectMapper.class);
    MapMassiveOperationStorage faultyStorage =
        new MapMassiveOperationStorage(mockMapper, dataSource);

    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString(1)).thenReturn("not-json");
    when(resultSet.getTimestamp(2)).thenReturn(Timestamp.from(Instant.now()));
    when(mockMapper.readValue(anyString(), any(TypeReference.class)))
        .thenThrow(new JsonProcessingException("bad json") {
          private static final long serialVersionUID = 1L;
        });

    assertThrows(IllegalArgumentException.class, () -> faultyStorage.restores(task, actor));
  }

  @Test
  void testSaveWhenResultSetNextReturnsFalse_ShouldInsert() throws Exception {
    // ResultSet is empty: treat as zero existing records and insert
    when(resultSet.next()).thenReturn(false);
    when(stmt.executeUpdate()).thenReturn(1);

    BatchProgress progress = BatchProgress.builder().uid(task).startTime(Instant.now())
        .steps(List.of(progress(Status.PENDING))).build();

    storage.save(task, actor, progress);

    verify(connection, atLeastOnce()).prepareStatement(contains("INSERT INTO"));
  }

  @Test
  void testSaveInsertFailsWhenExecuteUpdateReturnsZero() throws Exception {
    // count = 0 → insert path; executeUpdate returns 0 to simulate failure
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getLong(1)).thenReturn(0L);
    when(stmt.executeUpdate()).thenReturn(0);

    BatchProgress progress = BatchProgress.builder().uid(task).startTime(Instant.now())
        .steps(List.of(progress(Status.PENDING))).build();

    assertThrows(IllegalArgumentException.class, () -> storage.save(task, actor, progress));
  }

  @Test
  void testSaveUpdateFailsWhenExecuteUpdateReturnsZero() throws Exception {
    when(resultSet.next()).thenReturn(true);
    when(resultSet.getLong(1)).thenReturn(1L); // count = 1 → update path
    when(stmt.executeUpdate()).thenReturn(0); // update returns 0 to simulate failure

    BatchProgress progress = BatchProgress.builder().uid(task).startTime(Instant.now())
        .steps(List.of(progress(Status.PROCESSING))).build();

    assertThrows(IllegalArgumentException.class, () -> storage.save(task, actor, progress));
  }

  @Test
  void testFinishThrowsWhenUpdateResultIsNotOne() throws Exception {
    when(stmt.executeUpdate()).thenReturn(0); // simulate failure
    when(connection.prepareStatement(anyString())).thenReturn(stmt);

    Instant expiration = Instant.now().plusSeconds(3600);

    assertThrows(IllegalArgumentException.class, () -> {
      storage.finish(task, expiration, actor);
    });

    verify(stmt, Mockito.times(2)).executeUpdate();
  }

  @Test
  void testFinishThrowsWhenSQLExceptionOccurs() throws Exception {
    when(connection.prepareStatement(anyString())).thenThrow(new SQLException("DB is down"));

    Instant expiration = Instant.now().plusSeconds(3600);

    assertThrows(IllegalArgumentException.class, () -> {
      storage.finish(task, expiration, actor);
    });

    verify(connection).prepareStatement(anyString());
  }

  @Test
  void testRestoresWithNonNullCompletionTimestamp() throws Exception {
    Instant start = Instant.now().minusSeconds(600);
    Instant end = Instant.ofEpochMilli(System.currentTimeMillis());

    List<BatchStepProgress> steps = List.of(progress(Status.FINISHED));
    String json = objectMapper.writeValueAsString(steps);

    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString(1)).thenReturn(json);
    when(resultSet.getTimestamp(2)).thenReturn(Timestamp.from(start));
    when(resultSet.getTimestamp(3)).thenReturn(Timestamp.from(end));

    Optional<BatchProgress> result = storage.restores(task, actor);

    assertTrue(result.isPresent());
    assertEquals(end, result.get().getEndTime());
    assertEquals(GlobalStatus.FINISHED, result.get().getStatus());
  }

  @Test
  void testGlobalStatusAllPending() throws Exception {
    List<BatchStepProgress> steps = List.of(progress(Status.PENDING), progress(Status.PENDING));
    String json = objectMapper.writeValueAsString(steps);

    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString(1)).thenReturn(json);
    when(resultSet.getTimestamp(2)).thenReturn(Timestamp.from(Instant.now()));
    when(resultSet.getTimestamp(3)).thenReturn(null);

    Optional<BatchProgress> result = storage.restores(task, actor);

    assertTrue(result.isPresent());
    assertEquals(GlobalStatus.PENDING, result.get().getStatus());
  }

  @Test
  void testGlobalStatusSomeProcessing() throws Exception {
    List<BatchStepProgress> steps = List.of(progress(Status.PROCESSING), progress(Status.PENDING));
    String json = objectMapper.writeValueAsString(steps);

    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString(1)).thenReturn(json);
    when(resultSet.getTimestamp(2)).thenReturn(Timestamp.from(Instant.now()));
    when(resultSet.getTimestamp(3)).thenReturn(null);

    Optional<BatchProgress> result = storage.restores(task, actor);

    assertTrue(result.isPresent());
    assertEquals(GlobalStatus.PROCESSING, result.get().getStatus());
  }

  @Test
  void testGlobalStatusSomeFailed() throws Exception {
    List<BatchStepProgress> steps = List.of(progress(Status.FINISHED), progress(Status.FAILED));
    String json = objectMapper.writeValueAsString(steps);

    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString(1)).thenReturn(json);
    when(resultSet.getTimestamp(2)).thenReturn(Timestamp.from(Instant.now()));
    when(resultSet.getTimestamp(3)).thenReturn(null);

    Optional<BatchProgress> result = storage.restores(task, actor);

    assertTrue(result.isPresent());
    assertEquals(GlobalStatus.FAILED, result.get().getStatus());
  }

  @Test
  void testGlobalStatusAllFinished() throws Exception {
    List<BatchStepProgress> steps = List.of(progress(Status.FINISHED), progress(Status.FINISHED));
    String json = objectMapper.writeValueAsString(steps);

    when(resultSet.next()).thenReturn(true);
    when(resultSet.getString(1)).thenReturn(json);
    when(resultSet.getTimestamp(2)).thenReturn(Timestamp.from(Instant.now()));
    when(resultSet.getTimestamp(3)).thenReturn(null);

    Optional<BatchProgress> result = storage.restores(task, actor);

    assertTrue(result.isPresent());
    assertEquals(GlobalStatus.FINISHED, result.get().getStatus());
  }

  private BatchStepProgress progress(Status status) {
    BatchStepProgress bp = new BatchStepProgress();
    bp.setStatus(status);
    return bp;
  }
}
