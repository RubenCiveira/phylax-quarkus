/* @autogenerated */
package net.civeira.phylax.common.batch;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Optional;

import org.eclipse.microprofile.context.ManagedExecutor;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;

import net.civeira.phylax.common.batch.storage.MassiveOperationStorage;

class BatchServiceUnitTest {

  private MassiveOperationStorage storage;
  private ManagedExecutor executor;
  private BatchService service;

  @BeforeEach
  void setup() {
    storage = mock(MassiveOperationStorage.class);
    executor = mock(ManagedExecutor.class);
    service = new BatchService(storage, executor);
  }

  @Nested
  @DisplayName("start()")
  class Start {

    @Test
    @DisplayName("should initialize batch and run steps asynchronously")
    void testStartInitializesAndRunsBatch() {
      ExecutorPlan<String> plan = ExecutorPlan.<String>builder().name("step1").params("data")
          .executor((result, monitor, param) -> result.addOk("executed")).build();

      when(executor.runAsync(any())).thenAnswer(invocation -> {
        Runnable r = invocation.getArgument(0);
        r.run();
        return null;
      });

      BatchIdentificator identificator = service.start("user1", Duration.ofMinutes(5), plan);

      assertNotNull(identificator.getUid());
      assertEquals(List.of("step1"), identificator.getSteps());
      verify(storage, atLeastOnce()).save(eq(identificator.getUid()), eq("user1"), any());
      verify(storage).finish(eq(identificator.getUid()), any(), eq("user1"));
    }

    @Test
    @DisplayName("should record step as FAILED and continue when executor throws RuntimeException")
    void testStartHandlesExceptionInExecutor() {
      ExecutorPlan<String> plan = ExecutorPlan.<String>builder().name("stepWithError")
          .params("data").executor((result, monitor, param) -> {
            throw new RuntimeException("Failure");
          }).build();

      when(executor.runAsync(any())).thenAnswer(invocation -> {
        Runnable r = invocation.getArgument(0);
        r.run();
        return null;
      });

      BatchIdentificator identificator = service.start("user1", Duration.ofSeconds(1), plan);

      assertNotNull(identificator);
      verify(storage, atLeastOnce()).save(eq(identificator.getUid()), eq("user1"), any());
      verify(storage).finish(eq(identificator.getUid()), any(), eq("user1"));
    }

    @Test
    @DisplayName("should execute multiple steps in declaration order")
    void testStartExecutesMultipleStepsInSequence() {
      List<String> executionOrder = new ArrayList<>();

      ExecutorPlan<String> step1 = ExecutorPlan.<String>builder().name("step-a").params("p1")
          .executor((result, monitor, param) -> executionOrder.add("step-a")).build();
      ExecutorPlan<String> step2 = ExecutorPlan.<String>builder().name("step-b").params("p2")
          .executor((result, monitor, param) -> executionOrder.add("step-b")).build();
      ExecutorPlan<String> step3 = ExecutorPlan.<String>builder().name("step-c").params("p3")
          .executor((result, monitor, param) -> executionOrder.add("step-c")).build();

      when(executor.runAsync(any())).thenAnswer(invocation -> {
        Runnable r = invocation.getArgument(0);
        r.run();
        return null;
      });

      BatchIdentificator id = service.start("actor", Duration.ofMinutes(1), step1, step2, step3);

      assertEquals(List.of("step-a", "step-b", "step-c"), executionOrder,
          "Steps must execute in the declared order");
      assertEquals(List.of("step-a", "step-b", "step-c"), id.getSteps());
      verify(storage).finish(eq(id.getUid()), any(), eq("actor"));
    }

    @Test
    @DisplayName("should always call storage.finish() even when a step fails")
    void testFinishIsAlwaysCalledAfterStepFailure() {
      ExecutorPlan<String> failing = ExecutorPlan.<String>builder().name("failing-step").params("x")
          .executor((result, monitor, param) -> {
            throw new RuntimeException("intentional failure");
          }).build();
      ExecutorPlan<String> following = ExecutorPlan.<String>builder().name("following-step")
          .params("y").executor((result, monitor, param) -> result.addOk("ok")).build();

      when(executor.runAsync(any())).thenAnswer(invocation -> {
        ((Runnable) invocation.getArgument(0)).run();
        return null;
      });

      BatchIdentificator id = service.start("actor", Duration.ofSeconds(30), failing, following);

      verify(storage).finish(eq(id.getUid()), any(), eq("actor"));
    }

    @Test
    @DisplayName("should invoke monitor callback and persist progress mid-step")
    void testStartTriggersMonitorUpdateViaExecutor() {
      MassiveOperationStorage realStorage = mock(MassiveOperationStorage.class);
      ManagedExecutor localExecutor = mock(ManagedExecutor.class);
      BatchService localService = new BatchService(realStorage, localExecutor);

      @SuppressWarnings("unchecked")
      Executor<String> mockExecutor = mock(Executor.class);

      ExecutorPlan<String> plan = ExecutorPlan.<String>builder().name("step-monitored")
          .params("monitored-data").executor(mockExecutor).build();

      when(localExecutor.runAsync(any())).thenAnswer(invocation -> {
        ((Runnable) invocation.getArgument(0)).run();
        return null;
      });

      BatchIdentificator id = localService.start("actor42", Duration.ofMinutes(1), plan);

      ArgumentCaptor<BatchStepProgress> progressCaptor =
          ArgumentCaptor.forClass(BatchStepProgress.class);
      ArgumentCaptor<Monitor> monitorCaptor = ArgumentCaptor.forClass(Monitor.class);
      ArgumentCaptor<String> paramCaptor = ArgumentCaptor.forClass(String.class);

      verify(mockExecutor).run(progressCaptor.capture(), monitorCaptor.capture(),
          paramCaptor.capture());

      // Simulate the executor calling the monitor mid-step
      monitorCaptor.getValue().updateState(progressCaptor.getValue());

      verify(realStorage, atLeastOnce()).save(eq(id.getUid()), eq("actor42"), any());
    }
  }

  @Nested
  @DisplayName("retrieve()")
  class Retrieve {

    @Test
    @DisplayName("should delegate to storage and return progress when found")
    void testRetrieveDelegatesToStorage() {
      BatchProgress progress =
          BatchProgress.builder().uid("job123").status(BatchProgress.GlobalStatus.PENDING)
              .steps(List.of()).startTime(java.time.Instant.now()).build();

      when(storage.restores("job123", "actor1")).thenReturn(Optional.of(progress));

      Optional<BatchProgress> result = service.retrieve("job123", Locale.ENGLISH, "actor1");

      assertTrue(result.isPresent());
      assertEquals("job123", result.get().getUid());
      verify(storage).restores("job123", "actor1");
    }

    @Test
    @DisplayName("should return empty when batch uid does not exist for actor")
    void testRetrieveReturnsEmptyWhenNotFound() {
      when(storage.restores("missing", "actor1")).thenReturn(Optional.empty());

      Optional<BatchProgress> result = service.retrieve("missing", Locale.ENGLISH, "actor1");

      assertTrue(result.isEmpty());
      verify(storage).restores("missing", "actor1");
    }
  }
}
