/* @autogenerated */
package net.civeira.phylax.common.batch;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.time.Duration;
import java.util.List;
import java.util.Locale;
import java.util.Optional;

import org.eclipse.microprofile.context.ManagedExecutor;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;

import net.civeira.phylax.common.batch.storage.MasiveOperationStorage;

class BatchServiceUnitTest {

  private MasiveOperationStorage storage;
  private ManagedExecutor executor;
  private BatchService service;
  private SleepService sleeper;

  @BeforeEach
  void setup() {
    storage = mock(MasiveOperationStorage.class);
    executor = mock(ManagedExecutor.class);
    sleeper = mock(SleepService.class);
    service = new BatchService(storage, executor);
  }

  @Test
  void testStartInitializesAndRunsBatch() {
    ExecutorPlan<String> plan = ExecutorPlan.<String>builder().name("step1").params("data")
        .executor((result, monitor, param) -> result.addOk("executed")).build();

    when(executor.runAsync(any())).thenAnswer(invocation -> {
      Runnable r = invocation.getArgument(0);
      r.run(); // simulate async
      return null;
    });

    BatchIdentificator identificator = service.start("user1", Duration.ofMinutes(5), plan);

    assertNotNull(identificator.getUid());
    assertEquals(List.of("step1"), identificator.getSteps());
    verify(storage, atLeastOnce()).save(eq(identificator.getUid()), eq("user1"), any());
    verify(storage).finish(eq(identificator.getUid()), any(), eq("user1"));
  }

  @Test
  void testStartHandlesExceptionInExecutor() {
    ExecutorPlan<String> plan = ExecutorPlan.<String>builder().name("stepWithError").params("data")
        .executor((result, monitor, param) -> {
          throw new RuntimeException("Failure");
        }).build();

    when(executor.runAsync(any())).thenAnswer(invocation -> {
      Runnable r = invocation.getArgument(0);
      r.run(); // simulate async
      return null;
    });

    BatchIdentificator identificator = service.start("user1", Duration.ofSeconds(1), plan);

    assertNotNull(identificator);
    verify(storage, atLeastOnce()).save(eq(identificator.getUid()), eq("user1"), any());
    verify(storage).finish(eq(identificator.getUid()), any(), eq("user1"));
  }

  @Test
  void testRetrieveDelegatesToStorage() {
    BatchProgress progress =
        BatchProgress.builder().uid("job123").status(BatchProgress.GlobalStatus.PENDING)
            .steps(List.of()).startTime(java.time.Instant.now()).build();

    when(storage.restores("job123", "actor1")).thenReturn(Optional.of(progress));

    Optional<BatchProgress> result = service.retrieve("job123", Locale.ENGLISH, "actor1");

    assertTrue(result.isPresent());
    assertEquals("job123", result.get().getUid());
    verify(storage).restores("job123", "actor1");
  }

  @Test
  void testStartTriggersMonitorUpdateViaExecutor() {
    // Arrange
    MasiveOperationStorage realStorage = mock(MasiveOperationStorage.class);
    ManagedExecutor executor = mock(ManagedExecutor.class);
    BatchService service = new BatchService(realStorage, executor) {
      @Override
      protected SleepService sleeper() {
        return sleeper;
      }
    };

    @SuppressWarnings("unchecked")
    Executor<String> mockExecutor = mock(Executor.class);

    ExecutorPlan<String> plan = ExecutorPlan.<String>builder().name("step-monitored")
        .params("monitored-data").executor(mockExecutor).build();

    // Run the async part synchronously
    when(executor.runAsync(any())).thenAnswer(invocation -> {
      Runnable task = invocation.getArgument(0);
      task.run();
      return null;
    });

    // Act
    BatchIdentificator id = service.start("actor42", Duration.ofMinutes(1), plan);

    // Capture the arguments passed to the Executor.run(...)
    ArgumentCaptor<BatchStepProgress> progressCaptor =
        ArgumentCaptor.forClass(BatchStepProgress.class);
    ArgumentCaptor<Monitor> monitorCaptor = ArgumentCaptor.forClass(Monitor.class);
    ArgumentCaptor<String> paramCaptor = ArgumentCaptor.forClass(String.class);

    verify(mockExecutor).run(progressCaptor.capture(), monitorCaptor.capture(),
        paramCaptor.capture());

    // Act: invoke monitor callback manually
    Monitor capturedMonitor = monitorCaptor.getValue();
    capturedMonitor.updateState(progressCaptor.getValue());

    // Assert: verify that storage.save() was called inside monitor callback
    verify(realStorage, atLeastOnce()).save(eq(id.getUid()), eq("actor42"), any());
  }

  @Test
  void testSleepHandlesInterruptedExceptionFromSleepService() throws InterruptedException {
    // Arrange: forzar InterruptedException al simular el delay
    BatchService service = new BatchService(storage, executor) {
      @Override
      protected SleepService sleeper() {
        return sleeper;
      }
    };

    doThrow(new InterruptedException("interrupted")).when(sleeper).sleep(5000L);

    ExecutorPlan<String> plan = ExecutorPlan.<String>builder().name("interrupted-sleep")
        .params("param").executor((result, monitor, param) -> result.addOk("ok")).build();

    when(executor.runAsync(any())).thenAnswer(invocation -> {
      Runnable r = invocation.getArgument(0);
      assertDoesNotThrow(r::run); // La excepción es capturada por BatchService
      return null;
    });

    // Act
    service.start("actor", Duration.ofSeconds(1), plan);

    // Assert
    verify(sleeper).sleep(5000L); // se llamó correctamente
    verify(storage, atLeastOnce()).save(any(), eq("actor"), any());
  }
}
