/* @autogenerated */
package net.civeira.phylax.common.batch;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.time.Instant;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import org.junit.jupiter.api.Test;

import net.civeira.phylax.common.batch.BatchStepProgress.ErrorInfo;
import net.civeira.phylax.common.batch.BatchStepProgress.Status;
import net.civeira.phylax.common.value.validation.AbstractFail;
import net.civeira.phylax.common.value.validation.AbstractFail.LocalizedFail;
import net.civeira.phylax.common.value.validation.AbstractFail.LocalizedWrongValue;

class LocalizedBatchStepProgressUnitTest {

  @Test
  void testFromWithBasicFields() {
    // Arrange
    BatchStepProgress step = new BatchStepProgress();
    step.setName("step-test");
    step.setStatus(Status.FINISHED);
    step.setError(null);
    step.setStartTime(Instant.parse("2024-01-01T10:00:00Z"));
    step.setEndTime(Instant.parse("2024-01-01T10:05:00Z"));
    step.setTotalItems(5);
    step.setProcessedItems(5);
    step.setOks(List.of("ok1", "ok2"));

    // Act
    LocalizedBatchStepProgress localized = LocalizedBatchStepProgress.from(step, Locale.ENGLISH);

    // Assert
    assertNotNull(localized);
    assertEquals("step-test", localized.getName());
    assertEquals(Status.FINISHED, localized.getStatus());
    assertEquals(2, localized.getOks().size());
    assertTrue(localized.getErrors().isEmpty());
    assertTrue(localized.getWarns().isEmpty());
  }

  @Test
  void testFromWithLocalizedErrorsAndWarnings() {
    // Arrange
    AbstractFail failMock1 = mock(AbstractFail.class);
    AbstractFail failMock2 = mock(AbstractFail.class);

    LocalizedFail localizedFail1 = LocalizedFail.builder().code("code1").description("msg1")
        .wrongValues(
            List.of(LocalizedWrongValue.builder().field("field1").wrongValue("val1").build()))
        .build();
    LocalizedFail localizedFail2 = LocalizedFail.builder().code("code2").description("msg2")
        .wrongValues(
            List.of(LocalizedWrongValue.builder().field("field2").wrongValue("val2").build()))
        .build();

    when(failMock1.localize(Locale.ENGLISH, true)).thenReturn(localizedFail1);
    when(failMock2.localize(Locale.ENGLISH, true)).thenReturn(localizedFail2);

    ErrorInfo errorInfo1 = new ErrorInfo(failMock1);
    ErrorInfo warnInfo = new ErrorInfo(failMock2);

    BatchStepProgress step = new BatchStepProgress();
    step.setName("step");
    step.setStatus(Status.FAILED);
    step.setStartTime(Instant.now());
    step.setEndTime(Instant.now());
    step.setErrors(Map.of("item-1", errorInfo1));
    step.setWarns(Map.of("item-2", warnInfo));

    // Act
    LocalizedBatchStepProgress result = LocalizedBatchStepProgress.from(step, Locale.ENGLISH);

    // Assert
    assertEquals(1, result.getErrors().size());
    assertEquals("item-1", result.getErrors().get(0).getItem());
    assertEquals(1, result.getErrors().get(0).getFails().size());
    assertEquals("code1", result.getErrors().get(0).getFails().get(0).getCode());

    assertEquals(1, result.getWarns().size());
    assertEquals("item-2", result.getWarns().get(0).getItem());
    assertEquals("code2", result.getWarns().get(0).getFails().get(0).getCode());
  }

  @Test
  void testMapMapReturnsEmptyListWhenMapIsNull() {
    List<LocalizedBatchStepProgress.LocalizedErrorInfo> result = invokeMapMap(null, Locale.ENGLISH);
    assertNotNull(result);
    assertTrue(result.isEmpty());
  }

  @Test
  void testFrom_WithNullFails_ReturnsInfoWithNullFailsList() {
    // Arrange
    AbstractFail failMock = mock(AbstractFail.class);
    BatchStepProgress.ErrorInfo errorInfo = new BatchStepProgress.ErrorInfo(failMock);
    errorInfo.setFails(null); // Explicitly set fails to null

    // Act
    LocalizedBatchStepProgress.LocalizedErrorInfo result =
        LocalizedBatchStepProgress.from(errorInfo, Locale.ENGLISH);

    // Assert
    assertNotNull(result);
    assertNull(result.getFails(), "Fails list should be null when input fails are null");
  }

  // Helper to invoke private static method mapMap() using reflection
  @SuppressWarnings("unchecked")
  private List<LocalizedBatchStepProgress.LocalizedErrorInfo> invokeMapMap(
      Map<String, ErrorInfo> input, Locale locale) {
    try {
      var method =
          LocalizedBatchStepProgress.class.getDeclaredMethod("mapMap", Map.class, Locale.class);
      method.setAccessible(true);
      return (List<LocalizedBatchStepProgress.LocalizedErrorInfo>) method.invoke(null, input,
          locale);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }
}
