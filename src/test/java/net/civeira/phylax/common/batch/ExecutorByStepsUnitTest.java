/* @autogenerated */
package net.civeira.phylax.common.batch;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import net.civeira.phylax.common.exception.AbstractFailsException;
import net.civeira.phylax.common.value.validation.ExecutionFail;

class ExecutorByStepsUnitTest {

  private BatchStepProgress progress;
  private Monitor monitor;
  private SleepService sleeper;

  @BeforeEach
  void setup() {
    progress = new BatchStepProgress();
    monitor = mock(Monitor.class);
    sleeper = mock(SleepService.class);
  }

  @Test
  void testRunWithEmptyInput() {
    DummyExecutor executor = new DummyExecutor(null, List.of(), false, false);
    executor.run(progress, monitor, "param");

    assertEquals(0, progress.getProcessedItems());
    verify(monitor, atLeastOnce()).updateState(progress);
    assertTrue(executor.finishedCalled.get());
  }

  @Test
  void testWriteThrowsAbstractFailsException() {
    DummyExecutor executor = new DummyExecutor(sleeper, List.of("a"), false, false) {
      @Override
      protected void write(String item, String param) {
        throw new AbstractFailsException("", new ExecutionFail("code", "fail")) {
          private static final long serialVersionUID = 1L;
        };
      }
    };
    executor.run(progress, monitor, "param");
    assertEquals(1, progress.getErrors().size());
  }

  @Test
  void testBufferFlushesWhenFull() {
    DummyExecutor executor = new DummyExecutor(sleeper,
        List.of("a", "b", "c", "d", "a", "b", "c", "d", "a", "b", "c", "d", "a", "b", "c", "d"),
        false, false) {
      int writeCount = 0;

      @Override
      protected void write(String item, String param) {
        super.write(item, param);
        writeCount++;
      }

      @Override
      protected void finish(String param) {
        assertTrue(writeCount >= 1); // depending on bufferSize
        finishedCalled.set(true);
      }
    };

    executor.run(progress, monitor, "param");
    assertTrue(executor.finishedCalled.get());
  }

  @Test
  void testProcessReturnsNull() {
    DummyExecutor executor = new DummyExecutor(sleeper, List.of("a"), false, false) {
      @Override
      protected String process(String item, String param) {
        return null;
      }
    };

    executor.run(progress, monitor, "param");
    assertEquals(0, progress.getProcessedItems());
    assertTrue(progress.getOks() == null || progress.getOks().isEmpty());
  }

  @Test
  void testProcessThrowsAbstractFailsException() {
    DummyExecutor executor = new DummyExecutor(sleeper, List.of("a"), false, false) {
      @Override
      protected String process(String item, String param) {
        throw new AbstractFailsException("", new ExecutionFail("code", "fail")) {
          private static final long serialVersionUID = 1L;
        };
      }
    };

    executor.run(progress, monitor, "param");
    assertEquals(1, progress.getErrors().size());
  }

  @Test
  void testSleepThrowsInterruptedException() throws InterruptedException {
    SleepService sleeper = mock(SleepService.class);
    doThrow(new InterruptedException("simulated")).when(sleeper).sleep(100);

    DummyExecutor executor = new DummyExecutor(sleeper, List.of("a", "b"), false, false);
    executor.run(progress, monitor, "param");

    assertEquals(2, progress.getProcessedItems());
    assertTrue(executor.finishedCalled.get());
    verify(monitor, atLeastOnce()).updateState(progress);
  }


  @Test
  void testRunSuccessFlow() {
    DummyExecutor executor = new DummyExecutor(sleeper, List.of("a", "b"), false, false);
    executor.run(progress, monitor, "param");

    assertEquals(2, progress.getProcessedItems());
    verify(monitor, atLeastOnce()).updateState(progress);
    assertTrue(executor.finishedCalled.get());
  }

  @Test
  void testRunWithProcessingException() {
    DummyExecutor executor = new DummyExecutor(sleeper, List.of("a", "b"), true, false);
    executor.run(progress, monitor, "param");
    assertEquals(1, progress.getErrors().size()); // Only "a" succeeded
    assertEquals(2, progress.getProcessedItems()); // Only "a" succeeded
    assertTrue(progress.getErrors().containsKey("b"));
    assertTrue(executor.finishedCalled.get());
  }

  @Test
  void testRunWithWritingException() {
    DummyExecutor executor = new DummyExecutor(sleeper, List.of("a", "b"), false, true);
    executor.run(progress, monitor, "param");

    assertEquals(2, progress.getProcessedItems());
    assertTrue(progress.getErrors().containsKey("b"));
    assertTrue(executor.finishedCalled.get());
  }

  // Inner class to simulate behavior
  static class DummyExecutor extends ExecutorBySteps<String, String, String> {

    private final List<String> items;
    private final boolean throwOnProcess;
    private final boolean throwOnWrite;
    private final SleepService sleeper;
    AtomicBoolean finishedCalled = new AtomicBoolean(false);

    DummyExecutor(SleepService sleeper, List<String> items, boolean throwOnProcess,
        boolean throwOnWrite) {
      this.sleeper = sleeper;
      this.items = items;
      this.throwOnProcess = throwOnProcess;
      this.throwOnWrite = throwOnWrite;
    }

    @Override
    protected SleepService sleeper() {
      return null == sleeper ? super.sleeper() : sleeper;
    }

    @Override
    protected List<String> read(String param) {
      return items;
    }

    @Override
    protected String process(String item, String param) {
      super.process(item, param);
      if (throwOnProcess && "b".equals(item)) {
        throw new RuntimeException("Processing failed");
      }
      return item.toUpperCase();
    }

    @Override
    protected void write(String item, String param) {
      if (throwOnWrite && "B".equals(item)) {
        throw new RuntimeException("Write failed");
      }
    }

    @Override
    protected void finish(String param) {
      super.finish(param);
      finishedCalled.set(true);
    }

    @Override
    protected String itemDescriptor(String input) {
      super.itemDescriptor(input);
      return input;
    }
  }
}
