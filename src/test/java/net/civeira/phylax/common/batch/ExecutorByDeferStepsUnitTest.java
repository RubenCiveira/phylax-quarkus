/* @autogenerated */
package net.civeira.phylax.common.batch;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.mockStatic;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;

import io.quarkus.arc.Arc;
import io.quarkus.arc.ArcContainer;
import io.quarkus.arc.InstanceHandle;
import io.quarkus.arc.ManagedContext;
import net.civeira.phylax.common.batch.stepper.ItemDescriptor;
import net.civeira.phylax.common.batch.stepper.ItemProcessor;
import net.civeira.phylax.common.batch.stepper.ItemReader;
import net.civeira.phylax.common.batch.stepper.ItemWriter;
import net.civeira.phylax.common.batch.stepper.StepCounter;
import net.civeira.phylax.common.batch.stepper.StepFinalizer;
import net.civeira.phylax.common.batch.stepper.StepInitializer;
import net.civeira.phylax.common.exception.AbstractFailsException;
import net.civeira.phylax.common.value.validation.ExecutionFail;

@SuppressWarnings("unchecked")
class ExecutorByDeferStepsUnitTest {

  ItemReader<String, Object, Object> reader = mock(ItemReader.class);
  ItemProcessor<String, String, Object, Object> processor = mock(ItemProcessor.class);
  ItemWriter<String, Object, Object> writer = mock(ItemWriter.class);
  ItemDescriptor<String, Object, Object> descriptor = mock(ItemDescriptor.class);
  StepInitializer<Object, Object> initializer = mock(StepInitializer.class);
  StepFinalizer<Object, Object> finalizer = mock(StepFinalizer.class);
  StepCounter<Object, Object> counter = mock(StepCounter.class);
  BatchStepProgress progress = mock(BatchStepProgress.class);
  Monitor monitor = mock(Monitor.class);

  Object param = new Object();

  MockedStatic<Arc> arcStatic;
  ArcContainer arcContainer = mock(ArcContainer.class);
  ManagedContext managedContext = mock(ManagedContext.class);

  @BeforeEach
  void setupArcMocking() {
    arcStatic = mockStatic(Arc.class);

    // Simula Arc.container()
    arcStatic.when(Arc::container).thenReturn(arcContainer);

    // Simula el contexto de request (siempre no activo para probar .activate())
    when(arcContainer.requestContext()).thenReturn(managedContext);
    when(managedContext.isActive()).thenReturn(false);

    // Simula las instancias de CDI
    when(arcContainer.instance(ItemReader.class)).thenReturn(handle(reader));
    when(arcContainer.instance(ItemProcessor.class)).thenReturn(handle(processor));
    when(arcContainer.instance(ItemWriter.class)).thenReturn(handle(writer));
    when(arcContainer.instance(ItemDescriptor.class)).thenReturn(handle(descriptor));
    when(arcContainer.instance(StepInitializer.class)).thenReturn(handle(initializer));
    when(arcContainer.instance(StepFinalizer.class)).thenReturn(handle(finalizer));
    when(arcContainer.instance(StepCounter.class)).thenReturn(handle(counter));
  }

  @AfterEach
  void tearDown() {
    arcStatic.close(); // Limpia el mock estático
  }

  private <T> InstanceHandle<T> handle(T instance) {
    return new InstanceHandle<T>() {
      @Override
      public T get() {
        return instance;
      }

      @Override
      public void destroy() {
        // no-op for test
      }

      @Override
      public boolean isAvailable() {
        return true;
      }
    };
  }

  @Test
  void testSuccessfulExecutionUsingArc() throws Exception {
    when(reader.read(any())).thenReturn(List.of("a", "b")).thenReturn(Collections.emptyList());
    when(processor.process(any(), any())).thenReturn("A", "B");
    when(descriptor.itemDescription(any(), any())).thenReturn("desc");

    ExecutorByDeferSteps<String, String, Object, Object> executor =
        ExecutorByDeferSteps.<String, String, Object, Object>builder().reader(ItemReader.class)
            .writer(ItemWriter.class).processor(ItemProcessor.class)
            .descriptor(ItemDescriptor.class).initializer(StepInitializer.class)
            .finalizer(StepFinalizer.class).counter(StepCounter.class).bufferSize(2).readSleep(0)
            .processSleep(0).writeSleep(0).build();

    executor.run(progress, monitor, param);

    verify(initializer).init(any());
    verify(finalizer).finish(any());
    verify(writer).write(eq(List.of("A", "B")), any());
    verify(progress, times(2)).addOk("desc");
  }

  @Test
  @SuppressWarnings("rawtypes")
  void testProcessorThrowsAbstractFailsException() throws Exception {
    AbstractFailsException afe = mock(AbstractFailsException.class);
    Stream str = List.of(new ExecutionFail("failCode", "failMsg")).stream();
    when(afe.getFails()).thenReturn(str);

    when(reader.read(any())).thenReturn(List.of("x")).thenReturn(Collections.emptyList());
    when(processor.process(any(), any())).thenThrow(afe);
    when(descriptor.itemDescription(any(), any())).thenReturn("ref-x");

    ExecutorByDeferSteps<String, String, Object, Object> executor = ExecutorByDeferSteps
        .<String, String, Object, Object>builder().reader(ItemReader.class).writer(ItemWriter.class)
        .processor(ItemProcessor.class).descriptor(ItemDescriptor.class).build();

    executor.run(progress, monitor, param);

    verify(progress).addError(eq("ref-x"), any());
  }

  @Test
  void testWriterThrowsException() throws Exception {
    when(reader.read(any())).thenReturn(List.of("a")).thenReturn(Collections.emptyList());
    when(processor.process(any(), any())).thenReturn("A");

    doThrow(new RuntimeException("Write failed")).when(writer).write(any(), any());
    when(descriptor.itemDescription(any(), any())).thenReturn("a");

    ExecutorByDeferSteps<String, String, Object, Object> executor = ExecutorByDeferSteps
        .<String, String, Object, Object>builder().reader(ItemReader.class).writer(ItemWriter.class)
        .processor(ItemProcessor.class).descriptor(ItemDescriptor.class).build();

    executor.run(progress, monitor, param);

    verify(progress).addError(eq("a"), any(ExecutionFail.class));
  }

  @Test
  void testContextIsAlreadyActive() {
    when(managedContext.isActive()).thenReturn(true); // cambia el comportamiento

    when(reader.read(any())).thenReturn(Collections.emptyList());

    ExecutorByDeferSteps<String, String, Object, Object> executor = ExecutorByDeferSteps
        .<String, String, Object, Object>builder().reader(ItemReader.class).writer(ItemWriter.class)
        .processor(ItemProcessor.class).descriptor(ItemDescriptor.class).build();

    executor.run(progress, monitor, param);

    // Verifica que no se haya activado el contexto manualmente
    verify(managedContext, times(0)).activate();
  }

  @Test
  void testDescriptorIsNullUsesFallback() throws Exception {
    when(reader.read(any())).thenReturn(List.of("item")).thenReturn(Collections.emptyList());
    when(processor.process(any(), any())).thenReturn("processed");

    ExecutorByDeferSteps<String, String, Object, Object> executor =
        ExecutorByDeferSteps.<String, String, Object, Object>builder().reader(ItemReader.class)
            .writer(ItemWriter.class).processor(ItemProcessor.class).descriptor(null) // <--- clave:
                                                                                      // usar
                                                                                      // descriptor
                                                                                      // == null
            .build();

    executor.run(progress, monitor, param);

    verify(progress).addOk(eq("item")); // item.toString() será "item"
  }

  @Test
  void testReaderReturnsNullList() throws Exception {
    when(reader.read(any())).thenReturn(null); // <--- null list

    ExecutorByDeferSteps<String, String, Object, Object> executor = ExecutorByDeferSteps
        .<String, String, Object, Object>builder().reader(ItemReader.class).writer(ItemWriter.class)
        .processor(ItemProcessor.class).descriptor(ItemDescriptor.class).build();

    executor.run(progress, monitor, param);

    // Si no hay items, no debe escribirse nada
    verify(writer, times(0)).write(any(), any());
  }

  @Test
  void testReaderReturnsEmptyList() throws Exception {
    when(reader.read(any())).thenReturn(Collections.emptyList()); // empty list

    ExecutorByDeferSteps<String, String, Object, Object> executor = ExecutorByDeferSteps
        .<String, String, Object, Object>builder().reader(ItemReader.class).writer(ItemWriter.class)
        .processor(ItemProcessor.class).descriptor(ItemDescriptor.class).build();

    executor.run(progress, monitor, param);

    // No se procesan ni escriben items
    verify(writer, times(0)).write(any(), any());
  }

  @Test
  void testSleepThrowsInterruptedException() throws Exception {
    // Creamos un executor con un sleeper mockeado
    SleepService sleeper = mock(SleepService.class);
    doThrow(new InterruptedException("sleep interrupted")).when(sleeper).sleep(anyLong());

    ExecutorByDeferSteps<String, String, Object, Object> executor =
        new ExecutorByDeferSteps<>(100, 100, 100, 1, StepInitializer.class, ItemProcessor.class,
            ItemReader.class, ItemWriter.class, ItemDescriptor.class, null, null) {
          @Override
          protected SleepService sleeper() {
            return sleeper; // Sobrescribimos el sleeper para forzar la excepción
          }
        };

    when(reader.read(any())).thenReturn(List.of("x")).thenReturn(Collections.emptyList());
    when(processor.process(any(), any())).thenReturn("X");
    when(descriptor.itemDescription(any(), any())).thenReturn("x");

    executor.run(progress, monitor, param);

    assertTrue(Thread.currentThread().isInterrupted()); // <- se marcó como interrumpido
  }

  @Test
  void testProcessorThrowsGenericException() throws Exception {
    when(reader.read(any())).thenReturn(List.of("x")).thenReturn(Collections.emptyList());
    when(processor.process(any(), any())).thenThrow(new IllegalStateException("unexpected error"));
    when(descriptor.itemDescription(any(), any())).thenReturn("x");

    ExecutorByDeferSteps<String, String, Object, Object> executor = ExecutorByDeferSteps
        .<String, String, Object, Object>builder().reader(ItemReader.class).writer(ItemWriter.class)
        .processor(ItemProcessor.class).descriptor(ItemDescriptor.class).build();

    executor.run(progress, monitor, param);

    verify(progress).addError(eq("x"), any(ExecutionFail.class));
  }
}
